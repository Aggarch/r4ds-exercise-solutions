[
["vectors.html", "20 Vectors 20.1 Introduction 20.2 Vector Basics 20.3 Important Types of Atomic Vector 20.4 Using atomic vectors 20.5 Recursive Vectors (lists) 20.6 Attributes 20.7 Augmented Vectors", " 20 Vectors 20.1 Introduction library(&quot;tidyverse&quot;) 20.2 Vector Basics No exercises 20.3 Important Types of Atomic Vector 20.3.1 Exercise 1 Describe the difference between is.finite(x) and !is.infinite(x). To find out, try the functions on a numeric vector that includes a number and the five special values (NA, NaN, Inf, -Inf). x &lt;- c(0, NA, NaN, Inf, -Inf) is.finite(x) #&gt; [1] TRUE FALSE FALSE FALSE FALSE !is.infinite(x) #&gt; [1] TRUE TRUE TRUE FALSE FALSE is.finite considers only a number to be finite, and considers missing (NA), not a number (NaN), and positive and negative infinity to be not finite. However, since is.infinite only considers Inf and -Inf to be infinite, !is.infinite considers 0 as well as missing and not-a-number to be not infinite. So NA and NaN are neither finite or infinite. Mind blown. 20.3.2 Exercise 2 Read the source code for dplyr::near() (Hint: to see the source code, drop the ()). How does it work? The source for dplyr::near is: dplyr::near #&gt; function (x, y, tol = .Machine$double.eps^0.5) #&gt; { #&gt; abs(x - y) &lt; tol #&gt; } #&gt; &lt;bytecode: 0x7f8e65193740&gt; #&gt; &lt;environment: namespace:dplyr&gt; Instead of checking for exact equality, it checks that two numbers are within a certain tolerance, tol. By default the tolerance is set to the square root of .Machine$double.eps, which is the smallest floating point number that the computer can represent. 20.3.3 Exercise 3 A logical vector can take 3 possible values. How many possible values can an integer vector take? How many possible values can a double take? Use Google to do some research. The help for .Machine describes some of this: As all current implementations of R use 32-bit integers and uses IEC 60559 floating-point (double precision) arithmetic, The IEC 60559 or IEEE 754 format uses a 64 bit vector, but 20.3.4 Exercise 4 Brainstorm at least four functions that allow you to convert a double to an integer. How do they differ? Be precise. Broadly, could convert a double to an integer by truncating or rounding to the nearest integer. For truncating or for handling ties (doubles ending in 0.5), there are multiple methods for determining which integer value to go to. methods 0.5 -0.5 1.5 -1.5 towards zero: 0 0 1 1 away from zero 1 -1 2 -2 largest towards \\(+\\infty\\)) 1 0 2 -1 smallest (towards \\(-\\infty\\)) 0 -1 1 -2 even 0 0 2 -2 odd 1 -1 1 -1 See the Wikipedia article IEEE floating point for rounding rules. For rounding, R and many programming languages use the IEEE standard. This is “round to nearest, ties to even”. This is not the same as what you See the value of looking at the value of .Machine$double.rounding and its documentation. x &lt;- seq(-10, 10, by = 0.5) round2 &lt;- function(x, to_even = TRUE) { q &lt;- x %/% 1 r &lt;- x %% 1 q + (r &gt;= 0.5) } x &lt;- c(-12.5, -11.5, 11.5, 12.5) round(x) #&gt; [1] -12 -12 12 12 round2(x, to_even = FALSE) #&gt; [1] -12 -11 12 13 The problem with the always rounding 0.5 up rule is that it is biased upwards. Rounding to nearest with ties towards even is not. Consider the sequence \\(-100.5, -99.5, \\dots, 0, \\dots, 99.5, 100.5\\). Its sum is 0. It would be nice if rounding preserved that sum. Using the “ties towards even”, the sum is still zero. However, the “ties towards \\(+\\infty\\)” produces a non-zero number. x &lt;- seq(-100.5, 100.5, by = 1) sum(x) #&gt; [1] 0 sum(round(x)) #&gt; [1] 0 sum(round2(x)) #&gt; [1] 101 Here’s a real-world non-engineering example of rounding going terribly wrong. In 1983, the Vancouver stock exchange adjusted its index from 524.811 to 1098.892 to correct for accumulated error due to rounding to three decimal points (see Vancouver Stock Exchange). Here’s a list of a few more. 20.3.5 Exercise 5 What functions from the readr package allow you to turn a string into logical, integer, and double vector? The functions parse_logical, parse_integer, and parse_number. parse_logical(c(&quot;TRUE&quot;, &quot;FALSE&quot;, &quot;1&quot;, &quot;0&quot;, &quot;true&quot;, &quot;t&quot;, &quot;NA&quot;)) #&gt; [1] TRUE FALSE TRUE FALSE TRUE TRUE NA parse_integer(c(&quot;1235&quot;, &quot;0134&quot;, &quot;NA&quot;)) #&gt; [1] 1235 134 NA parse_number(c(&quot;1.0&quot;, &quot;3.5&quot;, &quot;1,000&quot;, &quot;NA&quot;)) #&gt; [1] 1.0 3.5 1000.0 NA Read the documentation of read_number. In order to ignore things like currency symbols and comma separators in number strings it ignores them using a heuristic. 20.4 Using atomic vectors 20.4.1 Exercise 1 What does mean(is.na(x)) tell you about a vector x? What about sum(!is.finite(x))? The expression mean(is.na(x)) calculates the proportion of missing values in a vector x &lt;- c(1:10, NA, NaN, Inf, -Inf) mean(is.na(x)) #&gt; [1] 0.143 The expression mean(!is.finite(x)) calculates the proportion of values that are NA, NaN, or infinite. mean(!is.finite(x)) #&gt; [1] 0.286 20.4.2 Exercise 2 Carefully read the documentation of is.vector(). What does it actually test for? Why does is.atomic() not agree with the definition of atomic vectors above? The function is.vector only checks whether the object has no attributes other than names. Thus a list is a vector: is.vector(list(a = 1, b = 2)) #&gt; [1] TRUE But any object that has an attribute (other than names) is not: x &lt;- 1:10 attr(x, &quot;something&quot;) &lt;- TRUE is.vector(x) #&gt; [1] FALSE The idea behind this is that object oriented classes will include attributes, including, but not limited to &quot;class&quot;. The function is.atomic explicitly checks whether an object is one of the atomic types (“logical”, “integer”, “numeric”, “complex”, “character”, and “raw”) or NULL. is.atomic(1:10) #&gt; [1] TRUE is.atomic(list(a = 1)) #&gt; [1] FALSE The function is.atomic will consider objects to be atomic even if they have extra attributes. is.atomic(x) #&gt; [1] TRUE 20.4.3 Exercise 3 Compare and contrast setNames() with purrr::set_names(). These are simple functions, so we can simply print out their source code: setNames #&gt; function (object = nm, nm) #&gt; { #&gt; names(object) &lt;- nm #&gt; object #&gt; } #&gt; &lt;bytecode: 0x7f8e64238b90&gt; #&gt; &lt;environment: namespace:stats&gt; purrr::set_names #&gt; function (x, nm = x, ...) #&gt; { #&gt; set_names_impl(x, x, nm, ...) #&gt; } #&gt; &lt;bytecode: 0x7f8e645f9358&gt; #&gt; &lt;environment: namespace:rlang&gt; From the code we can see that set_names adds a few sanity checks: x has to be a vector, and the lengths of the object and the names have to be the same. 20.4.4 Exercise 4 Create functions that take a vector as input and returns: The last value. Should you use [ or [[? The elements at even numbered positions. Every element except the last value. Only even numbers (and no missing values). last_value &lt;- function(x) { # check for case with no length if (length(x)) { # Use [[ as suggested because it returns one element x[[length(x)]] } else { x } } last_value(numeric()) #&gt; numeric(0) last_value(1) #&gt; [1] 1 last_value(1:10) #&gt; [1] 10 even_indices &lt;- function(x) { if (length(x)) { x[seq_along(x) %% 2 == 0] } else { x } } even_indices(numeric()) #&gt; numeric(0) even_indices(1) #&gt; numeric(0) even_indices(1:10) #&gt; [1] 2 4 6 8 10 # test using case to ensure that values not indices # are being returned even_indices(letters) #&gt; [1] &quot;b&quot; &quot;d&quot; &quot;f&quot; &quot;h&quot; &quot;j&quot; &quot;l&quot; &quot;n&quot; &quot;p&quot; &quot;r&quot; &quot;t&quot; &quot;v&quot; &quot;x&quot; &quot;z&quot; not_last &lt;- function(x) { if (length(x)) { x[-length(x)] } else { x } } not_last(1:5) #&gt; [1] 1 2 3 4 even_numbers &lt;- function(x) { x[!is.na(x) &amp; (x %% 2 == 0)] } even_numbers(-10:10) #&gt; [1] -10 -8 -6 -4 -2 0 2 4 6 8 10 20.4.5 Exercise 5 Why is x[-which(x &gt; 0)] not the same as x[x &lt;= 0]? They will treat missing values differently. x &lt;- c(-5:5, Inf, -Inf, NaN, NA) x[-which(x &gt; 0)] #&gt; [1] -5 -4 -3 -2 -1 0 -Inf NaN NA -which(x &gt; 0) #&gt; [1] -7 -8 -9 -10 -11 -12 x[x &lt;= 0] #&gt; [1] -5 -4 -3 -2 -1 0 -Inf NA NA x &lt;= 0 #&gt; [1] TRUE TRUE TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE #&gt; [12] FALSE TRUE NA NA -which(x &gt; 0) which calculates the indexes for any value that is TRUE and ignores NA. Thus is keeps NA and NaN because the comparison is not TRUE. x &lt;= 0 works slightly differently. If x &lt;= 0 returns TRUE or FALSE it works the same way. However, if the comparison generates a NA, then it will always keep that entry, but set it to NA. This is why the last two values of x[x &lt;= 0] are NA rather than c(NaN, NA). 20.4.6 Exercise 6 What happens when you subset with a positive integer that’s bigger than the length of the vector? What happens when you subset with a name that doesn’t exist? When you subset with positive integers that are larger than the length of the vector, NA values are returned for those integers larger than the length of the vector. (1:10)[11:12] #&gt; [1] NA NA When a vector is subset with a name that doesn’t exist, an error is generated. c(a = 1, 2)[[&quot;b&quot;]] #&gt; Error in c(a = 1, 2)[[&quot;b&quot;]]: subscript out of bounds 20.5 Recursive Vectors (lists) 20.5.1 Exercise 1 Draw the following lists as nested sets: list(a, b, list(c, d), list(e, f)) list(list(list(list(list(list(a)))))) There are a variety of ways to draw these graphs. The original digrams in R for Data Science were produced with Graffle. You could also use various drawing or slide software, such as Illustrator, Powerpoint, Keynote, Google Slides. For these examples, I generated these diagrams programmatically using the DiagrammeR R package to render Graphviz diagrams. The nested set diagram for list(a, b, list(c, d), list(e, f)) is The nested set diagram for list(list(list(list(list(list(a)))))) is as follows. 20.5.2 Exercise 2 What happens if you subset a tibble as if you’re subsetting a list? What are the key differences between a list and a tibble? Subsetting a tibble works the same way as a list; a data frame can be thought of as a list of columns. The key different between a list and a tibble is that a tibble (data frame) has the restriction that all its elements (columns) must have the same length. x &lt;- tibble(a = 1:2, b = 3:4) x[[&quot;a&quot;]] #&gt; [1] 1 2 x[&quot;a&quot;] #&gt; # A tibble: 2 x 1 #&gt; a #&gt; &lt;int&gt; #&gt; 1 1 #&gt; 2 2 x[1] #&gt; # A tibble: 2 x 1 #&gt; a #&gt; &lt;int&gt; #&gt; 1 1 #&gt; 2 2 x[1, ] #&gt; # A tibble: 1 x 2 #&gt; a b #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 3 20.6 Attributes No exercises 20.7 Augmented Vectors 20.7.1 Exercise 1 What does hms::hms(3600) return? How does it print? What primitive type is the augmented vector built on top of? What attributes does it use? x &lt;- hms::hms(3600) class(x) #&gt; [1] &quot;hms&quot; &quot;difftime&quot; x #&gt; 01:00:00 hms::hms returns an object of class, and prints the time in “%H:%M:%S” format. The primitive type is a double typeof(x) #&gt; [1] &quot;double&quot; The attributes is uses are &quot;units&quot; and &quot;class&quot;. attributes(x) #&gt; $class #&gt; [1] &quot;hms&quot; &quot;difftime&quot; #&gt; #&gt; $units #&gt; [1] &quot;secs&quot; 20.7.2 Exercise 2 Try and make a tibble that has columns with different lengths. What happens? If I try to create at tibble with a scalar and column of a different length there are no issues, and the scalar is repeated to the length of the longer vector. tibble(x = 1, y = 1:5) #&gt; # A tibble: 5 x 2 #&gt; x y #&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 1 1 #&gt; 2 1 2 #&gt; 3 1 3 #&gt; 4 1 4 #&gt; 5 1 5 However, if I try to create a tibble with two vectors of different lengths (other than one), the tibble function throws an error. tibble(x = 1:3, y = 1:4) #&gt; Error: Column `x` must be length 1 or 4, not 3 20.7.3 Exercise 3 Based on the definition above, is it OK to have a list as a column of a tibble? If I didn’t already know the answer, what I would do is try it out. From the above, the error message was about vectors having different lengths. But there is nothing that prevents a tibble from having vectors of different types: doubles, character, integers, logical, factor, date. The later are still atomic, but they have additional attributes. So, maybe there won’t be an issue with a list vector as long as it is the same length. tibble(x = 1:3, y = list(&quot;a&quot;, 1, list(1:3))) #&gt; # A tibble: 3 x 2 #&gt; x y #&gt; &lt;int&gt; &lt;list&gt; #&gt; 1 1 &lt;chr [1]&gt; #&gt; 2 2 &lt;dbl [1]&gt; #&gt; 3 3 &lt;list [1]&gt; It works! I even used a list with heterogeneous types and there wasn’t an issue. In following chapters we’ll see that list vectors can be very useful: for example, when processing many different models. "]
]
