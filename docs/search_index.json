[
["index.html", "Exercise Solutions and Notes for “R for Data Science” Welcome", " Exercise Solutions and Notes for “R for Data Science” Jeffrey B. Arnold Welcome This contains my exercise solutions and notes for Hadley Wickham and Garret Grolemund, R for Data Science. The original website is at r4ds.had.co.nz. Note that the chapter and section numbers don’t exactly match those of R4DS. Refer to the titles, not the numbers. The text of this work is licensed under the Creative Commons Attribution 4.0 International License. The R Code in this work is licensed under the MIT License. "],
["explore-intro.html", "1 Introduction", " 1 Introduction No exercises. "],
["visualize.html", "2 Visualize 2.1 Introduction 2.2 Position Adjustments 2.3 Coordinate Systems", " 2 Visualize 2.1 Introduction 2.1.1 Prerequisites library(&quot;tidyverse&quot;) Other resources All the graph things Stat 545. Jenny Bryan. 2.1.2 First Steps 2.1.2.1 Exercises Run ggplot(data = mpg) what do you see? ggplot(data = mpg) Nothing. The plot is created, but ggplot is not given any data to plot. How many rows are in mtcars? How many columns? nrow(mtcars) #&gt; [1] 32 ncol(mtcars) #&gt; [1] 11 This can also be found by printing the dataset, or looking in the environment pane. What does the drv variable describe? Read the help for ?mpg to find out. ?mpg The drv variable takes the following values &quot;f&quot; = front-wheel drive &quot;r&quot; = rear wheel drive &quot;4&quot; = 4wd Make a scatterplot of hwy vs cyl ggplot(mpg, aes(x = hwy, y = cyl)) + geom_point() What happens if you make a scatterplot of class vs drv. Why is the plot not useful? ggplot(mpg, aes(x = class, y = drv)) + geom_point() A scatterplot is not a useful way to plot these variables, since both drv and class are factor variables, and the scatterplot cannot show which are overlapping or not. count(mpg, drv, class) #&gt; Source: local data frame [12 x 3] #&gt; Groups: drv [?] #&gt; #&gt; drv class n #&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 4 compact 12 #&gt; 2 4 midsize 3 #&gt; 3 4 pickup 33 #&gt; 4 4 subcompact 4 #&gt; 5 4 suv 51 #&gt; 6 f compact 35 #&gt; # ... with 6 more rows 2.1.3 Aesthetic mappings 2.1.3.1 Exercises What’s gone wrong with this code? Why are the points not blue? ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = &quot;blue&quot;)) Since color = &quot;blue&quot; was included within the mapping argument, it was treated as an aesthetic (a mapping between a variable and a value). It was treated as a variable which has only one value: “blue”. Which variables in mpg are categorical? Which variables are continuous? (Hint: type ?mpg to read the documentation for the dataset). How can you see this information when you run mpg? ?mpg When printing the data frame, this information is given at the top of each column within angled brackets. Categorical variables have a class of “character” (&lt;chr&gt;). mpg #&gt; # A tibble: 234 × 11 #&gt; manufacturer model displ year cyl trans drv cty hwy fl #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; #&gt; 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p #&gt; 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p #&gt; 3 audi a4 2.0 2008 4 manual(m6) f 20 31 p #&gt; 4 audi a4 2.0 2008 4 auto(av) f 21 30 p #&gt; 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p #&gt; 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p #&gt; # ... with 228 more rows, and 1 more variables: class &lt;chr&gt; The glimpse command from “mpg” shows this: glimpse(mpg) #&gt; Observations: 234 #&gt; Variables: 11 #&gt; $ manufacturer &lt;chr&gt; &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;... #&gt; $ model &lt;chr&gt; &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4 qua... #&gt; $ displ &lt;dbl&gt; 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0,... #&gt; $ year &lt;int&gt; 1999, 1999, 2008, 2008, 1999, 1999, 2008, 1999, 1... #&gt; $ cyl &lt;int&gt; 4, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6... #&gt; $ trans &lt;chr&gt; &quot;auto(l5)&quot;, &quot;manual(m5)&quot;, &quot;manual(m6)&quot;, &quot;auto(av)... #&gt; $ drv &lt;chr&gt; &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;,... #&gt; $ cty &lt;int&gt; 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 1... #&gt; $ hwy &lt;int&gt; 29, 29, 31, 30, 26, 26, 27, 26, 25, 28, 27, 25, 2... #&gt; $ fl &lt;chr&gt; &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;,... #&gt; $ class &lt;chr&gt; &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;comp... Map a continuous variable to color, size, and shape. How do these aesthetics behave differently for categorical vs. continuous variables? The variable cty, city highway miles per gallon, is a continuous variable: ggplot(mpg, aes(x = displ, y = hwy, color = cty)) + geom_point() Instead of using discrete colors, the continous variable uses a scale that goes from black to bluish. ggplot(mpg, aes(x = displ, y = hwy, size = cty)) + geom_point() When mapped to size, the sizes of the points vary continuously with respect to the size (although the legend shows a few representative values) ggplot(mpg, aes(x = displ, y = hwy, shape = cty)) + geom_point() #&gt; Error: A continuous variable can not be mapped to shape When a continuous value is mapped to shape, it gives an error. Though we could split a continuous variable into discrete categories and use shape, this would conceptually not make sense. A continuous numeric variable is ordered, but shapes have no natural order. It is clear that smaller points correspond to smaller values, or once the color scale is given, which points are larger or smaller. But it is not clear whether a square is greater or less than a circle. What happens if you map the same variable to multiple aesthetics? ggplot(mpg, aes(x = displ, y = hwy, color = hwy, size = displ)) + geom_point() In the above plot, hwy is mapped to both location on the y-axis and color, and displ is mapped to both location on the x-axis and size. The code works and produces a plot, even if it is a bad one. Mapping a single variable to multiple aesthetics is redundant. Because it is redundant information, in most cases avoid mapping a single variable to multiple aesthetics. What does the stroke aesthetic do? What shapes does it work with? (Hint: use ?geom_point) The following example is given in ?geom_point: ggplot(mtcars, aes(wt, mpg)) + geom_point(shape = 21, colour = &quot;black&quot;, fill = &quot;white&quot;, size = 5, stroke = 5) Stroke changes the color of the border for shapes (22-24). What happens if you map an aesthetic to something other than a variable name, like aes(colour = displ &lt; 5)? ggplot(mpg, aes(x = displ, y = hwy, colour = displ &lt; 5)) + geom_point() Aesthetics can also be mapped to expressions (code like displ &lt; 5). It will create a temporary variable which takes values from the result of the expression. In this case, it is logical variable which is TRUE or FALSE. This also explains exercise 1, color = &quot;blue&quot; created a categorical variable that only had one category: “blue”. 2.1.4 Facets 2.1.4.1 Exercises What happens if you facet on a continuous variable? Let’s see ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() + facet_grid(. ~ cty) It converts the continuous varible to a factor and creates facets for all unique values of it. What do the empty cells in plot with facet_grid(drv ~ cyl) mean? How do they relate to this plot? They are cells in which there are no values of the combination of drv and cyl. ggplot(data = mpg) + geom_point(mapping = aes(x = drv, y = cyl)) The locations in the above plot without points are the same cells in facet_grid(drv ~ cyl) tha have no points. What plots does the following code make? What does . do? The symbol . ignores that dimension for faceting. This plot facets by values of drv on the y-axis: ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_grid(drv ~ .) This plot facets by values of cyl on the x-axis: ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_grid(. ~ cyl) Read ?facet_wrap. What does nrow do? What does ncol do? What other options control the layout of the individual panels? Why doesn’t facet_grid() have nrow and ncol variables? The arguments nrow (ncol) determines the number of rows (columns) to use when laying out the facets. It is necessary since facet_wrap only facets on one variable. These arguments are unnecessary for facet_grid since the number of rows and columns are determined by the number of unique values of the variables specified. When using facet_grid() you should usually put the variable with more unique levels in the columns. Why? You should put the variable with more unique levels in the columns if the plot is laid out landscape. It is easier to compare relative levels of y by scanning horizontally, so it may be easier to visually compare these levels. I’m actually not sure about the correct answer to this. 2.1.5 Geometric Objects What does show.legend = FALSE do? What happens if you remove it? Why do you think I used it earlier in the chapter? NOTE This doesn’t appear earlier in the chapter Issue #510 What does the se argument to geom_smooth() do? It adds standard error bands to the lines. ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + geom_point() + geom_smooth(se = TRUE) #&gt; `geom_smooth()` using method = &#39;loess&#39; By default se = TRUE: ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + geom_point() + geom_smooth() #&gt; `geom_smooth()` using method = &#39;loess&#39; Will these two graphs look different? Why/why not? No. Because both geom_point and geom_smooth use the same data and mappings. They will inherit those options from the ggplot object, and thus don’t need to specified again (or twice). ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point() + geom_smooth() #&gt; `geom_smooth()` using method = &#39;loess&#39; ggplot() + geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy)) #&gt; `geom_smooth()` using method = &#39;loess&#39; Recreate the R code necessary to generate the following graphs. ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() + geom_smooth(se = FALSE) #&gt; `geom_smooth()` using method = &#39;loess&#39; ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() + geom_smooth(mapping = aes(group = drv), se = FALSE) #&gt; `geom_smooth()` using method = &#39;loess&#39; ggplot(mpg, aes(x = displ, y = hwy, colour = drv)) + geom_point() + geom_smooth(se = FALSE) #&gt; `geom_smooth()` using method = &#39;loess&#39; ggplot(mpg, aes(x = displ, y = hwy)) + geom_point(mapping = aes(colour = drv)) + geom_smooth(se = FALSE) #&gt; `geom_smooth()` using method = &#39;loess&#39; ggplot(mpg, aes(x = displ, y = hwy)) + geom_point(aes(colour = drv)) + geom_smooth(aes(linetype = drv), se = FALSE) #&gt; `geom_smooth()` using method = &#39;loess&#39; ggplot(mpg, aes(x = displ, y = hwy, fill = drv)) + geom_point(color = &quot;white&quot;, shape = 21) 2.1.6 Statistical Transformations What is the default geom associated with stat_summary()? How could you rewrite the previous plot to use that geom function instead of the stat function? The default geom for stat_summary is geom_pointrange (see the stat) argument. But, the default stat for geom_pointrange is identity, so use geom_pointrange(stat = &quot;summary&quot;). ggplot(data = diamonds) + geom_pointrange( mapping = aes(x = cut, y = depth), stat = &quot;summary&quot;, ) #&gt; No summary function supplied, defaulting to `mean_se() The default message says that stat_summary uses the mean and sd to calculate the point, and range of the line. So lets use the previous values of fun.ymin, fun.ymax, and fun.y: ggplot(data = diamonds) + geom_pointrange( mapping = aes(x = cut, y = depth), stat = &quot;summary&quot;, fun.ymin = min, fun.ymax = max, fun.y = median ) What does geom_col() do? How is it different to geom_bar()? geom_col differs from geom_bar in its default stat. geom_col has uses the identity stat. So it expects that a variable already exists for the height of the bars. geom_bar uses the count stat, and so will count observations in groups in order to generate the variable to use for the height of the bars. Most geoms and stats come in pairs that are almost always used in concert. Read through the documentation and make a list of all the pairs. What do they have in common? See the ggplot2 documentation What variables does stat_smooth() compute? What parameters control its behaviour? stat_smooth calculates y: predicted value ymin: lower value of the confidence interval ymax: upper value of the confidence interval se: standard error There’s parameters such as method which determines which method is used to calculate the predictions and confidence interval, and some other arguments that are passed to that. In our proportion bar chart, we need to set group = 1 Why? In other words what is the problem with these two graphs? If group is not set to 1, then all the bars have prop == 1. The function geom_bar assumes that the groups are equal to the x values, since the stat computes the counts within the group. ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, y = ..prop..)) The problem with these two plots is that the proportions are calculated within the groups. ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, y = ..prop..)) ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = color, y = ..prop..)) This is more likely what was intended: ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, y = ..prop.., group = 1)) ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = color, y = ..prop.., group = color)) 2.2 Position Adjustments What is the problem with this plot? How could you improve it? There is overplotting because there are multiple observations for each combination of cty and hwy. ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + geom_point() I’d fix it by using a jitter positition adjustment. ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + geom_point(position = &quot;jitter&quot;) What parameters to geom_jitter() control the amount of jittering? From the position_jitter documentation, there are two arguments to jitter: width and height, which control the amount of vertical and horizontal jitter. No horizontal jitter ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + geom_point(position = position_jitter(width = 0)) Way too much vertical jitter ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + geom_point(position = position_jitter(width = 0, height = 15)) Only horizontal jitter: ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + geom_point(position = position_jitter(height = 0)) Way too much horizontal jitter: ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + geom_point(position = position_jitter(height = 0, width = 20)) Compare and contrast geom_jitter() with geom_count(). What’s the default position adjustment for geom_boxplot()? Create a visualisation of the mpg dataset that demonstrates it. The default position for geom_boxplot is position_dodge (see its docs). When we add color = class to the boxplot, the different classes within drv are placed side by side, i.e. dodged. If it was position_identity, they would be overlapping. ggplot(data = mpg, aes(x = drv, y = hwy, color = class)) + geom_boxplot() ggplot(data = mpg, aes(x = drv, y = hwy, color = class)) + geom_boxplot(position = &quot;identity&quot;) 2.3 Coordinate Systems 2.3.1 Exercises Turn a stacked bar chart into a pie chart using coord_polar(). This is a stacked bar chart with a single category ggplot(mpg, aes(x = factor(1), fill = drv)) + geom_bar() See the documentation for coord_polar for an example of making a pie chart. In particular, theta = &quot;y&quot;, meaning that the angle of the chart is the y variable has to be specified. ggplot(mpg, aes(x = factor(1), fill = drv)) + geom_bar(width = 1) + coord_polar(theta = &quot;y&quot;) If theta = &quot;y&quot; is not specified, then you get a bullseye chart ggplot(mpg, aes(x = factor(1), fill = drv)) + geom_bar(width = 1) + coord_polar() If you had a multiple stacked bar chart, like, ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = clarity), position = &quot;fill&quot;) you end up with a multi-donut chart ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = clarity), position = &quot;fill&quot;) + coord_polar(theta = &quot;y&quot;) What does labs() do? Read the documentation. labs is a shortcut function to add labels to different scales. ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + geom_boxplot() + coord_flip() + labs(y = &quot;Highway MPG&quot;, x = &quot;&quot;) What’s the difference between coord_quickmap() and coord_map()? See the docs: coord_map uses a 2D projection: by default the Mercatur project of the sphere to the plot. But this requires transforming all geoms. coord_quickmap uses a quick approximation by using the lat/long ratio as an approximation. This is “quick” because the shapes don’t need to be transformed. What does the plot below tell you about the relationship between city and highway mpg? Why is coord_fixed() important? What does geom_abline() do? The coordinates coord_fixed ensures that the abline is at a 45 degree angle, which makes it easy to compare the highway and city mileage against what it would be if they were exactly the same. ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + geom_point() + geom_abline() + coord_fixed() If we didn’t include geom_point, then the line is no longer at 45 degrees: ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + geom_point() + geom_abline() "],
["workflow-basics.html", "3 Workflow Basics 3.1 Practice", " 3 Workflow Basics 3.1 Practice 3.1.1 Exercises Why does this code not work? my_variable &lt;- 10 my_varıable #&gt; Error in eval(expr, envir, enclos): object &#39;my_varıable&#39; not found The variable being printed is my_varıable, not my_variable: the seventh character is “ı” (LATIN SMALL LETTER DOTLESS I) not “i”. While it wouldn’t have helped much in this case, the importance of distinguishing characters in code is reasons why fonts which clearly distinguish similar characters are preferred in programming: especially important are distinguishing between zero (0), Latin small letter O (o), and Latin capital letter O (O); and the numeral one (1), Latin small letter I (i), Latin capital letter I (i), and Latin small letter L (l). In these fonts, zero and the Latin letter O are often distinguished by using a glyph for zero that uses either a dot in the interior or a slash through it. Also note that the error messages of the form “object ‘…’ not found”, mean just what they say, the object can’t be found by R. This is usually because you either (1) forgot to define the function (or had an error that prevented it from being defined earlier), (2) didn’t load a package with the object, or (3) made a typo in the object’s name (either when using it or when you originally defined it). Tweak each of the following R commands so that they run correctly: library(tidyverse) #&gt; Loading tidyverse: ggplot2 #&gt; Loading tidyverse: tibble #&gt; Loading tidyverse: tidyr #&gt; Loading tidyverse: readr #&gt; Loading tidyverse: purrr #&gt; Loading tidyverse: dplyr #&gt; Conflicts with tidy packages ---------------------------------------------- #&gt; filter(): dplyr, stats #&gt; lag(): dplyr, stats ggplot(dota = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) #&gt; Error in structure(list(data = data, layers = list(), scales = scales_list(), : argument &quot;data&quot; is missing, with no default The error message is argument &quot;data&quot; is missing, with no default. It looks like a typo, dota instead of data. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) fliter(mpg, cyl = 8) #&gt; Error in eval(expr, envir, enclos): could not find function &quot;fliter&quot; R could not find the function fliter because we made a typo: fliter instead of filter. filter(mpg, cyl = 8) #&gt; Error: filter() takes unnamed arguments. Do you need `==`? We aren’t done yet. But the error message gives a suggestion. Let’s follow it. filter(mpg, cyl == 8) #&gt; # A tibble: 70 × 11 #&gt; manufacturer model displ year cyl trans drv cty #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 audi a6 quattro 4.2 2008 8 auto(s6) 4 16 #&gt; 2 chevrolet c1500 suburban 2wd 5.3 2008 8 auto(l4) r 14 #&gt; 3 chevrolet c1500 suburban 2wd 5.3 2008 8 auto(l4) r 11 #&gt; 4 chevrolet c1500 suburban 2wd 5.3 2008 8 auto(l4) r 14 #&gt; 5 chevrolet c1500 suburban 2wd 5.7 1999 8 auto(l4) r 13 #&gt; 6 chevrolet c1500 suburban 2wd 6.0 2008 8 auto(l4) r 12 #&gt; # ... with 64 more rows, and 3 more variables: hwy &lt;int&gt;, fl &lt;chr&gt;, #&gt; # class &lt;chr&gt; filter(diamond, carat &gt; 3) #&gt; Error in filter_(.data, .dots = lazyeval::lazy_dots(...)): object &#39;diamond&#39; not found R says it can’t find the object diamond. This is a typo; the data frame is named diamonds. filter(diamonds, carat &gt; 3) #&gt; # A tibble: 32 × 10 #&gt; carat cut color clarity depth table price x y z #&gt; &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 3.01 Premium I I1 62.7 58 8040 9.10 8.97 5.67 #&gt; 2 3.11 Fair J I1 65.9 57 9823 9.15 9.02 5.98 #&gt; 3 3.01 Premium F I1 62.2 56 9925 9.24 9.13 5.73 #&gt; 4 3.05 Premium E I1 60.9 58 10453 9.26 9.25 5.66 #&gt; 5 3.02 Fair I I1 65.2 56 10577 9.11 9.02 5.91 #&gt; 6 3.01 Fair H I1 56.1 62 10761 9.54 9.38 5.31 #&gt; # ... with 26 more rows How did I know? I started typing in diamond and RStudio autocorrected it to diamonds. Since diamonds includes the variable carat and the code works, that appears to have been the problem. Press Alt + Shift + K. What happens? How can you get to the same place using the menus? This gives a menu with keyboard shortcuts. This can be found in the menu under Tools -&gt; Keyboard Shortcuts Help. "],
["data-transformation.html", "4 Data Transformation 4.1 Prerequisites 4.2 Filter 4.3 Exercises 4.4 Arrange 4.5 Mutate 4.6 Grouped summaries with summarise() 4.7 Grouped mutates and filters", " 4 Data Transformation 4.1 Prerequisites library(nycflights13) library(tidyverse) 4.2 Filter glimpse(flights) #&gt; Observations: 336,776 #&gt; Variables: 19 #&gt; $ year &lt;int&gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013,... #&gt; $ month &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,... #&gt; $ day &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,... #&gt; $ dep_time &lt;int&gt; 517, 533, 542, 544, 554, 554, 555, 557, 557, 55... #&gt; $ sched_dep_time &lt;int&gt; 515, 529, 540, 545, 600, 558, 600, 600, 600, 60... #&gt; $ dep_delay &lt;dbl&gt; 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2... #&gt; $ arr_time &lt;int&gt; 830, 850, 923, 1004, 812, 740, 913, 709, 838, 7... #&gt; $ sched_arr_time &lt;int&gt; 819, 830, 850, 1022, 837, 728, 854, 723, 846, 7... #&gt; $ arr_delay &lt;dbl&gt; 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -... #&gt; $ carrier &lt;chr&gt; &quot;UA&quot;, &quot;UA&quot;, &quot;AA&quot;, &quot;B6&quot;, &quot;DL&quot;, &quot;UA&quot;, &quot;B6&quot;, &quot;EV&quot;,... #&gt; $ flight &lt;int&gt; 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79... #&gt; $ tailnum &lt;chr&gt; &quot;N14228&quot;, &quot;N24211&quot;, &quot;N619AA&quot;, &quot;N804JB&quot;, &quot;N668DN... #&gt; $ origin &lt;chr&gt; &quot;EWR&quot;, &quot;LGA&quot;, &quot;JFK&quot;, &quot;JFK&quot;, &quot;LGA&quot;, &quot;EWR&quot;, &quot;EWR&quot;... #&gt; $ dest &lt;chr&gt; &quot;IAH&quot;, &quot;IAH&quot;, &quot;MIA&quot;, &quot;BQN&quot;, &quot;ATL&quot;, &quot;ORD&quot;, &quot;FLL&quot;... #&gt; $ air_time &lt;dbl&gt; 227, 227, 160, 183, 116, 150, 158, 53, 140, 138... #&gt; $ distance &lt;dbl&gt; 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 94... #&gt; $ hour &lt;dbl&gt; 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5,... #&gt; $ minute &lt;dbl&gt; 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, ... #&gt; $ time_hour &lt;dttm&gt; 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013... 4.3 Exercises Find all flights that Had an arrival delay of two or more hours Flew to Houston (IAH or HOU) Were operated by United, American, or Delta Departed in summer (July, August, and September) Arrived more than two hours late, but didn’t leave late Were delayed by at least an hour, but made up over 30 minutes in flight Departed between midnight and 6am (inclusive) Had an arrival delay of two or more hours Since delay is in minutes, we are looking for flights where arr_delay &gt; 120: flights %&gt;% filter(arr_delay &gt; 120) #&gt; # A tibble: 10,034 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 1 1 811 630 101 1047 #&gt; 2 2013 1 1 848 1835 853 1001 #&gt; 3 2013 1 1 957 733 144 1056 #&gt; 4 2013 1 1 1114 900 134 1447 #&gt; 5 2013 1 1 1505 1310 115 1638 #&gt; 6 2013 1 1 1525 1340 105 1831 #&gt; # ... with 1.003e+04 more rows, and 12 more variables: #&gt; # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, #&gt; # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, #&gt; # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Flew to Houston (IAH or HOU): flights %&gt;% filter(dest %in% c(&quot;IAH&quot;, &quot;HOU&quot;)) #&gt; # A tibble: 9,313 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 #&gt; 2 2013 1 1 533 529 4 850 #&gt; 3 2013 1 1 623 627 -4 933 #&gt; 4 2013 1 1 728 732 -4 1041 #&gt; 5 2013 1 1 739 739 0 1104 #&gt; 6 2013 1 1 908 908 0 1228 #&gt; # ... with 9,307 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, #&gt; # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, #&gt; # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, #&gt; # minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Were operated by United, American, or Delta The variable carrier has the airline: but it is in two-digit carrier codes. However, we can look it up in the airlines dataset. airlines #&gt; # A tibble: 16 × 2 #&gt; carrier name #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 9E Endeavor Air Inc. #&gt; 2 AA American Airlines Inc. #&gt; 3 AS Alaska Airlines Inc. #&gt; 4 B6 JetBlue Airways #&gt; 5 DL Delta Air Lines Inc. #&gt; 6 EV ExpressJet Airlines Inc. #&gt; # ... with 10 more rows Since there are only 16 rows, its not even worth filtering. Delta is DL, American is AA, and United is UA: filter(flights, carrier %in% c(&quot;AA&quot;, &quot;DL&quot;, &quot;UA&quot;)) #&gt; # A tibble: 139,504 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 #&gt; 2 2013 1 1 533 529 4 850 #&gt; 3 2013 1 1 542 540 2 923 #&gt; 4 2013 1 1 554 600 -6 812 #&gt; 5 2013 1 1 554 558 -4 740 #&gt; 6 2013 1 1 558 600 -2 753 #&gt; # ... with 1.395e+05 more rows, and 12 more variables: #&gt; # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, #&gt; # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, #&gt; # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Departed in summer (July, August, and September) The variable month has the month, and it is numeric. filter(flights, between(month, 7, 9)) #&gt; # A tibble: 86,326 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 7 1 1 2029 212 236 #&gt; 2 2013 7 1 2 2359 3 344 #&gt; 3 2013 7 1 29 2245 104 151 #&gt; 4 2013 7 1 43 2130 193 322 #&gt; 5 2013 7 1 44 2150 174 300 #&gt; 6 2013 7 1 46 2051 235 304 #&gt; # ... with 8.632e+04 more rows, and 12 more variables: #&gt; # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, #&gt; # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, #&gt; # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Arrived more than two hours late, but didn’t leave late filter(flights, !is.na(dep_delay), dep_delay &lt;= 0, arr_delay &gt; 120) #&gt; # A tibble: 29 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 1 27 1419 1420 -1 1754 #&gt; 2 2013 10 7 1350 1350 0 1736 #&gt; 3 2013 10 7 1357 1359 -2 1858 #&gt; 4 2013 10 16 657 700 -3 1258 #&gt; 5 2013 11 1 658 700 -2 1329 #&gt; 6 2013 3 18 1844 1847 -3 39 #&gt; # ... with 23 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, #&gt; # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, #&gt; # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, #&gt; # minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Were delayed by at least an hour, but made up over 30 minutes in flight filter(flights, !is.na(dep_delay), dep_delay &gt;= 60, arr_delay &lt; 30) #&gt; # A tibble: 206 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 1 3 1850 1745 65 2148 #&gt; 2 2013 1 3 1950 1845 65 2228 #&gt; 3 2013 1 3 2015 1915 60 2135 #&gt; 4 2013 1 6 1019 900 79 1558 #&gt; 5 2013 1 7 1543 1430 73 1758 #&gt; 6 2013 1 11 1020 920 60 1311 #&gt; # ... with 200 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, #&gt; # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, #&gt; # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, #&gt; # minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Departed between midnight and 6am (inclusive). filter(flights, dep_time &gt;= 0, dep_time &lt;= 600) #&gt; # A tibble: 9,344 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 #&gt; 2 2013 1 1 533 529 4 850 #&gt; 3 2013 1 1 542 540 2 923 #&gt; 4 2013 1 1 544 545 -1 1004 #&gt; 5 2013 1 1 554 600 -6 812 #&gt; 6 2013 1 1 554 558 -4 740 #&gt; # ... with 9,338 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, #&gt; # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, #&gt; # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, #&gt; # minute &lt;dbl&gt;, time_hour &lt;dttm&gt; or using between (see next question) filter(flights, between(dep_time, 0, 600)) #&gt; # A tibble: 9,344 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 #&gt; 2 2013 1 1 533 529 4 850 #&gt; 3 2013 1 1 542 540 2 923 #&gt; 4 2013 1 1 544 545 -1 1004 #&gt; 5 2013 1 1 554 600 -6 812 #&gt; 6 2013 1 1 554 558 -4 740 #&gt; # ... with 9,338 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, #&gt; # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, #&gt; # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, #&gt; # minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Another useful dplyr filtering helper is between(). What does it do? Can you use it to simplify the code needed to answer the previous challenges? between(x, left, right) is equivalent to x &gt;= left &amp; x &lt;= right. I already used it in 1.4. How many flights have a missing dep_time? What other variables are missing? What might these rows represent? filter(flights, is.na(dep_time)) #&gt; # A tibble: 8,255 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 1 1 NA 1630 NA NA #&gt; 2 2013 1 1 NA 1935 NA NA #&gt; 3 2013 1 1 NA 1500 NA NA #&gt; 4 2013 1 1 NA 600 NA NA #&gt; 5 2013 1 2 NA 1540 NA NA #&gt; 6 2013 1 2 NA 1620 NA NA #&gt; # ... with 8,249 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, #&gt; # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, #&gt; # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, #&gt; # minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Since arr_time is also missing, these are cancelled flights. Why is NA ^ 0 not missing? Why is NA | TRUE not missing? Why is FALSE &amp; NA not missing? Can you figure out the general rule? (NA * 0 is a tricky counterexample!) NA ^ 0 == 1 since for all numeric values \\(x ^ 0 = 1\\). NA ^ 0 #&gt; [1] 1 NA | TRUE is TRUE because the it doesn’t matter whether the missing value is TRUE or FALSE, x \\lor T = T for all values of x. NA | TRUE #&gt; [1] TRUE Likewise, anything and FALSE is always FALSE. NA &amp; FALSE #&gt; [1] FALSE Because the value of the missing element matters in NA | FALSE and NA &amp; TRUE, these are missing: NA | FALSE #&gt; [1] NA NA &amp; TRUE #&gt; [1] NA wut? Since x * 0 = 0 for all \\(x\\) (except Inf) we might expect NA * 0 = 0, but that’s not the case. NA * 0 #&gt; [1] NA The reason that NA * 0 is not equal to 0 is that x * 0 = NaN is undefined when x = Inf or x = -Inf. Inf * 0 #&gt; [1] NaN -Inf * 0 #&gt; [1] NaN 4.4 Arrange missing values always at the end. 4.4.1 Exercises How could you use arrange() to sort all missing values to the start? (Hint: use is.na()). This sorts by increasing dep_time, but with all missing values put first. arrange(flights, desc(is.na(dep_time)), dep_time) #&gt; # A tibble: 336,776 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 1 1 NA 1630 NA NA #&gt; 2 2013 1 1 NA 1935 NA NA #&gt; 3 2013 1 1 NA 1500 NA NA #&gt; 4 2013 1 1 NA 600 NA NA #&gt; 5 2013 1 2 NA 1540 NA NA #&gt; 6 2013 1 2 NA 1620 NA NA #&gt; # ... with 3.368e+05 more rows, and 12 more variables: #&gt; # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, #&gt; # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, #&gt; # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Sort flights to find the most delayed flights. Find the flights that left earliest. The most delayed flights are found by sorting by dep_delay in descending order. arrange(flights, desc(dep_delay)) #&gt; # A tibble: 336,776 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 1 9 641 900 1301 1242 #&gt; 2 2013 6 15 1432 1935 1137 1607 #&gt; 3 2013 1 10 1121 1635 1126 1239 #&gt; 4 2013 9 20 1139 1845 1014 1457 #&gt; 5 2013 7 22 845 1600 1005 1044 #&gt; 6 2013 4 10 1100 1900 960 1342 #&gt; # ... with 3.368e+05 more rows, and 12 more variables: #&gt; # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, #&gt; # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, #&gt; # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; If we sort dep_delay in ascending order, we get those that left earliest. There was a flight that left 43 minutes early. arrange(flights, dep_delay) #&gt; # A tibble: 336,776 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 12 7 2040 2123 -43 40 #&gt; 2 2013 2 3 2022 2055 -33 2240 #&gt; 3 2013 11 10 1408 1440 -32 1549 #&gt; 4 2013 1 11 1900 1930 -30 2233 #&gt; 5 2013 1 29 1703 1730 -27 1947 #&gt; 6 2013 8 9 729 755 -26 1002 #&gt; # ... with 3.368e+05 more rows, and 12 more variables: #&gt; # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, #&gt; # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, #&gt; # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Sort flights to find the fastest flights. I assume that by by “fastest flights” it means the flights with the minimum air time. So I sort by air_time. The fastest flights. The fastest flights area couple of flights between EWR and BDL with an air time of 20 minutes. arrange(flights, air_time) #&gt; # A tibble: 336,776 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 1 16 1355 1315 40 1442 #&gt; 2 2013 4 13 537 527 10 622 #&gt; 3 2013 12 6 922 851 31 1021 #&gt; 4 2013 2 3 2153 2129 24 2247 #&gt; 5 2013 2 5 1303 1315 -12 1342 #&gt; 6 2013 2 12 2123 2130 -7 2211 #&gt; # ... with 3.368e+05 more rows, and 12 more variables: #&gt; # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, #&gt; # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, #&gt; # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Which flights travelled the longest? Which travelled the shortest? I’ll assume hat travelled the longest or shortest refers to distance, rather than air-time. The longest flights are the Hawaii Air (HA 51) between JFK and HNL (Honolulu) at 4,983 miles. arrange(flights, desc(distance)) #&gt; # A tibble: 336,776 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 1 1 857 900 -3 1516 #&gt; 2 2013 1 2 909 900 9 1525 #&gt; 3 2013 1 3 914 900 14 1504 #&gt; 4 2013 1 4 900 900 0 1516 #&gt; 5 2013 1 5 858 900 -2 1519 #&gt; 6 2013 1 6 1019 900 79 1558 #&gt; # ... with 3.368e+05 more rows, and 12 more variables: #&gt; # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, #&gt; # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, #&gt; # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Apart from an EWR to LGA flight that was cancelled, the shortest flights are the Envoy Air Flights between EWR and PHL at 80 miles. arrange(flights, distance) #&gt; # A tibble: 336,776 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 7 27 NA 106 NA NA #&gt; 2 2013 1 3 2127 2129 -2 2222 #&gt; 3 2013 1 4 1240 1200 40 1333 #&gt; 4 2013 1 4 1829 1615 134 1937 #&gt; 5 2013 1 4 2128 2129 -1 2218 #&gt; 6 2013 1 5 1155 1200 -5 1241 #&gt; # ... with 3.368e+05 more rows, and 12 more variables: #&gt; # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, #&gt; # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, #&gt; # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Brainstorm as many ways as possible to select dep_time, dep_delay, arr_time, and arr_delay from flights. A few ways include: select(flights, dep_time, dep_delay, arr_time, arr_delay) #&gt; # A tibble: 336,776 × 4 #&gt; dep_time dep_delay arr_time arr_delay #&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 517 2 830 11 #&gt; 2 533 4 850 20 #&gt; 3 542 2 923 33 #&gt; 4 544 -1 1004 -18 #&gt; 5 554 -6 812 -25 #&gt; 6 554 -4 740 12 #&gt; # ... with 3.368e+05 more rows select(flights, starts_with(&quot;dep_&quot;), starts_with(&quot;arr_&quot;)) #&gt; # A tibble: 336,776 × 4 #&gt; dep_time dep_delay arr_time arr_delay #&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 517 2 830 11 #&gt; 2 533 4 850 20 #&gt; 3 542 2 923 33 #&gt; 4 544 -1 1004 -18 #&gt; 5 554 -6 812 -25 #&gt; 6 554 -4 740 12 #&gt; # ... with 3.368e+05 more rows select(flights, matches(&quot;^(dep|arr)_(time|delay)$&quot;)) #&gt; # A tibble: 336,776 × 4 #&gt; dep_time dep_delay arr_time arr_delay #&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 517 2 830 11 #&gt; 2 533 4 850 20 #&gt; 3 542 2 923 33 #&gt; 4 544 -1 1004 -18 #&gt; 5 554 -6 812 -25 #&gt; 6 554 -4 740 12 #&gt; # ... with 3.368e+05 more rows using ends_with() doesn’t work well since it would bget sched_arr_time and sched_dep_time. What happens if you include the name of a variable multiple times in a select() call? It ignores the duplicates, and that variable is only included once. No error, warning, or message is emited. select(flights, year, month, day, year, year) #&gt; # A tibble: 336,776 × 3 #&gt; year month day #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 #&gt; 2 2013 1 1 #&gt; 3 2013 1 1 #&gt; 4 2013 1 1 #&gt; 5 2013 1 1 #&gt; 6 2013 1 1 #&gt; # ... with 3.368e+05 more rows What does the one_of() function do? Why might it be helpful in conjunction with this vector? The one_of vector allows you to select variables with a character vector rather than as unquoted variable names. It’s useful because then you can easily pass vectors to select(). vars &lt;- c(&quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;dep_delay&quot;, &quot;arr_delay&quot;) select(flights, one_of(vars)) #&gt; # A tibble: 336,776 × 5 #&gt; year month day dep_delay arr_delay #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 2 11 #&gt; 2 2013 1 1 4 20 #&gt; 3 2013 1 1 2 33 #&gt; 4 2013 1 1 -1 -18 #&gt; 5 2013 1 1 -6 -25 #&gt; 6 2013 1 1 -4 12 #&gt; # ... with 3.368e+05 more rows Does the result of running the following code surprise you? How do the select helpers deal with case by default? How can you change that default? select(flights, contains(&quot;TIME&quot;)) #&gt; # A tibble: 336,776 × 6 #&gt; dep_time sched_dep_time arr_time sched_arr_time air_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 517 515 830 819 227 #&gt; 2 533 529 850 830 227 #&gt; 3 542 540 923 850 160 #&gt; 4 544 545 1004 1022 183 #&gt; 5 554 600 812 837 116 #&gt; 6 554 558 740 728 150 #&gt; # ... with 3.368e+05 more rows, and 1 more variables: time_hour &lt;dttm&gt; The default behavior for contains is to ignore case. Yes, it surprises me. Upon reflection, I realized that this is likely the default behavior because dplyr is designed to deal with a variety of data backends, and some database engines don’t differentiate case. To change the behavior add the argument ignore.case = FALSE. Now no variables are selected. select(flights, contains(&quot;TIME&quot;, ignore.case = FALSE)) #&gt; # A tibble: 336,776 × 0 4.5 Mutate 4.5.1 Exercises Currently dep_time and sched_dep_time are convenient to look at, but hard to compute with because they’re not really continuous numbers. Convert them to a more convenient representation of number of minutes since midnight. To get the departure times in the number of minutes, (integer) divide dep_time by 100 to get the hours since midnight and muliply by 60 and add the remainder of dep_time divided by 100. mutate(flights, dep_time_mins = dep_time %/% 100 * 60 + dep_time %% 100, sched_dep_time_mins = sched_dep_time %/% 100 * 60 + sched_dep_time %% 100) %&gt;% select(dep_time, dep_time_mins, sched_dep_time, sched_dep_time_mins) #&gt; # A tibble: 336,776 × 4 #&gt; dep_time dep_time_mins sched_dep_time sched_dep_time_mins #&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 517 317 515 315 #&gt; 2 533 333 529 329 #&gt; 3 542 342 540 340 #&gt; 4 544 344 545 345 #&gt; 5 554 354 600 360 #&gt; 6 554 354 558 358 #&gt; # ... with 3.368e+05 more rows This would be more cleanly done by first definining a funciton and reusing that: time2mins &lt;- function(x) { x %/% 100 * 60 + x %% 100 } mutate(flights, dep_time_mins = time2mins(dep_time), sched_dep_time_mins = time2mins(sched_dep_time)) %&gt;% select(dep_time, dep_time_mins, sched_dep_time, sched_dep_time_mins) #&gt; # A tibble: 336,776 × 4 #&gt; dep_time dep_time_mins sched_dep_time sched_dep_time_mins #&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 517 317 515 315 #&gt; 2 533 333 529 329 #&gt; 3 542 342 540 340 #&gt; 4 544 344 545 345 #&gt; 5 554 354 600 360 #&gt; 6 554 354 558 358 #&gt; # ... with 3.368e+05 more rows Compare air_time with arr_time - dep_time. What do you expect to see? What do you see? What do you need to do to fix it? Since arr_time and dep_time may be in different time zones, the air_time doesn’t equal the difference. We would need to account for time-zones in these calculations. mutate(flights, air_time2 = arr_time - dep_time, air_time_diff = air_time2 - air_time) %&gt;% filter(air_time_diff != 0) %&gt;% select(air_time, air_time2, dep_time, arr_time, dest) #&gt; # A tibble: 326,128 × 5 #&gt; air_time air_time2 dep_time arr_time dest #&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; #&gt; 1 227 313 517 830 IAH #&gt; 2 227 317 533 850 IAH #&gt; 3 160 381 542 923 MIA #&gt; 4 183 460 544 1004 BQN #&gt; 5 116 258 554 812 ATL #&gt; 6 150 186 554 740 ORD #&gt; # ... with 3.261e+05 more rows Compare dep_time, sched_dep_time, and dep_delay. How would you expect those three numbers to be related? I’d expect dep_time, sched_dep_time, and dep_delay to be related so that dep_time - sched_dep_time = dep_delay. mutate(flights, dep_delay2 = dep_time - sched_dep_time) %&gt;% filter(dep_delay2 != dep_delay) %&gt;% select(dep_time, sched_dep_time, dep_delay, dep_delay2) #&gt; # A tibble: 99,777 × 4 #&gt; dep_time sched_dep_time dep_delay dep_delay2 #&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 554 600 -6 -46 #&gt; 2 555 600 -5 -45 #&gt; 3 557 600 -3 -43 #&gt; 4 557 600 -3 -43 #&gt; 5 558 600 -2 -42 #&gt; 6 558 600 -2 -42 #&gt; # ... with 9.977e+04 more rows Oops, I forgot to convert to minutes. I’ll reuse the time2mins function I wrote earlier. mutate(flights, dep_delay2 = time2mins(dep_time) - time2mins(sched_dep_time)) %&gt;% filter(dep_delay2 != dep_delay) %&gt;% select(dep_time, sched_dep_time, dep_delay, dep_delay2) #&gt; # A tibble: 1,207 × 4 #&gt; dep_time sched_dep_time dep_delay dep_delay2 #&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 848 1835 853 -587 #&gt; 2 42 2359 43 -1397 #&gt; 3 126 2250 156 -1284 #&gt; 4 32 2359 33 -1407 #&gt; 5 50 2145 185 -1255 #&gt; 6 235 2359 156 -1284 #&gt; # ... with 1,201 more rows Well, that solved most of the problems, but these two numbers don’t match because we aren’t accounting for flights where the departure time is the next day from the scheduled departure time. Find the 10 most delayed flights using a ranking function. How do you want to handle ties? Carefully read the documentation for min_rank(). I’d want to handle ties by taking the minimum of tied values. If three flights are have the same value and are the most delayed, we would say they are tied for first, not tied for third or second. mutate(flights, dep_delay_rank = min_rank(-dep_delay)) %&gt;% arrange(dep_delay_rank) %&gt;% filter(dep_delay_rank &lt;= 10) #&gt; # A tibble: 10 × 20 #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 1 9 641 900 1301 1242 #&gt; 2 2013 6 15 1432 1935 1137 1607 #&gt; 3 2013 1 10 1121 1635 1126 1239 #&gt; 4 2013 9 20 1139 1845 1014 1457 #&gt; 5 2013 7 22 845 1600 1005 1044 #&gt; 6 2013 4 10 1100 1900 960 1342 #&gt; # ... with 4 more rows, and 13 more variables: sched_arr_time &lt;int&gt;, #&gt; # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, #&gt; # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, #&gt; # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, dep_delay_rank &lt;int&gt; What does 1:3 + 1:10 return? Why? It returns c(1 + 1, 2 + 2, 3 + 3, 1 + 4, 2 + 5, 3 + 6, 1 + 7, 2 + 8, 3 + 9, 1 + 10). When adding two vectors recycles the shorter vector’s values to get vectors of the same length. We get a warning vector since the shorter vector is not a multiple of the longer one (this often, but not necessarily, means we made an error somewhere). 1:3 + 1:10 #&gt; Warning in 1:3 + 1:10: longer object length is not a multiple of shorter #&gt; object length #&gt; [1] 2 4 6 5 7 9 8 10 12 11 What trigonometric functions does R provide? All the classics: cos, sin, tan, acos, asin, atan, plus a few others that are drive by numerical or computational issues. 4.6 Grouped summaries with summarise() 4.6.1 Exercises Brainstorm at least 5 different ways to assess the typical delay characteristics of a group of flights. Consider the following scenarios: A flight is 15 minutes early 50% of the time, and 15 minutes late 50% of the time. A flight is always 10 minutes late. A flight is 30 minutes early 50% of the time, and 30 minutes late 50% of the time. 99% of the time a flight is on time. 1% of the time it’s 2 hours late. Which is more important: arrival delay or departure delay? Arrival delay is more important. Arriving early is nice, but equally as good as arriving late is bad. Variation is worse than consistency; if I know the plane will always arrive 10 minutes late, then I can plan for it arriving as if the actual arrival time was 10 minutes later than the scheduled arrival time. So I’d try something that calculates the expected time of the flight, and then aggregates over any delays from that time. I would ignore any early arrival times. A better ranking would also consider cancellations, and need a way to convert them to a delay time (perhaps using the arrival time of the next flight to the same destination). Come up with another approach that will give you the same output as not_cancelled %&gt;% count(dest) and not_cancelled %&gt;% count(tailnum, wt = distance) (without using count()). Our definition of cancelled flights (is.na(dep_delay) | is.na(arr_delay)) is slightly suboptimal. Why? Which is the most important column? If a flight doesn’t depart, then it won’t arrive. A flight can also depart and not arrive if it crashes; I’m not sure how this data would handle flights that are redirected and land at other airports for whatever reason. The more important column is arr_delay so we could just use that. filter(flights, !is.na(dep_delay), is.na(arr_delay)) %&gt;% select(dep_time, arr_time, sched_arr_time, dep_delay, arr_delay) #&gt; # A tibble: 1,175 × 5 #&gt; dep_time arr_time sched_arr_time dep_delay arr_delay #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1525 1934 1805 -5 NA #&gt; 2 1528 2002 1647 29 NA #&gt; 3 1740 2158 2020 -5 NA #&gt; 4 1807 2251 2103 29 NA #&gt; 5 1939 29 2151 59 NA #&gt; 6 1952 2358 2207 22 NA #&gt; # ... with 1,169 more rows Okay, I’m not sure what’s going on in this data. dep_time can be non-missing and arr_delay missing but arr_time not missing. They may be combining different flights? Look at the number of cancelled flights per day. Is there a pattern? Is the proportion of cancelled flights related to the average delay? cancelled_delayed &lt;- flights %&gt;% mutate(cancelled = (is.na(arr_delay) | is.na(dep_delay))) %&gt;% group_by(year, month, day) %&gt;% summarise(prop_cancelled = mean(cancelled), avg_dep_delay = mean(dep_delay, na.rm = TRUE)) ggplot(cancelled_delayed, aes(x = avg_dep_delay, prop_cancelled)) + geom_point() + geom_smooth() #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Which carrier has the worst delays? Challenge: can you disentangle the effects of bad airports vs. bad carriers? Why/why not? (Hint: think about flights %&gt;% group_by(carrier, dest) %&gt;% summarise(n())) flights %&gt;% group_by(carrier) %&gt;% summarise(arr_delay = mean(arr_delay, na.rm = TRUE)) %&gt;% arrange(desc(arr_delay)) #&gt; # A tibble: 16 × 2 #&gt; carrier arr_delay #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 F9 21.9 #&gt; 2 FL 20.1 #&gt; 3 EV 15.8 #&gt; 4 YV 15.6 #&gt; 5 OO 11.9 #&gt; 6 MQ 10.8 #&gt; # ... with 10 more rows filter(airlines, carrier == &quot;F9&quot;) #&gt; # A tibble: 1 × 2 #&gt; carrier name #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 F9 Frontier Airlines Inc. Frontier Airlines (FL) has the worst delays. You can get part of the way to disentangling the effects of airports vs. carriers by comparing each flight’s delay to the average delay of destination airport. However, you’d really want to compare it to the average delay of the desination airport, after removing other flights from the same airline. 538 has done something like this: http://fivethirtyeight.com/features/the-best-and-worst-airlines-airports-and-flights-summer-2015-update/. For each plane, count the number of flights before the first delay of greater than 1 hour. I think this requires grouped mutate (but I may be wrong): flights %&gt;% arrange(tailnum, year, month, day) %&gt;% group_by(tailnum) %&gt;% mutate(delay_gt1hr = dep_delay &gt; 60) %&gt;% mutate(before_delay = cumsum(delay_gt1hr)) %&gt;% filter(before_delay &lt; 1) %&gt;% count(sort = TRUE) #&gt; # A tibble: 3,755 × 2 #&gt; tailnum n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 N954UW 206 #&gt; 2 N952UW 163 #&gt; 3 N957UW 142 #&gt; 4 N5FAAA 117 #&gt; 5 N38727 99 #&gt; 6 N3742C 98 #&gt; # ... with 3,749 more rows What does the sort argument to count() do. When might you use it? The sort argument to count sorts the results in order of n. You could use this anytime you would do count followed by arrange. 4.7 Grouped mutates and filters 4.7.1 Exercises Refer back to the table of useful mutate and filtering functions. Describe how each operation changes when you combine it with grouping. They operate within each group rather than over the entire data frame. E.g. mean will calculate the mean within each group. Which plane (tailnum) has the worst on-time record? flights %&gt;% group_by(tailnum) %&gt;% summarise(arr_delay = mean(arr_delay, na.rm = TRUE)) %&gt;% ungroup() %&gt;% filter(rank(desc(arr_delay)) &lt;= 1) #&gt; # A tibble: 1 × 2 #&gt; tailnum arr_delay #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 N844MH 320 What time of day should you fly if you want to avoid delays as much as possible? Let’s group by hour. The earlier the better to fly. This is intuitive as delays early in the morning are likely to propogate throughout the day. flights %&gt;% group_by(hour) %&gt;% summarise(arr_delay = mean(arr_delay, na.rm = TRUE)) %&gt;% ungroup() %&gt;% arrange(arr_delay) #&gt; # A tibble: 20 × 2 #&gt; hour arr_delay #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 7 -5.304 #&gt; 2 5 -4.797 #&gt; 3 6 -3.384 #&gt; 4 9 -1.451 #&gt; 5 8 -1.113 #&gt; 6 10 0.954 #&gt; # ... with 14 more rows For each destination, compute the total minutes of delay. For each, flight, compute the proportion of the total delay for its destination. flights %&gt;% filter(!is.na(arr_delay), arr_delay &gt; 0) %&gt;% group_by(dest) %&gt;% mutate(total_delay = sum(arr_delay), prop_delay = arr_delay / sum(arr_delay)) #&gt; Source: local data frame [133,004 x 21] #&gt; Groups: dest [103] #&gt; #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 #&gt; 2 2013 1 1 533 529 4 850 #&gt; 3 2013 1 1 542 540 2 923 #&gt; 4 2013 1 1 554 558 -4 740 #&gt; 5 2013 1 1 555 600 -5 913 #&gt; 6 2013 1 1 558 600 -2 753 #&gt; # ... with 1.33e+05 more rows, and 14 more variables: #&gt; # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, #&gt; # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, #&gt; # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, #&gt; # total_delay &lt;dbl&gt;, prop_delay &lt;dbl&gt; Alternatively, consider the delay as relative to the minimum delay for any flight to that destination. Now all non-cancelled flights have a proportion. flights %&gt;% filter(!is.na(arr_delay), arr_delay &gt; 0) %&gt;% group_by(dest) %&gt;% mutate(total_delay = sum(arr_delay - min(arr_delay)), prop_delay = arr_delay / sum(arr_delay)) #&gt; Source: local data frame [133,004 x 21] #&gt; Groups: dest [103] #&gt; #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 #&gt; 2 2013 1 1 533 529 4 850 #&gt; 3 2013 1 1 542 540 2 923 #&gt; 4 2013 1 1 554 558 -4 740 #&gt; 5 2013 1 1 555 600 -5 913 #&gt; 6 2013 1 1 558 600 -2 753 #&gt; # ... with 1.33e+05 more rows, and 14 more variables: #&gt; # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, #&gt; # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, #&gt; # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, #&gt; # total_delay &lt;dbl&gt;, prop_delay &lt;dbl&gt; Delays are typically temporally correlated: even once the problem that caused the initial delay has been resolved, later flights are delayed to allow earlier flights to leave. Using lag() explore how the delay of a flight is related to the delay of the immediately preceding flight. We want to group by day to avoid taking the lag from the previous day. Also, I want to use departure delay, since this mechanism is relevant for departures. Also, I remove missing values both before and after calculating the lag delay. However, it would be interesting to ask the probability or averge delay after a cancellation. flights %&gt;% group_by(year, month, day) %&gt;% filter(!is.na(dep_delay)) %&gt;% mutate(lag_delay = lag(dep_delay)) %&gt;% filter(!is.na(lag_delay)) %&gt;% ggplot(aes(x = dep_delay, y = lag_delay)) + geom_point() + geom_smooth() #&gt; `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; Look at each destination. Can you find flights that are suspiciously fast? (i.e. flights that represent a potential data entry error). Compute the air time a flight relative to the shortest flight to that destination. Which flights were most delayed in the air? The shorter BOS and PHL flights that are 20 minutes for 30+ minutes flights seem plausible - though maybe entries of +/- a few minutes can easily create large changes. I assume that departure time has a standardized definition, but I’m not sure; if there is some discretion, that could create errors that are small in absolute time, but large in relative time for small flights. The ATL, GSP, an BNA flights looks a little suspicious as it’s almost half the time for longer flights. flights %&gt;% filter(!is.na(air_time)) %&gt;% group_by(dest) %&gt;% mutate(med_time = median(air_time), fast = (air_time - med_time) / med_time) %&gt;% arrange(fast) %&gt;% select(air_time, med_time, fast, dep_time, sched_dep_time, arr_time, sched_arr_time) %&gt;% head(15) #&gt; Adding missing grouping variables: `dest` #&gt; Source: local data frame [15 x 8] #&gt; Groups: dest [9] #&gt; #&gt; dest air_time med_time fast dep_time sched_dep_time arr_time #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 BOS 21 38 -0.447 1450 1500 1547 #&gt; 2 ATL 65 112 -0.420 1709 1700 1923 #&gt; 3 GSP 55 92 -0.402 2040 2025 2225 #&gt; 4 BOS 23 38 -0.395 1954 2000 2131 #&gt; 5 BNA 70 113 -0.381 1914 1910 2045 #&gt; 6 MSP 93 149 -0.376 1558 1513 1745 #&gt; # ... with 9 more rows, and 1 more variables: sched_arr_time &lt;int&gt; I could also try a z-score. Though the sd and mean will be affected by large delays. flights %&gt;% filter(!is.na(air_time)) %&gt;% group_by(dest) %&gt;% mutate(air_time_mean = mean(air_time), air_time_sd = sd(air_time), z_score = (air_time - air_time_mean) / air_time_sd) %&gt;% arrange(z_score) %&gt;% select(z_score, air_time_mean, air_time_sd, air_time, dep_time, sched_dep_time, arr_time, sched_arr_time) #&gt; Adding missing grouping variables: `dest` #&gt; Source: local data frame [327,346 x 9] #&gt; Groups: dest [104] #&gt; #&gt; dest z_score air_time_mean air_time_sd air_time dep_time sched_dep_time #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 MSP -4.90 150.6 11.75 93 1558 1513 #&gt; 2 ATL -4.88 112.9 9.81 65 1709 1700 #&gt; 3 GSP -4.72 93.4 8.13 55 2040 2025 #&gt; 4 BNA -4.05 114.4 10.96 70 1914 1910 #&gt; 5 CVG -3.98 96.0 8.52 62 1359 1343 #&gt; 6 BOS -3.63 39.0 4.95 21 1450 1500 #&gt; # ... with 3.273e+05 more rows, and 2 more variables: arr_time &lt;int&gt;, #&gt; # sched_arr_time &lt;int&gt; flights %&gt;% filter(!is.na(air_time)) %&gt;% group_by(dest) %&gt;% mutate(air_time_diff = air_time - min(air_time)) %&gt;% arrange(desc(air_time_diff)) %&gt;% select(dest, year, month, day, carrier, flight, air_time_diff, air_time, dep_time, arr_time) %&gt;% head() #&gt; Source: local data frame [6 x 10] #&gt; Groups: dest [5] #&gt; #&gt; dest year month day carrier flight air_time_diff air_time dep_time #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 SFO 2013 7 28 DL 841 195 490 1727 #&gt; 2 LAX 2013 11 22 DL 426 165 440 1812 #&gt; 3 EGE 2013 1 28 AA 575 163 382 1806 #&gt; 4 DEN 2013 9 10 UA 745 149 331 1513 #&gt; 5 LAX 2013 7 10 DL 17 147 422 1814 #&gt; 6 LAS 2013 11 22 UA 587 143 399 2142 #&gt; # ... with 1 more variables: arr_time &lt;int&gt; Find all destinations that are flown by at least two carriers. Use that information to rank the carriers. The carrier tha flies to the most locations is ExpressJet Airlines (EV). ExpressJet is a regional airline and partner for major airlines, so its one of those that flies small planes to close airports flights %&gt;% group_by(dest, carrier) %&gt;% count(carrier) %&gt;% group_by(carrier) %&gt;% count(sort = TRUE) #&gt; # A tibble: 16 × 2 #&gt; carrier nn #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 EV 61 #&gt; 2 9E 49 #&gt; 3 UA 47 #&gt; 4 B6 42 #&gt; 5 DL 40 #&gt; 6 MQ 20 #&gt; # ... with 10 more rows filter(airlines, carrier == &quot;EV&quot;) #&gt; # A tibble: 1 × 2 #&gt; carrier name #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 EV ExpressJet Airlines Inc. "],
["exploratory-data-analysis.html", "5 Exploratory Data Analysis 5.1 Introduction 5.2 Missing Values 5.3 Covariation", " 5 Exploratory Data Analysis 5.1 Introduction library(&quot;tidyverse&quot;) library(&quot;viridis&quot;) library(&quot;forcats&quot;) This will also use data from nycflights13, library(&quot;nycflights13&quot;) 5.1.1 Questions 5.1.2 Variation 5.1.2.1 Exercises 1. Explore the distribution of each of the x, y, and z variables in diamonds. What do you learn? Think about a diamond and how you might decide which dimension is the length, width, and depth. In order to make it eaiser to plot them, I’ll reshape the dataset so that I can use the variables as facets. diamonds %&gt;% mutate(id = row_number()) %&gt;% select(x, y, z, id) %&gt;% gather(variable, value, -id) %&gt;% ggplot(aes(x = value)) + geom_density() + geom_rug() + facet_grid(variable ~ .) There several noticeable features of thedistributions They are right skewed, with most diamonds small, but a few very large ones. There is an outlier in y, and z (see the rug) All three distributions have a bimodality (perhaps due to some sort of threshhold) According to the documentation for diamonds: x is length, y is width, and z is depth. I don’t know if I would have figured that out before; maybe if there was data on the type of cuts. 2. Explore the distribution of price. Do you discover anything unusual or surprising? (Hint: Carefully think about the binwidth and make sure you try a wide range of values.) The price data is spikey, but I can’t tell what that corresponds to, as the following plots don’t show much difference in the distributions in the last one and last two digits. There are no diamonds with a price of 1500 There’s a bulge in the distribution around 7500. ggplot(filter(diamonds, price &lt; 2500), aes(x = price)) + geom_histogram(binwidth = 10, center = 0) ggplot(filter(diamonds), aes(x = price)) + geom_histogram(binwidth = 100, center = 0) Distribution of last digit diamonds %&gt;% mutate(ending = price %% 10) %&gt;% ggplot(aes(x = ending)) + geom_histogram(binwidth = 1, center = 0) + geom_bar() diamonds %&gt;% mutate(ending = price %% 100) %&gt;% ggplot(aes(x = ending)) + geom_histogram(binwidth = 1) + geom_bar() diamonds %&gt;% mutate(ending = price %% 1000) %&gt;% filter(ending &gt;= 500, ending &lt;= 800) %&gt;% ggplot(aes(x = ending)) + geom_histogram(binwidth = 1) + geom_bar() 3. How many diamonds are 0.99 carat? How many are 1 carat? What do you think is the cause of the difference? There are more than 70 times as many 1 carat diamonds as 0.99 carat diamond. diamonds %&gt;% filter(carat &gt;= 0.99, carat &lt;= 1) %&gt;% count(carat) #&gt; # A tibble: 2 × 2 #&gt; carat n #&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 0.99 23 #&gt; 2 1.00 1558 I don’t know exactly the process behind how carats are measured, but some way or another some diamonds carat values are being “rounded up”, because presumably there is a premium for a 1 carat diamond vs. a 0.99 carat diamond beyond the expected increase in price due to a 0.01 carat increase. To check this intuition, we’d want to look at the number of diamonds in each carat range to seem if there is an abnormally low number at 0.99 carats, and an abnormally high number at 1 carat. diamonds %&gt;% filter(carat &gt;= 0.9, carat &lt;= 1.1) %&gt;% count(carat) %&gt;% print(n = 30) #&gt; # A tibble: 21 × 2 #&gt; carat n #&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 0.90 1485 #&gt; 2 0.91 570 #&gt; 3 0.92 226 #&gt; 4 0.93 142 #&gt; 5 0.94 59 #&gt; 6 0.95 65 #&gt; 7 0.96 103 #&gt; 8 0.97 59 #&gt; 9 0.98 31 #&gt; 10 0.99 23 #&gt; 11 1.00 1558 #&gt; 12 1.01 2242 #&gt; 13 1.02 883 #&gt; 14 1.03 523 #&gt; 15 1.04 475 #&gt; 16 1.05 361 #&gt; 17 1.06 373 #&gt; 18 1.07 342 #&gt; 19 1.08 246 #&gt; 20 1.09 287 #&gt; 21 1.10 278 Q Can you think of other examples of similar phenoma where you might expect to see similar discontinuities in areas related to your research. Compare and contrast coord_cartesian() vs xlim() or ylim() when zooming in on a histogram. What happens if you leave binwidth unset? What happens if you try and zoom so only half a bar shows? coord_cartesian simply zooms in on the area specified by the limits. The calculation of the histogram is unaffected. ggplot(diamonds) + geom_histogram(mapping = aes(x = price)) + coord_cartesian(xlim = c(100, 5000), ylim = c(0, 3000)) #&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. However, the xlim and ylim functions first drop any values outside the limits (the ylim doesn’t matter in this case), then calculates the histogram, and draws the graph with the given limits. ggplot(diamonds) + geom_histogram(mapping = aes(x = price)) + xlim(100, 5000) + ylim(0, 3000) #&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. #&gt; Warning: Removed 14714 rows containing non-finite values (stat_bin). #&gt; Warning: Removed 5 rows containing missing values (geom_bar). 5.2 Missing Values 5.2.1 Exercises What happens to missing values in a histogram? What happens to missing values in a bar chart? Why is there a difference? Missing values are removed when the number of observations in each bin are calculated. See the warning message: Removed 9 rows containing non-finite values (stat_bin) diamonds2 &lt;- diamonds %&gt;% mutate(y = ifelse(y &lt; 3 | y &gt; 20, NA, y)) ggplot(diamonds2, aes(x = y)) + geom_histogram() #&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. #&gt; Warning: Removed 9 rows containing non-finite values (stat_bin). In geom_bar, NA is treated as another category. This is because the x aesthetic in geom_bar should be a discrete (categorical) variable, and missing values are just another category. diamonds %&gt;% mutate(cut = if_else(runif(n()) &lt; 0.1, NA_character_, as.character(cut))) %&gt;% ggplot() + geom_bar(mapping = aes(x = cut)) In a histogram, the x aesthetic variable needs to be numeric, and stat_bin groups the observations by ranges into bins. Since the numeric value of the NA observations is unknown, they cannot be placed in a particular bin, and are dropped. What does na.rm = TRUE do in mean() and sum()? This option removes NA values from the vector prior to calculating the mean and sum. mean(c(0, 1, 2, NA), na.rm = TRUE) #&gt; [1] 1 sum(c(0, 1, 2, NA), na.rm = TRUE) #&gt; [1] 3 5.3 Covariation 5.3.1 A categorical and continuous variable For a history of the boxplot see Wikckham [40 years of the boxplot] (http://vita.had.co.nz/papers/boxplots.pdf) Krywinski, Martin, and Naomi Altman. 2014. “Points of Significance: Visualizing samples with box plots.” Nature Methods URL Where does the 1.5 x IQR come from? It’s kind of arbitrary. But in a normal distribution, the IQR is approximatley 2, and 1.5 x IQR is approx 4, so the outliers are approximately within 4 standard deviations of the median (mean). 5.3.1.1 Excercises Use what you’ve learned to improve the visualisation of the departure times of cancelled vs. non-cancelled flights. Instead of a freqplot use a box-plot nycflights13::flights %&gt;% mutate( cancelled = is.na(dep_time), sched_hour = sched_dep_time %/% 100, sched_min = sched_dep_time %% 100, sched_dep_time = sched_hour + sched_min / 60 ) %&gt;% ggplot() + geom_boxplot(mapping = aes(y = sched_dep_time, x = cancelled)) What variable in the diamonds dataset is most important for predicting the price of a diamond? How is that variable correlated with cut? Why does the combination of those two relationships lead to lower quality diamonds being more expensive? I’m not exactly sure what this question is asking conditional on using only the tools introduced in the book thus far. Install the ggstance package, and create a horizontal boxplot. How does this compare to using coord_flip()? Earlier we created a horizontal boxplot of the distribution hwy by class, using geom_boxplot and coord_flip: ggplot(data = mpg) + geom_boxplot(mapping = aes(x = reorder(class, hwy, FUN = median), y = hwy)) + coord_flip() In this case the output looks the same, but in the aesthetics the x and y are flipped from the previous case. library(&quot;ggstance&quot;) ggplot(data = mpg) + geom_boxploth(mapping = aes(y = reorder(class, hwy, FUN = median), x = hwy)) One problem with boxplots is that they were developed in an era of much smaller datasets and tend to display a prohibitively large number of “outlying values”. One approach to remedy this problem is the letter value plot. Install the lvplot package, and try using geom_lv() to display the distribution of price vs cut. What do you learn? How do you interpret the plots? The boxes of the letter-value plot correspond to many more quantiles. They are useful for larger datasets because larger datasets can give precise estiamtes of quantiles beyond the quartiles in expectation, larger datasets should have many more outliers The letter-value plot is described in: Heike Hofmann, Karen Kafadar, and Hadley Wickham. 2011. “Letter-value plots: Boxplots for large data” http://vita.had.co.nz/papers/letter-value-plot.pdf library(&quot;lvplot&quot;) ggplot(diamonds, aes(x = cut, y = price)) + geom_lv() Compare and contrast geom_violin() with a facetted geom_histogram(), or a coloured geom_freqpoly(). What are the pros and cons of each method? I produce plots for these three methods below. The geom_freqpoly is better for look-up: meaning that given a price, it is easy to tell which cut has the highest density. However, the overlapping lines makes it difficult to distinguish how the overall distributions relate to each other. The geom_violin and facetted geom_histogram have similar strengths and weaknesses. It is easy to visually distinguish differences in the overall shape of the distributions (skewness, central values, variance, etc). However, since we can’t easily compare the vertical values of the distribution, its difficult to look up which category has the highest density for a given price. All of these methods depend on tuning parameters to determine the level of smoothness of the distribution. ggplot(data = diamonds, mapping = aes(x = price, y = ..density..)) + geom_freqpoly(mapping = aes(colour = cut), binwidth = 500) ggplot(data = diamonds, mapping = aes(x = price)) + geom_histogram() + facet_wrap(~ cut, ncol = 1, scales = &quot;free_y&quot;) #&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ggplot(data = diamonds, mapping = aes(x = cut, y = price)) + geom_violin() + coord_flip() The violin plot was first described in Hintze JL, Nelson RD (1998). “Violin Plots: A Box Plot-Density Trace Synergism.” The American Statistician, 52(2), 181–184 If you have a small dataset, it’s sometimes useful to use geom_jitter() to see the relationship between a continuous and categorical variable. The ggbeeswarm package provides a number of methods similar to geom_jitter(). List them and briefly describe what each one does. There are two methods: geom_quasirandom that produces plots that resemble something between jitter and violin. There are several different methods that determine exactly how the random location of the points is generated. geom_beeswarm creates a shape similar to a violin plot, but by offsetting the points. I’ll use the mpg boxplot example since these methods display individual points, they are better suited for smaller datasets. library(&quot;ggbeeswarm&quot;) ggplot(data = mpg) + geom_quasirandom(mapping = aes(x = reorder(class, hwy, FUN = median), y = hwy)) ggplot(data = mpg) + geom_quasirandom(mapping = aes(x = reorder(class, hwy, FUN = median), y = hwy), method = &quot;tukey&quot;) ggplot(data = mpg) + geom_quasirandom(mapping = aes(x = reorder(class, hwy, FUN = median), y = hwy), method = &quot;tukeyDense&quot;) ggplot(data = mpg) + geom_quasirandom(mapping = aes(x = reorder(class, hwy, FUN = median), y = hwy), method = &quot;frowney&quot;) ggplot(data = mpg) + geom_quasirandom(mapping = aes(x = reorder(class, hwy, FUN = median), y = hwy), method = &quot;smiley&quot;) ggplot(data = mpg) + geom_beeswarm(mapping = aes(x = reorder(class, hwy, FUN = median), y = hwy)) 5.3.2 Two categorical variables How could you rescale the count dataset above to more clearly show the distribution of cut within colour, or colour within cut? TO clearly show the distribution of cut within color, calculate a new variable prop which is the proportion of each cut within a color. This is done using a grouped mutate. diamonds %&gt;% count(color, cut) %&gt;% group_by(color) %&gt;% mutate(prop = n / sum(n)) %&gt;% ggplot(mapping = aes(x = color, y = cut)) + geom_tile(mapping = aes(fill = prop)) + scale_fill_viridis(limits = c(0, 1)) Similarly, to scale by the distribution of color within cut, diamonds %&gt;% count(color, cut) %&gt;% group_by(cut) %&gt;% mutate(prop = n / sum(n)) %&gt;% ggplot(mapping = aes(x = color, y = cut)) + geom_tile(mapping = aes(fill = prop)) + scale_fill_viridis(limits = c(0, 1)) I add limit = c(0, 1) to put the color scale between (0, 1). These are the logical boundaries of proportions. This makes it possible to compare each cell to its actual value, and would improve comparisons across multiple plots. However, it ends up limiting the colors and makes it harder to compare within the dataset. However, using the default limits of the minimum and maximum values makes it easier to compare within the dataset the emphasizing relative differences, but harder to compare across datasets. Use geom_tile() together with dplyr to explore how average flight delays vary by destination and month of year. What makes the plot difficult to read? How could you improve it? flights %&gt;% group_by(month, dest) %&gt;% summarise(dep_delay = mean(dep_delay, na.rm = TRUE)) %&gt;% ggplot(aes(x = factor(month), y = dest, fill = dep_delay)) + geom_tile() + labs(x = &quot;Month&quot;, y = &quot;Destination&quot;, fill = &quot;Departure Delay&quot;) There are several things that could be done to improve it, sort destinations by a meaningful quanity (distance, number of flights, average delay) remove missing values better color scheme (viridis) How to treat missing values is difficult. In this case, missing values correspond to airports which don’t have regular flights (at least one flight each month) from NYC. These are likely smaller airports (with higher variance in their average due to fewer observations). library(&quot;viridis&quot;) flights %&gt;% group_by(month, dest) %&gt;% summarise(dep_delay = mean(dep_delay, na.rm = TRUE)) %&gt;% group_by(dest) %&gt;% filter(n() == 12) %&gt;% ungroup() %&gt;% mutate(dest = fct_reorder(dest, dep_delay)) %&gt;% ggplot(aes(x = factor(month), y = dest, fill = dep_delay)) + geom_tile() + scale_fill_viridis() + labs(x = &quot;Month&quot;, y = &quot;Destination&quot;, fill = &quot;Departure Delay&quot;) Why is it slightly better to use aes(x = color, y = cut) rather than aes(x = cut, y = color) in the example above? It’s usually better to use the categorical variable with a larger number of categories or the longer labels on the y axis. If at all possible, labels should be horizontal because that is easier to read. However, switching the order doesn’t result in overlapping labels. diamonds %&gt;% count(color, cut) %&gt;% ggplot(mapping = aes(y = color, x = cut)) + geom_tile(mapping = aes(fill = n)) Another justification, for switching the order is that the larger numbers are at the top when x = color and y = cut, and that lowers the cognitive burden of interpreting the plot. 5.3.3 Two continuous variables Instead of summarising the conditional distribution with a boxplot, you could use a frequency polygon. What do you need to consider when using cut_width() vs cut_number()? How does that impact a visualisation of the 2d distribution of carat and price? When using cut_width the number in each bin may be unequal. The distribution of carat is right skewed so there are few diamonds in those bins. ggplot(data = diamonds, mapping = aes(x = price, colour = cut_width(carat, 0.3))) + geom_freqpoly() #&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Plotting the density instead of counts will make the distributions comparable, although the bins with few observations will still be hard to interpret. ggplot(data = diamonds, mapping = aes(x = price, y = ..density.., colour = cut_width(carat, 0.3))) + geom_freqpoly() #&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Plotting the density instead of counts will make the distributions comparable, although the bins with few observations will still be hard to interpret. ggplot(data = diamonds, mapping = aes(x = price, colour = cut_number(carat, 10))) + geom_freqpoly() #&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Since there are equal numbers in each bin, the plot looks the same if density is used for the y aesthetic (although the values are on a different scale). ggplot(data = diamonds, mapping = aes(x = price, y = ..density.., colour = cut_number(carat, 10))) + geom_freqpoly() #&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Visualise the distribution of carat, partitioned by price. With a boxplot, partitionining into an 10 bins with the same number of observations: ggplot(diamonds, aes(x = cut_number(price, 10), y = carat)) + geom_boxplot() + coord_flip() + xlab(&quot;Price&quot;) With a boxplot, partitionining into an bins of $2,000 with the width of the box determined by the number of observations. I use boundary = 0 to ensure the first bin goes from $0–$2,000. ggplot(diamonds, aes(x = cut_width(price, 2000, boundary = 0), y = carat)) + geom_boxplot(varwidth = TRUE) + coord_flip() + xlab(&quot;Price&quot;) How does the price distribution of very large diamonds compare to small diamonds. Is it as you expect, or does it surprise you? The distribution of very large diamonds is more variable. I’m not surprised, since I had a very weak prior about diamond prices. Ex post, I would reason that above a certain size other factors such as cut, clarity, color play more of a role in the price. Combine two of the techniques you’ve learned to visualise the combined distribution of cut, carat, and price. There’s lots of options to try: Here’s a couple. What else did you try? What’s the best way? ggplot(diamonds, aes(x = carat, y = price)) + geom_hex() + facet_wrap(~ cut, ncol = 1) + scale_fill_viridis() ggplot(diamonds, aes(x = cut_number(carat, 5), y = price, color = cut)) + geom_boxplot() ggplot(diamonds, aes(color = cut_number(carat, 5), y = price, x = cut)) + geom_boxplot() "],
["tibbles.html", "6 Tibbles 6.1 Prerquisites 6.2 Creating Tibbles 6.3 Tibbles vs. data.frame 6.4 Subsetting 6.5 Interacting with older code 6.6 Exercises", " 6 Tibbles 6.1 Prerquisites library(&quot;tidyverse&quot;) Functions and packages covered in this chapter: package tibble as_tibble, tibble 6.2 Creating Tibbles Why might you want to create non-syntactic variable names? Since variable names are often used as in plots (e.g. axis-titles) or headers in tables, where having spaces or other characters that are invalid R variable names is useful. Those functions will have ways to use text other than the column. 6.3 Tibbles vs. data.frame Discuss the definition of a data frame. What is the traditional R data.frame? In general, discuss how this “dialect” of R relates to base R and other R that they will see. Also, need to discuss types of variables. If nycflights::flights were printed in the console it would be much worse. Just try it, I dare you. as.data.frame(nycflights13::flights) 6.4 Subsetting Note Warnings about partial matching! What is it and why is it dangerous. 6.5 Interacting with older code Note Not all older functions work with tibbles (an example includes giAmelia); usually because they rely on quirks in data.frame behavior that tibbles “fix”. Use as.data.frame() to turn a tibble back into a data.frame. This is usually because of [ and the way it inconsistenly returns a vector or a data frame. With tibbles [ always returns a data frame 6.6 Exercises How can you tell if an object is a tibble? (Hint: try printing mtcars, which is a regular data frame). mtcars #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.62 16.5 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.88 17.0 0 1 4 4 #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.32 18.6 1 1 4 1 #&gt; Hornet 4 Drive 21.4 6 258.0 110 3.08 3.21 19.4 1 0 3 1 #&gt; Hornet Sportabout 18.7 8 360.0 175 3.15 3.44 17.0 0 0 3 2 #&gt; Valiant 18.1 6 225.0 105 2.76 3.46 20.2 1 0 3 1 #&gt; Duster 360 14.3 8 360.0 245 3.21 3.57 15.8 0 0 3 4 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.19 20.0 1 0 4 2 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 #&gt; Merc 280 19.2 6 167.6 123 3.92 3.44 18.3 1 0 4 4 #&gt; Merc 280C 17.8 6 167.6 123 3.92 3.44 18.9 1 0 4 4 #&gt; Merc 450SE 16.4 8 275.8 180 3.07 4.07 17.4 0 0 3 3 #&gt; Merc 450SL 17.3 8 275.8 180 3.07 3.73 17.6 0 0 3 3 #&gt; Merc 450SLC 15.2 8 275.8 180 3.07 3.78 18.0 0 0 3 3 #&gt; Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.25 18.0 0 0 3 4 #&gt; Lincoln Continental 10.4 8 460.0 215 3.00 5.42 17.8 0 0 3 4 #&gt; Chrysler Imperial 14.7 8 440.0 230 3.23 5.34 17.4 0 0 3 4 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.20 19.5 1 1 4 1 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.61 18.5 1 1 4 2 #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.83 19.9 1 1 4 1 #&gt; Toyota Corona 21.5 4 120.1 97 3.70 2.46 20.0 1 0 3 1 #&gt; Dodge Challenger 15.5 8 318.0 150 2.76 3.52 16.9 0 0 3 2 #&gt; AMC Javelin 15.2 8 304.0 150 3.15 3.44 17.3 0 0 3 2 #&gt; Camaro Z28 13.3 8 350.0 245 3.73 3.84 15.4 0 0 3 4 #&gt; Pontiac Firebird 19.2 8 400.0 175 3.08 3.85 17.1 0 0 3 2 #&gt; Fiat X1-9 27.3 4 79.0 66 4.08 1.94 18.9 1 1 4 1 #&gt; Porsche 914-2 26.0 4 120.3 91 4.43 2.14 16.7 0 1 5 2 #&gt; Lotus Europa 30.4 4 95.1 113 3.77 1.51 16.9 1 1 5 2 #&gt; Ford Pantera L 15.8 8 351.0 264 4.22 3.17 14.5 0 1 5 4 #&gt; Ferrari Dino 19.7 6 145.0 175 3.62 2.77 15.5 0 1 5 6 #&gt; Maserati Bora 15.0 8 301.0 335 3.54 3.57 14.6 0 1 5 8 #&gt; Volvo 142E 21.4 4 121.0 109 4.11 2.78 18.6 1 1 4 2 class(mtcars) #&gt; [1] &quot;data.frame&quot; class(as_tibble(mtcars)) #&gt; [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Tibbles will only print out a limited number of rows and show the class on top of each column. Addtionally, tibbles have class &quot;tbl_df&quot; and &quot;tbl_&quot; in addition to &quot;data.frame&quot;. Compare and contrast the following operations on a data.frame and equivalent tibble. What is different? Why might the default data frame behaviours cause you frustration? df &lt;- data.frame(abc = 1, xyz = &quot;a&quot;) df$x #&gt; [1] a #&gt; Levels: a df[, &quot;xyz&quot;] #&gt; [1] a #&gt; Levels: a df[, c(&quot;abc&quot;, &quot;xyz&quot;)] #&gt; abc xyz #&gt; 1 1 a tbl &lt;- as_tibble(df) tbl$x #&gt; Warning: Unknown column &#39;x&#39; #&gt; NULL tbl[, &quot;xyz&quot;] #&gt; # A tibble: 1 × 1 #&gt; xyz #&gt; &lt;fctr&gt; #&gt; 1 a tbl[, c(&quot;abc&quot;, &quot;xyz&quot;)] #&gt; # A tibble: 1 × 2 #&gt; abc xyz #&gt; &lt;dbl&gt; &lt;fctr&gt; #&gt; 1 1 a Using $ a data.frame will partially complete the column. So even though we wrote df$x it returned df$xyz. This saves a few keystrokes, but can result in accidentally using a different variable than you thought you were using. With data.frames, with [ the type of object that is returned differs on the number of columns. If it is one column, it won’t return a data.frame, but instead will return a vector. With more than one column, then it will return a data.frame. This is fine if you know what you are passing in, but suppose you did df[ , vars] where vars was a variable. Then you what that code does depends on length(vars) and you’d have to write code to account for those situations or risk bugs. If you have the name of a variable stored in an object, e.g. var &lt;- &quot;mpg&quot;, how can you extract the reference variable from a tibble? You can use the double bracket, like df[[var]]. You cannot use the dollar sign, becuase df$var would look for a column named var. Practice referring to non-syntactic names in the following data frame by: Extracting the variable called 1. Plotting a scatterplot of 1 vs 2. Creating a new column called 3 which is 2 divided by 1. Renaming the columns to one, two and three. annoying &lt;- tibble( `1` = 1:10, `2` = `1` * 2 + rnorm(length(`1`)) ) Extract the variable called 1: annoying[[&quot;1&quot;]] #&gt; [1] 1 2 3 4 5 6 7 8 9 10 or annoying$`1` #&gt; [1] 1 2 3 4 5 6 7 8 9 10 A scatterplot of 1 vs. 2: ggplot(annoying, aes(x = `1`, y = `2`)) + geom_point() A new column 3 with is 2 divided by 1: annoying[[&quot;3&quot;]] &lt;- annoying$`2` / annoying$`1` or annoying[[&quot;3&quot;]] &lt;- annoying[[&quot;2&quot;]] / annoying[[&quot;1&quot;]] Renaming the columns to one, two, and three: annoying &lt;- rename(annoying, one = `1`, two = `2`, three = `3`) glimpse(annoying) #&gt; Observations: 10 #&gt; Variables: 3 #&gt; $ one &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 #&gt; $ two &lt;dbl&gt; 2.97, 2.99, 5.92, 7.45, 10.75, 11.07, 13.53, 15.14, 16.4... #&gt; $ three &lt;dbl&gt; 2.97, 1.50, 1.97, 1.86, 2.15, 1.84, 1.93, 1.89, 1.83, 2.20 What does tibble::enframe() do? When might you use it? It converts named vectors to a data frame with names and values ?tibble::enframe enframe(c(a = 1, b = 2, c = 3)) #&gt; # A tibble: 3 × 2 #&gt; name value #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 a 1 #&gt; 2 b 2 #&gt; 3 c 3 What option controls how many additional column names are printed at the footer of a tibble? The print function for tibbles is in print.tbl_df: ?print.tbl_df The option n_extra determines the number of extra columns to print information for. "],
["data-import.html", "7 Data Import 7.1 Introduction 7.2 Getting started 7.3 Parsing a vector 7.4 Other Types of Data", " 7 Data Import 7.1 Introduction Functions and packages used: readr, feather, haven, rio read_csv parse_* type_convert save, load readRDS, writeRDS write_csv, write_tsv, write_feather read_lines, read_file library(&quot;tidyverse&quot;) 7.2 Getting started Note: read_log() is important for web data, but likely to be irrelevant to most political science research TODO fill in the links and add any missing 7.2.1 Exercises What function would you use to read a file where fields were separated with “|”? I’d use read_delim with delim=&quot;|&quot;: read_delim(file, delim = &quot;|&quot;) Apart from file, skip, and comment, what other arguments do read_csv() and read_tsv() have in common? They have the following arguments in common: union(names(formals(read_csv)), names(formals(read_tsv))) #&gt; [1] &quot;file&quot; &quot;col_names&quot; &quot;col_types&quot; &quot;locale&quot; &quot;na&quot; #&gt; [6] &quot;quoted_na&quot; &quot;comment&quot; &quot;trim_ws&quot; &quot;skip&quot; &quot;n_max&quot; #&gt; [11] &quot;guess_max&quot; &quot;progress&quot; col_names and col_types are used to specify the column names and how to parse the columns locale is important for determining things like the enecoding and whether “.” or “,” is used as a decimal mark. na and quoted_na control which strings are treated as missing values when parsing vectors trim_ws trims whitespace before and after cells before parsing n_max sets how many rows to read guess_max sets how many rows to use when guessing the column type progress determines whether a progress bar is shown. What are the most important arguments to read_fwf()? The most important argument to read_fwf which reads “fixed-width formats”, is col_positions which tells the function where data columns begin and end. Sometimes strings in a CSV file contain commas. To prevent them from causing problems they need to be surrounded by a quoting character, like &quot; or '. By convention, read_csv() assumes that the quoting character will be &quot;, and if you want to change it you’ll need to use read_delim() instead. What arguments do you need to specify to read the following text into a data frame? &quot;x,y\\n1,&#39;a,b&#39;&quot; x &lt;- &quot;x,y\\n1,&#39;a,b&#39;&quot; read_delim(x, &quot;,&quot;, quote = &quot;&#39;&quot;) #&gt; # A tibble: 1 × 2 #&gt; x y #&gt; &lt;int&gt; &lt;chr&gt; #&gt; 1 1 a,b Identify what is wrong with each of the following inline CSV files. What happens when you run the code? read_csv(&quot;a,b\\n1,2,3\\n4,5,6&quot;) #&gt; Warning: 2 parsing failures. #&gt; row col expected actual file #&gt; 1 -- 2 columns 3 columns literal data #&gt; 2 -- 2 columns 3 columns literal data #&gt; # A tibble: 2 × 2 #&gt; a b #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 2 #&gt; 2 4 5 Only two columns are specified in the header “a” and “b”, but the rows have three columns, so the last column in dropped. read_csv(&quot;a,b,c\\n1,2\\n1,2,3,4&quot;) #&gt; Warning: 2 parsing failures. #&gt; row col expected actual file #&gt; 1 -- 3 columns 2 columns literal data #&gt; 2 -- 3 columns 4 columns literal data #&gt; # A tibble: 2 × 3 #&gt; a b c #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 2 NA #&gt; 2 1 2 3 The numbers of columns in the data do not match the number of columns in the header (three). In row one, there are only two values, so column c is set to missing. In row two, there is an extra value, and that value is dropped. read_csv(&quot;a,b\\n\\&quot;1&quot;) #&gt; Warning: 2 parsing failures. #&gt; row col expected actual file #&gt; 1 a closing quote at end of file literal data #&gt; 1 -- 2 columns 1 columns literal data #&gt; # A tibble: 1 × 2 #&gt; a b #&gt; &lt;int&gt; &lt;chr&gt; #&gt; 1 1 &lt;NA&gt; It’s not clear what the intent was here. The opening quote \\\\&quot;1 is dropped because it is not closed, and a is treated as an integer. read_csv(&quot;a,b\\n1,2\\na,b&quot;) #&gt; # A tibble: 2 × 2 #&gt; a b #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 2 #&gt; 2 a b Both “a” and “b” are treated as character vectors since they contain non-numeric strings. This may have been intentional, or the author may have intended the values of the columns to be “1,2” and “a,b”. read_csv(&quot;a;b\\n1;3&quot;) #&gt; # A tibble: 1 × 1 #&gt; `a;b` #&gt; &lt;chr&gt; #&gt; 1 1;3 The values are separated by “;” rather than “,”. Use read_csv2 instead: read_csv2(&quot;a;b\\n1;3&quot;) #&gt; Using &#39;,&#39; as decimal and &#39;.&#39; as grouping mark. Use read_delim() for more control. #&gt; # A tibble: 1 × 2 #&gt; a b #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 3 7.3 Parsing a vector Notes This is detailed, but these details can make your life hell. Skim now, but be aware that what should be simple, actually is not. In data analysis, ��% is data cleaning, ��% is modeling, and the rest is character encoding issues — Jeffrey B. Arnold (@jrnld) July 31, 2016 This Computerphile video on Unicode is great Characters, Symbols and the Unicode Miracle - Computerphile Note that these issues are real. Reusing one of Chris Adolph’s csv files from an earlier version of this course gave me problems, resulting in me filing this bug report. The suggested reading is very useful: http://kunststube.net/encoding/ This becomes especially useful when you take “Text as Data”. charToRaw(&quot;Jeff&quot;) #&gt; [1] 4a 65 66 66 class(charToRaw(&quot;Jeff&quot;)) #&gt; [1] &quot;raw&quot; 7.3.1 Exercises What are the most important arguments to locale()? The locale broadly controls the following: date and time formats: date_names, date_format, and time_format time_zone: tz numbers: decimal_mark, grouping_mark encoding: encoding What happens if you try and set decimal_mark and grouping_mark to the same character? What happens to the default value of grouping_mark when you set decimal_mark to “,”? What happens to the default value of decimal_mark when you set the grouping_mark to “.”? If the decimal and grouping marks are set to the same character, locale throws an error: locale(decimal_mark = &quot;.&quot;, grouping_mark = &quot;.&quot;) #&gt; Error: `decimal_mark` and `grouping_mark` must be different If the decimal_mark is set to the comma “,&quot;, then the grouping mark is set to the period &quot;.&quot;: locale(decimal_mark = &quot;,&quot;) #&gt; &lt;locale&gt; #&gt; Numbers: 123.456,78 #&gt; Formats: %AD / %AT #&gt; Timezone: UTC #&gt; Encoding: UTF-8 #&gt; &lt;date_names&gt; #&gt; Days: Sunday (Sun), Monday (Mon), Tuesday (Tue), Wednesday (Wed), #&gt; Thursday (Thu), Friday (Fri), Saturday (Sat) #&gt; Months: January (Jan), February (Feb), March (Mar), April (Apr), May #&gt; (May), June (Jun), July (Jul), August (Aug), September #&gt; (Sep), October (Oct), November (Nov), December (Dec) #&gt; AM/PM: AM/PM If the grouping mark is set to a period, then the decimal mark is set to a comma locale(grouping_mark = &quot;,&quot;) #&gt; &lt;locale&gt; #&gt; Numbers: 123,456.78 #&gt; Formats: %AD / %AT #&gt; Timezone: UTC #&gt; Encoding: UTF-8 #&gt; &lt;date_names&gt; #&gt; Days: Sunday (Sun), Monday (Mon), Tuesday (Tue), Wednesday (Wed), #&gt; Thursday (Thu), Friday (Fri), Saturday (Sat) #&gt; Months: January (Jan), February (Feb), March (Mar), April (Apr), May #&gt; (May), June (Jun), July (Jul), August (Aug), September #&gt; (Sep), October (Oct), November (Nov), December (Dec) #&gt; AM/PM: AM/PM I didn’t discuss the date_format and time_format options to locale(). What do they do? Construct an example that shows when they might be useful. They provide default date and time formats. The readr vignette discusses using these to parse dates: since dates can include languages specific weekday and month names, and different conventions for specifying AM/PM locale() #&gt; &lt;locale&gt; #&gt; Numbers: 123,456.78 #&gt; Formats: %AD / %AT #&gt; Timezone: UTC #&gt; Encoding: UTF-8 #&gt; &lt;date_names&gt; #&gt; Days: Sunday (Sun), Monday (Mon), Tuesday (Tue), Wednesday (Wed), #&gt; Thursday (Thu), Friday (Fri), Saturday (Sat) #&gt; Months: January (Jan), February (Feb), March (Mar), April (Apr), May #&gt; (May), June (Jun), July (Jul), August (Aug), September #&gt; (Sep), October (Oct), November (Nov), December (Dec) #&gt; AM/PM: AM/PM Examples from the readr vignette of parsing French dates parse_date(&quot;1 janvier 2015&quot;, &quot;%d %B %Y&quot;, locale = locale(&quot;fr&quot;)) #&gt; [1] &quot;2015-01-01&quot; parse_date(&quot;14 oct. 1979&quot;, &quot;%d %b %Y&quot;, locale = locale(&quot;fr&quot;)) #&gt; [1] &quot;1979-10-14&quot; Apparently the time format is not used for anything, but the date format is used for guessing column types. If you live outside the US, create a new locale object that encapsulates the settings for the types of file you read most commonly. ?locale What’s the difference between read_csv() and read_csv2()? The delimiter. The function read_csv uses a comma, while read_csv2 uses a semi-colon (;). Using a semi-colon is useful when commas are used as the decimal point (as in Europe). What are the most common encodings used in Europe? What are the most common encodings used in Asia? Do some googling to find out. UTF-8 is standard now, and ASCII has been around forever. For the European languages, there are separate encodings for Romance languages and Eastern European languages using Latin script, Cyrillic, Greek, Hebrew, Turkish: usually with separate ISO and Windows encoding standards. There is also Mac OS Roman. For Asian languages Arabic and Vietnamese have ISO and Windows standards. The other major Asian scripts have their own: Japanese: JIS X 0208, Shift JIS, ISO-2022-JP Chinese: GB 2312, GBK, GB 18030 Korean: KS X 1001, EUC-KR, ISO-2022-KR The list in the documentation for stringi::stri_enc_detect is pretty good since it supports the most common encodings: Western European Latin script languages: ISO-8859-1, Windows-1250 (also CP-1250 for code-point) Eastern European Latin script languages: ISO-8859-2, Windows-1252 Greek: ISO-8859-7 Turkish: ISO-8859-9, Windows-1254 Hebrew: ISO-8859-8, IBM424, Windows 1255 Russian: Windows 1251 Japanese: Shift JIS, ISO-2022-JP, EUC-JP Korean: ISO-2022-KR, EUC-KR Chinese: GB18030, ISO-2022-CN (Simplified), Big5 (Traditional) Arabic: ISO-8859-6, IBM420, Windows 1256 For more information: https://en.wikipedia.org/wiki/Character_encoding has a good list http://stackoverflow.com/questions/8509339/what-is-the-most-common-encoding-of-each-language http://kunststube.net/encoding/ Some of the more useful programs for this In R see readr::guess_encoding and the stringi package with str_enc_detect iconv: https://en.wikipedia.org/wiki/Iconv chardet: https://github.com/chardet/chardet (Python) Generate the correct format string to parse each of the following dates and times: 7.4 Other Types of Data NOTES Expand on what’s in this section: The rio package is very useful for loading different types of Other useful functions and packages not mentioned here: Stata: haven, read_dta. While the foreign package in R reads Stata files, it cannot read files created by the most recent version of Stata (&gt; 13). SPSS: haven::read_spss SAS: haven::read_sas XLS: readxl::read_excel JSON: jsonlite pacakge. However, often there are APIs and clients which make this easier, e.g. pollstR which returns data from the Huffington Post Pollster API. XML: xml2 HTML: rvest Databases: DBI and backends PDF: This is really a different thing as you are extracting data from an unstructured form. It also depends on whether the PDF text is actually an image as from a scan, in which case you need to use OCR to first indentify words. tabulizer: extracts tables from PDF documents pdftools: extracts text from pdf documents Also see general text analysis packages like tm, quanteda, etc. which often have functions to assist with getting text from PDFs. Links to Jenny Bryan’s tutorials: purrr-tutorial worked examples Discussing csvy as an example of a csv with metadata "],
["tidy-data.html", "8 Tidy Data 8.1 Introduction 8.2 Tidy Data 8.3 Spreading and Gathering 8.4 Separating and Uniting 8.5 Missing Values 8.6 Case Study 8.7 Non-Tidy Data", " 8 Tidy Data 8.1 Introduction Functions used in this chapter spread gather separate unite complete fill library(tidyverse) 8.2 Tidy Data NOTES Add Tidy Data to reading Use COW war dataset as an example of non-tidy data Also WDI data for non-tidy data Replication datatsets are often non-tidy. Why? See this post by Jeff Leek The Rules Each variable has its own column Each observation muust have its own row Each value must have its own cell or even Put each dataset in a tibble Put each variable in a column These seem obvious at first, so we need to see examples of not-following tidy data and what happens. Some nuances: The definitions of variable, observation, and value are not always clear. And how you store and arrange the data can depend on how you aim to use it. Generally, aim for storing the data in a tidy format that ensures minimal errors. When you model it, you can transform the data later. See non-tidy data. It is easier to work with variables in columns because of mutate and summary functions. It will also work better with tidyverse functions: e.g. using group_by to group and summarize, or facet_* and aesthetics in ggplot2. The tidy data ideas are adapted from the database normalization, but simplified and adapted to the general uses of practicing data scientists. 8.2.1 Exercises Using prose, describe how the variables and observations are organised in each of the sample tables. In table1 each row is a (country, year) with variables cases and population. table1 #&gt; # A tibble: 6 × 4 #&gt; country year cases population #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 Afghanistan 1999 745 19987071 #&gt; 2 Afghanistan 2000 2666 20595360 #&gt; 3 Brazil 1999 37737 172006362 #&gt; 4 Brazil 2000 80488 174504898 #&gt; 5 China 1999 212258 1272915272 #&gt; 6 China 2000 213766 1280428583 In table2, each row is country, year , variable (“cases”, “population”) combination, and there is a count variable with the numeric value of the variable. table2 #&gt; # A tibble: 12 × 4 #&gt; country year type count #&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 Afghanistan 1999 cases 745 #&gt; 2 Afghanistan 1999 population 19987071 #&gt; 3 Afghanistan 2000 cases 2666 #&gt; 4 Afghanistan 2000 population 20595360 #&gt; 5 Brazil 1999 cases 37737 #&gt; 6 Brazil 1999 population 172006362 #&gt; # ... with 6 more rows In table3, each row is a (country, year) combination with the column rate having the rate of cases to population as a character string in the format &quot;cases/rate&quot;. table3 #&gt; # A tibble: 6 × 3 #&gt; country year rate #&gt; * &lt;chr&gt; &lt;int&gt; &lt;chr&gt; #&gt; 1 Afghanistan 1999 745/19987071 #&gt; 2 Afghanistan 2000 2666/20595360 #&gt; 3 Brazil 1999 37737/172006362 #&gt; 4 Brazil 2000 80488/174504898 #&gt; 5 China 1999 212258/1272915272 #&gt; 6 China 2000 213766/1280428583 Table 4 is split into two tables, one table for each variable: table4a is the table for cases, while table4b is the table for population. Within each table, each row is a country, each column is a year, and the cells are the value of the variable for the table. table4a #&gt; # A tibble: 3 × 3 #&gt; country `1999` `2000` #&gt; * &lt;chr&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 Afghanistan 745 2666 #&gt; 2 Brazil 37737 80488 #&gt; 3 China 212258 213766 table4b #&gt; # A tibble: 3 × 3 #&gt; country `1999` `2000` #&gt; * &lt;chr&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 Afghanistan 19987071 20595360 #&gt; 2 Brazil 172006362 174504898 #&gt; 3 China 1272915272 1280428583 Compute the rate for table2, and table4a + table4b. You will need to perform four operations: Extract the number of TB cases per country per year. Extract the matching population per country per year. Divide cases by population, and multiply by 10000. Store back in the appropriate place. Which representation is easiest to work with? Which is hardest? Why? Without using the joins covered in Ch 12: tb2_cases &lt;- filter(table2, type == &quot;cases&quot;)[[&quot;count&quot;]] tb2_country &lt;- filter(table2, type == &quot;cases&quot;)[[&quot;country&quot;]] tb2_year &lt;- filter(table2, type == &quot;cases&quot;)[[&quot;year&quot;]] tb2_population &lt;- filter(table2, type == &quot;population&quot;)[[&quot;count&quot;]] table2_clean &lt;- tibble(country = tb2_country, year = tb2_year, rate = tb2_cases / tb2_population) table2_clean #&gt; # A tibble: 6 × 3 #&gt; country year rate #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 Afghanistan 1999 3.73e-05 #&gt; 2 Afghanistan 2000 1.29e-04 #&gt; 3 Brazil 1999 2.19e-04 #&gt; 4 Brazil 2000 4.61e-04 #&gt; 5 China 1999 1.67e-04 #&gt; 6 China 2000 1.67e-04 Note, that this assumes that all observations are sorted so that each country, year will have the observation for cases followed by population. tibble(country = table4a[[&quot;country&quot;]], `1999` = table4a[[&quot;1999&quot;]] / table4b[[&quot;1999&quot;]], `2000` = table4b[[&quot;2000&quot;]] / table4b[[&quot;2000&quot;]]) #&gt; # A tibble: 3 × 3 #&gt; country `1999` `2000` #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Afghanistan 3.73e-05 1 #&gt; 2 Brazil 2.19e-04 1 #&gt; 3 China 1.67e-04 1 or tibble(country = rep(table4a[[&quot;country&quot;]], 2), year = rep(c(1999, 2000), each = nrow(table4a)), `rate` = c(table4a[[&quot;1999&quot;]] / table4b[[&quot;1999&quot;]], table4b[[&quot;2000&quot;]] / table4b[[&quot;2000&quot;]])) #&gt; # A tibble: 6 × 3 #&gt; country year rate #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Afghanistan 1999 3.73e-05 #&gt; 2 Brazil 1999 2.19e-04 #&gt; 3 China 1999 1.67e-04 #&gt; 4 Afghanistan 2000 1.00e+00 #&gt; 5 Brazil 2000 1.00e+00 #&gt; 6 China 2000 1.00e+00 Recreate the plot showing change in cases over time using table2 instead of table1. What do you need to do first? First, I needed to filter the tibble to only include those rows that represented the “cases” variable. table2 %&gt;% filter(type == &quot;cases&quot;) %&gt;% ggplot(aes(year, count)) + geom_line(aes(group = country), colour = &quot;grey50&quot;) + geom_point(aes(colour = country)) 8.3 Spreading and Gathering tidy4a &lt;- table4a %&gt;% gather(`1999`, `2000`, key = &quot;year&quot;, value = &quot;cases&quot;) tidy4b &lt;- table4b %&gt;% gather(`1999`, `2000`, key = &quot;year&quot;, value = &quot;cases&quot;) left_join(tidy4a, tidy4b) #&gt; Joining, by = c(&quot;country&quot;, &quot;year&quot;, &quot;cases&quot;) #&gt; # A tibble: 6 × 3 #&gt; country year cases #&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 Afghanistan 1999 745 #&gt; 2 Brazil 1999 37737 #&gt; 3 China 1999 212258 #&gt; 4 Afghanistan 2000 2666 #&gt; 5 Brazil 2000 80488 #&gt; 6 China 2000 213766 spread(table2, key = type, value = count) #&gt; # A tibble: 6 × 4 #&gt; country year cases population #&gt; * &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 Afghanistan 1999 745 19987071 #&gt; 2 Afghanistan 2000 2666 20595360 #&gt; 3 Brazil 1999 37737 172006362 #&gt; 4 Brazil 2000 80488 174504898 #&gt; 5 China 1999 212258 1272915272 #&gt; 6 China 2000 213766 1280428583 8.3.1 Exercises Why are gather() and spread() not perfectly symmetrical? Carefully consider the following example: stocks &lt;- tibble( year = c(2015, 2015, 2016, 2016), half = c( 1, 2, 1, 2), return = c(1.88, 0.59, 0.92, 0.17) ) stocks %&gt;% spread(year, return) %&gt;% gather(&quot;year&quot;, &quot;return&quot;, `2015`:`2016`) #&gt; # A tibble: 4 × 3 #&gt; half year return #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 2015 1.88 #&gt; 2 2 2015 0.59 #&gt; 3 1 2016 0.92 #&gt; 4 2 2016 0.17 The functions spread and gather are not perfectly symmetrical because column type information is not transferred between them. In the original table the column year was numeric, but after the spread-gather cyle it is character, because with gather, variable names are always converted to a character vector. The convert argument tries to convert character vectors to the appropriate type. In the background this uses the type.convert function. stocks %&gt;% spread(year, return) %&gt;% gather(&quot;year&quot;, &quot;return&quot;, `2015`:`2016`, convert = TRUE) #&gt; # A tibble: 4 × 3 #&gt; half year return #&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1 2015 1.88 #&gt; 2 2 2015 0.59 #&gt; 3 1 2016 0.92 #&gt; 4 2 2016 0.17 Why does this code fail? table4a %&gt;% gather(1999, 2000, key = &quot;year&quot;, value = &quot;cases&quot;) #&gt; Error in eval(expr, envir, enclos): Position must be between 0 and n The code fails because the column names 1999 and 2000 are not standard and thus needs to be quoted. The tidyverse functions will interpret 1999 and 2000 without quotes as looking for the 1999th and 2000th column of the data frame. This will work: table4a %&gt;% gather(`1999`, `2000`, key = &quot;year&quot;, value = &quot;cases&quot;) #&gt; # A tibble: 6 × 3 #&gt; country year cases #&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 Afghanistan 1999 745 #&gt; 2 Brazil 1999 37737 #&gt; 3 China 1999 212258 #&gt; 4 Afghanistan 2000 2666 #&gt; 5 Brazil 2000 80488 #&gt; 6 China 2000 213766 Why does spreading this tibble fail? How could you add a new column to fix the problem? people &lt;- tribble( ~name, ~key, ~value, #-----------------|--------|------ &quot;Phillip Woods&quot;, &quot;age&quot;, 45, &quot;Phillip Woods&quot;, &quot;height&quot;, 186, &quot;Phillip Woods&quot;, &quot;age&quot;, 50, &quot;Jessica Cordero&quot;, &quot;age&quot;, 37, &quot;Jessica Cordero&quot;, &quot;height&quot;, 156 ) glimpse(people) #&gt; Observations: 5 #&gt; Variables: 3 #&gt; $ name &lt;chr&gt; &quot;Phillip Woods&quot;, &quot;Phillip Woods&quot;, &quot;Phillip Woods&quot;, &quot;Jess... #&gt; $ key &lt;chr&gt; &quot;age&quot;, &quot;height&quot;, &quot;age&quot;, &quot;age&quot;, &quot;height&quot; #&gt; $ value &lt;dbl&gt; 45, 186, 50, 37, 156 spread(people, key, value) #&gt; Error: Duplicate identifiers for rows (1, 3) Spreading the data frame fails because there are two rows with “age” for “Phillip Woods”. We would need to add another column with an indicator for the number observation it is, people &lt;- tribble( ~name, ~key, ~value, ~obs, #-----------------|--------|------|------ &quot;Phillip Woods&quot;, &quot;age&quot;, 45, 1, &quot;Phillip Woods&quot;, &quot;height&quot;, 186, 1, &quot;Phillip Woods&quot;, &quot;age&quot;, 50, 2, &quot;Jessica Cordero&quot;, &quot;age&quot;, 37, 1, &quot;Jessica Cordero&quot;, &quot;height&quot;, 156, 1 ) spread(people, key, value) #&gt; # A tibble: 3 × 4 #&gt; name obs age height #&gt; * &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Jessica Cordero 1 37 156 #&gt; 2 Phillip Woods 1 45 186 #&gt; 3 Phillip Woods 2 50 NA Tidy the simple tibble below. Do you need to spread or gather it? What are the variables? preg &lt;- tribble( ~pregnant, ~male, ~female, &quot;yes&quot;, NA, 10, &quot;no&quot;, 20, 12 ) You need to gather it. The variables are: pregnant: logical (“yes”, “no”) female: logical count: integer gather(preg, sex, count, male, female) %&gt;% mutate(pregnant = pregnant == &quot;yes&quot;, female = sex == &quot;female&quot;) %&gt;% select(-sex) #&gt; # A tibble: 4 × 3 #&gt; pregnant count female #&gt; &lt;lgl&gt; &lt;dbl&gt; &lt;lgl&gt; #&gt; 1 TRUE NA FALSE #&gt; 2 FALSE 20 FALSE #&gt; 3 TRUE 10 TRUE #&gt; 4 FALSE 12 TRUE Converting pregnant and female from character vectors to logical was not necessary to tidy it, but it makes it easier to work with. 8.4 Separating and Uniting table3 %&gt;% separate(rate, into = c(&quot;cases&quot;, &quot;population&quot;), sep = &quot;/&quot;, convert = TRUE) %&gt;% separate(year, into = c(&quot;century&quot;, &quot;year&quot;), sep = 2) #&gt; # A tibble: 6 × 5 #&gt; country century year cases population #&gt; * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 Afghanistan 19 99 745 19987071 #&gt; 2 Afghanistan 20 00 2666 20595360 #&gt; 3 Brazil 19 99 37737 172006362 #&gt; 4 Brazil 20 00 80488 174504898 #&gt; 5 China 19 99 212258 1272915272 #&gt; 6 China 20 00 213766 1280428583 table5 %&gt;% unite(new, century, year, sep = &quot;&quot;) #&gt; # A tibble: 6 × 3 #&gt; country new rate #&gt; * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Afghanistan 1999 745/19987071 #&gt; 2 Afghanistan 2000 2666/20595360 #&gt; 3 Brazil 1999 37737/172006362 #&gt; 4 Brazil 2000 80488/174504898 #&gt; 5 China 1999 212258/1272915272 #&gt; 6 China 2000 213766/1280428583 8.4.1 Exercises What do the extra and fill arguments do in separate()? Experiment with the various options for the following two toy datasets. tibble(x = c(&quot;a,b,c&quot;, &quot;d,e,f,g&quot;, &quot;h,i,j&quot;)) %&gt;% separate(x, c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)) #&gt; Warning: Too many values at 1 locations: 2 #&gt; # A tibble: 3 × 3 #&gt; one two three #&gt; * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 a b c #&gt; 2 d e f #&gt; 3 h i j tibble(x = c(&quot;a,b,c&quot;, &quot;d,e&quot;, &quot;f,g,i&quot;)) %&gt;% separate(x, c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)) #&gt; Warning: Too few values at 1 locations: 2 #&gt; # A tibble: 3 × 3 #&gt; one two three #&gt; * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 a b c #&gt; 2 d e &lt;NA&gt; #&gt; 3 f g i ?separate The extra argument tells separate what to do if there are too many pieces, and the fill argument if there aren’t enough. tibble(x = c(&quot;a,b,c&quot;, &quot;d,e,f,g&quot;, &quot;h,i,j&quot;)) %&gt;% separate(x, c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)) #&gt; Warning: Too many values at 1 locations: 2 #&gt; # A tibble: 3 × 3 #&gt; one two three #&gt; * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 a b c #&gt; 2 d e f #&gt; 3 h i j By default separate drops the extra values with a warning. tibble(x = c(&quot;a,b,c&quot;, &quot;d,e,f,g&quot;, &quot;h,i,j&quot;)) %&gt;% separate(x, c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;), extra = &quot;drop&quot;) #&gt; # A tibble: 3 × 3 #&gt; one two three #&gt; * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 a b c #&gt; 2 d e f #&gt; 3 h i j This produces the same result as above, dropping extra values, but without the warning. tibble(x = c(&quot;a,b,c&quot;, &quot;d,e,f,g&quot;, &quot;h,i,j&quot;)) %&gt;% separate(x, c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;), extra = &quot;merge&quot;) #&gt; # A tibble: 3 × 3 #&gt; one two three #&gt; * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 a b c #&gt; 2 d e f,g #&gt; 3 h i j In this, the extra values are not split, so “f,g” appears in column three. In this, one of the entries for column, “d,e”, has too few elements. The default for fill is similar to separate; it fills with missing values but emits a warning. In this, row 2 of column “three”, is NA. tibble(x = c(&quot;a,b,c&quot;, &quot;d,e&quot;, &quot;f,g,i&quot;)) %&gt;% separate(x, c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)) #&gt; Warning: Too few values at 1 locations: 2 #&gt; # A tibble: 3 × 3 #&gt; one two three #&gt; * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 a b c #&gt; 2 d e &lt;NA&gt; #&gt; 3 f g i Alternative options for fill are &quot;right&quot;, to fill with missing values from the right, but without a warning tibble(x = c(&quot;a,b,c&quot;, &quot;d,e&quot;, &quot;f,g,i&quot;)) %&gt;% separate(x, c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;), fill = &quot;right&quot;) #&gt; # A tibble: 3 × 3 #&gt; one two three #&gt; * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 a b c #&gt; 2 d e &lt;NA&gt; #&gt; 3 f g i The option fill = &quot;left&quot; also fills with missing values without a warning, but this time from the left side. Now, column “one” of row 2 will be missing, and the other values in that row are shifted over. tibble(x = c(&quot;a,b,c&quot;, &quot;d,e&quot;, &quot;f,g,i&quot;)) %&gt;% separate(x, c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;), fill = &quot;left&quot;) #&gt; # A tibble: 3 × 3 #&gt; one two three #&gt; * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 a b c #&gt; 2 &lt;NA&gt; d e #&gt; 3 f g i Both unite() and separate() have a remove argument. What does it do? Why would you set it to FALSE? You would set it to FALSE if you want to create a new variable, but keep the old one. Compare and contrast separate() and extract(), Why are there three variations of separation (by position, by separator, and with groups), but only one unite? The function extract uses a regular expression to find groups and split into columns. In unite it is unambigous since it is many columns to one, and once the columns are specified, there is only one way to do it, the only choice is the sep. In separate, it is one to many, and there are multiple ways to split the character string. 8.5 Missing Values 8.5.1 Exercises Compare and contrast the fill arguments to spread() and complete(). ?spread ?complete In spread, the fill argument explicitly sets the value to replace NAs. In complete, the fill argument also sets a value to replace NAs but it is named list, allowing for different values for different variables. Also, both cases replace both implicit and explicit missing values. What does the direction argument to fill() do? With fill, it determines whether NA values should be replaced by the previous non-missing value (&quot;down&quot;) or the next non-missing value (&quot;up&quot;). 8.6 Case Study who1 &lt;- who %&gt;% gather(new_sp_m014:newrel_f65, key = &quot;key&quot;, value = &quot;cases&quot;, na.rm = TRUE) glimpse(who1) #&gt; Observations: 76,046 #&gt; Variables: 6 #&gt; $ country &lt;chr&gt; &quot;Afghanistan&quot;, &quot;Afghanistan&quot;, &quot;Afghanistan&quot;, &quot;Afghanis... #&gt; $ iso2 &lt;chr&gt; &quot;AF&quot;, &quot;AF&quot;, &quot;AF&quot;, &quot;AF&quot;, &quot;AF&quot;, &quot;AF&quot;, &quot;AF&quot;, &quot;AF&quot;, &quot;AF&quot;, ... #&gt; $ iso3 &lt;chr&gt; &quot;AFG&quot;, &quot;AFG&quot;, &quot;AFG&quot;, &quot;AFG&quot;, &quot;AFG&quot;, &quot;AFG&quot;, &quot;AFG&quot;, &quot;AFG&quot;... #&gt; $ year &lt;int&gt; 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, ... #&gt; $ key &lt;chr&gt; &quot;new_sp_m014&quot;, &quot;new_sp_m014&quot;, &quot;new_sp_m014&quot;, &quot;new_sp_m... #&gt; $ cases &lt;int&gt; 0, 30, 8, 52, 129, 90, 127, 139, 151, 193, 186, 187, 2... who2 &lt;- who1 %&gt;% mutate(key = stringr::str_replace(key, &quot;newrel&quot;, &quot;new_rel&quot;)) who3 &lt;- who2 %&gt;% separate(key, c(&quot;new&quot;, &quot;type&quot;, &quot;sexage&quot;), sep = &quot;_&quot;) who3 #&gt; # A tibble: 76,046 × 8 #&gt; country iso2 iso3 year new type sexage cases #&gt; * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 Afghanistan AF AFG 1997 new sp m014 0 #&gt; 2 Afghanistan AF AFG 1998 new sp m014 30 #&gt; 3 Afghanistan AF AFG 1999 new sp m014 8 #&gt; 4 Afghanistan AF AFG 2000 new sp m014 52 #&gt; 5 Afghanistan AF AFG 2001 new sp m014 129 #&gt; 6 Afghanistan AF AFG 2002 new sp m014 90 #&gt; # ... with 7.604e+04 more rows who3 %&gt;% count(new) #&gt; # A tibble: 1 × 2 #&gt; new n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 new 76046 who4 &lt;- who3 %&gt;% select(-new, -iso2, -iso3) who5 &lt;- who4 %&gt;% separate(sexage, c(&quot;sex&quot;, &quot;age&quot;), sep = 1) who5 #&gt; # A tibble: 76,046 × 6 #&gt; country year type sex age cases #&gt; * &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 Afghanistan 1997 sp m 014 0 #&gt; 2 Afghanistan 1998 sp m 014 30 #&gt; 3 Afghanistan 1999 sp m 014 8 #&gt; 4 Afghanistan 2000 sp m 014 52 #&gt; 5 Afghanistan 2001 sp m 014 129 #&gt; 6 Afghanistan 2002 sp m 014 90 #&gt; # ... with 7.604e+04 more rows 8.6.1 Exercises In this case study I set na.rm = TRUE just to make it easier to check that we had the correct values. Is this reasonable? Think about how missing values are represented in this dataset. Are there implicit missing values? What’s the difference between an NA and zero? Perhaps? I would need to know more about the data generation process. There are zero’s in the data, which means they may explicitly be indicating no cases. who1 %&gt;% filter(cases == 0) %&gt;% nrow() #&gt; [1] 11080 So it appears that either a country has all its values in a year as non-missing if the WHO collected data for that country, or all its values are non-missing. So it is okay to treat explicitly and implicitly missing values the same, and we don’t lose any information by dropping them. gather(who, new_sp_m014:newrel_f65, key = &quot;key&quot;, value = &quot;cases&quot;) %&gt;% group_by(country, year) %&gt;% mutate(missing = is.na(cases)) %&gt;% select(country, year, missing) %&gt;% distinct() %&gt;% group_by(country, year) %&gt;% filter(n() &gt; 1) #&gt; Source: local data frame [0 x 2] #&gt; Groups: country, year [0] #&gt; #&gt; # ... with 2 variables: country &lt;chr&gt;, year &lt;int&gt; What happens if you neglect the mutate() step? (mutate(key = stringr::str_replace(key, &quot;newrel&quot;, &quot;new_rel&quot;)) separate emits the warning “too few values”, and if we check the rows for keys beginning with &quot;newrel_&quot;, we see that sexage is messing, and type = m014. who3a &lt;- who1 %&gt;% separate(key, c(&quot;new&quot;, &quot;type&quot;, &quot;sexage&quot;), sep = &quot;_&quot;) #&gt; Warning: Too few values at 2580 locations: 73467, 73468, 73469, 73470, #&gt; 73471, 73472, 73473, 73474, 73475, 73476, 73477, 73478, 73479, 73480, #&gt; 73481, 73482, 73483, 73484, 73485, 73486, ... filter(who3a, new == &quot;newrel&quot;) %&gt;% head() #&gt; # A tibble: 6 × 8 #&gt; country iso2 iso3 year new type sexage cases #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 Afghanistan AF AFG 2013 newrel m014 &lt;NA&gt; 1705 #&gt; 2 Albania AL ALB 2013 newrel m014 &lt;NA&gt; 14 #&gt; 3 Algeria DZ DZA 2013 newrel m014 &lt;NA&gt; 25 #&gt; 4 Andorra AD AND 2013 newrel m014 &lt;NA&gt; 0 #&gt; 5 Angola AO AGO 2013 newrel m014 &lt;NA&gt; 486 #&gt; 6 Anguilla AI AIA 2013 newrel m014 &lt;NA&gt; 0 I claimed that iso2 and iso3 were redundant with country. Confirm this claim. select(who3, country, iso2, iso3) %&gt;% distinct() %&gt;% group_by(country) %&gt;% filter(n() &gt; 1) #&gt; Source: local data frame [0 x 3] #&gt; Groups: country [0] #&gt; #&gt; # ... with 3 variables: country &lt;chr&gt;, iso2 &lt;chr&gt;, iso3 &lt;chr&gt; For each country, year, and sex compute the total number of cases of TB. Make an informative visualisation of the data. who5 %&gt;% group_by(country, year, sex) %&gt;% filter(year &gt; 1995) %&gt;% summarise(cases = sum(cases)) %&gt;% unite(country_sex, country, sex, remove = FALSE) %&gt;% ggplot(aes(x = year, y = cases, group = country_sex, colour = sex)) + geom_line() A small multiples plot faceting by country is difficult given the number of countries. Focusing on those countries with the largest changes or absolute magnitudes after providing the context above is another option. 8.7 Non-Tidy Data Corpus and text data is often stored in sparse Matrices https://cran.r-project.org/web/packages/tm/tm.pdf Graphical data has its own format: http://igraph.org/r/doc/ "],
["relational-data.html", "9 Relational Data 9.1 Prerequisites 9.2 nycflights13 9.3 Keys 9.4 Mutating Joins 9.5 Filtering Joins 9.6 Set operations", " 9 Relational Data 9.1 Prerequisites library(&quot;tidyverse&quot;) library(&quot;nycflights13&quot;) Topics, functions keys: primary key, foreign key, mutating joins: left_join, right_join, inner_join, full_join merge vs. joins filtering joins: semi_join, anti_join set operations: intersect, union, setdiff TODO: fuzzy joining 9.2 nycflights13 NOTES nycflights13 is an example of a data-only R package. R packages can contain both functions and data. Since data-sets can get large, often they can be packaged as their own dataset. These sorts of data-only R packages make it convenient for R users to access your data, but it should not be the only way you provide your research data. Not everyone uses R, so the original data should be provided in a program agnostic format (e.g. csv files). This also holds for those using Stata; they should not be distributing data in .dta format files specific to Stata (even if as we saw earlier, other programs can read that data.) Another example of a data-only R package is gapminder. How does Hadley create his diagrams? The four tables in the nycflights13 package: airlines #&gt; # A tibble: 16 × 2 #&gt; carrier name #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 9E Endeavor Air Inc. #&gt; 2 AA American Airlines Inc. #&gt; 3 AS Alaska Airlines Inc. #&gt; 4 B6 JetBlue Airways #&gt; 5 DL Delta Air Lines Inc. #&gt; 6 EV ExpressJet Airlines Inc. #&gt; # ... with 10 more rows airports #&gt; # A tibble: 1,458 × 8 #&gt; faa name lat lon alt tz dst #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 04G Lansdowne Airport 41.1 -80.6 1044 -5 A #&gt; 2 06A Moton Field Municipal Airport 32.5 -85.7 264 -6 A #&gt; 3 06C Schaumburg Regional 42.0 -88.1 801 -6 A #&gt; 4 06N Randall Airport 41.4 -74.4 523 -5 A #&gt; 5 09J Jekyll Island Airport 31.1 -81.4 11 -5 A #&gt; 6 0A9 Elizabethton Municipal Airport 36.4 -82.2 1593 -5 A #&gt; # ... with 1,452 more rows, and 1 more variables: tzone &lt;chr&gt; planes #&gt; # A tibble: 3,322 × 9 #&gt; tailnum year type manufacturer model engines #&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 N10156 2004 Fixed wing multi engine EMBRAER EMB-145XR 2 #&gt; 2 N102UW 1998 Fixed wing multi engine AIRBUS INDUSTRIE A320-214 2 #&gt; 3 N103US 1999 Fixed wing multi engine AIRBUS INDUSTRIE A320-214 2 #&gt; 4 N104UW 1999 Fixed wing multi engine AIRBUS INDUSTRIE A320-214 2 #&gt; 5 N10575 2002 Fixed wing multi engine EMBRAER EMB-145LR 2 #&gt; 6 N105UW 1999 Fixed wing multi engine AIRBUS INDUSTRIE A320-214 2 #&gt; # ... with 3,316 more rows, and 3 more variables: seats &lt;int&gt;, #&gt; # speed &lt;int&gt;, engine &lt;chr&gt; weather #&gt; # A tibble: 26,130 × 15 #&gt; origin year month day hour temp dewp humid wind_dir wind_speed #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 EWR 2013 1 1 0 37.0 21.9 54.0 230 10.4 #&gt; 2 EWR 2013 1 1 1 37.0 21.9 54.0 230 13.8 #&gt; 3 EWR 2013 1 1 2 37.9 21.9 52.1 230 12.7 #&gt; 4 EWR 2013 1 1 3 37.9 23.0 54.5 230 13.8 #&gt; 5 EWR 2013 1 1 4 37.9 24.1 57.0 240 15.0 #&gt; 6 EWR 2013 1 1 6 39.0 26.1 59.4 270 10.4 #&gt; # ... with 2.612e+04 more rows, and 5 more variables: wind_gust &lt;dbl&gt;, #&gt; # precip &lt;dbl&gt;, pressure &lt;dbl&gt;, visib &lt;dbl&gt;, time_hour &lt;dttm&gt; 9.2.1 Exercises Imagine you wanted to draw (approximately) the route each plane flies from its origin to its destination. What variables would you need? What tables would you need to combine? flights table: origin and dest airports table: longitude and latitude variables We would merge the flights with airports twice: once to get the location of the origin airport, and once to get the location of the dest airport. I forgot to draw the relationship between weather and airports. What is the relationship and how should it appear in the diagram? The variable origin in weather is matched with faa in airports. weather only contains information for the origin (NYC) airports. If it contained weather records for all airports in the USA, what additional relation would it define with flights? year, month, day, hour, origin in weather would be matched to year, month, day, hour, dest in flight (though it should use the arrival date-time values for dest if possible). We know that some days of the year are “special”, and fewer people than usual fly on them. How might you represent that data as a data frame? What would be the primary keys of that table? How would it connect to the existing tables? I would add a table of special dates. The primary key would be date. It would match to the year, month, day columns of `flights. 9.3 Keys Add a surrogate key to flights. I add the column flight_id as a surrogate key. I sort the data prior to making the key, even though it is not strictly necessary, so the order of the rows has some meaning. flights %&gt;% arrange(year, month, day, sched_dep_time, carrier, flight) %&gt;% mutate(flight_id = row_number()) %&gt;% glimpse() #&gt; Observations: 336,776 #&gt; Variables: 20 #&gt; $ year &lt;int&gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013,... #&gt; $ month &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,... #&gt; $ day &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,... #&gt; $ dep_time &lt;int&gt; 517, 533, 542, 544, 554, 559, 558, 559, 558, 55... #&gt; $ sched_dep_time &lt;int&gt; 515, 529, 540, 545, 558, 559, 600, 600, 600, 60... #&gt; $ dep_delay &lt;dbl&gt; 2, 4, 2, -1, -4, 0, -2, -1, -2, -2, -3, NA, 1, ... #&gt; $ arr_time &lt;int&gt; 830, 850, 923, 1004, 740, 702, 753, 941, 849, 8... #&gt; $ sched_arr_time &lt;int&gt; 819, 830, 850, 1022, 728, 706, 745, 910, 851, 8... #&gt; $ arr_delay &lt;dbl&gt; 11, 20, 33, -18, 12, -4, 8, 31, -2, -3, -8, NA,... #&gt; $ carrier &lt;chr&gt; &quot;UA&quot;, &quot;UA&quot;, &quot;AA&quot;, &quot;B6&quot;, &quot;UA&quot;, &quot;B6&quot;, &quot;AA&quot;, &quot;AA&quot;,... #&gt; $ flight &lt;int&gt; 1545, 1714, 1141, 725, 1696, 1806, 301, 707, 49... #&gt; $ tailnum &lt;chr&gt; &quot;N14228&quot;, &quot;N24211&quot;, &quot;N619AA&quot;, &quot;N804JB&quot;, &quot;N39463... #&gt; $ origin &lt;chr&gt; &quot;EWR&quot;, &quot;LGA&quot;, &quot;JFK&quot;, &quot;JFK&quot;, &quot;EWR&quot;, &quot;JFK&quot;, &quot;LGA&quot;... #&gt; $ dest &lt;chr&gt; &quot;IAH&quot;, &quot;IAH&quot;, &quot;MIA&quot;, &quot;BQN&quot;, &quot;ORD&quot;, &quot;BOS&quot;, &quot;ORD&quot;... #&gt; $ air_time &lt;dbl&gt; 227, 227, 160, 183, 150, 44, 138, 257, 149, 158... #&gt; $ distance &lt;dbl&gt; 1400, 1416, 1089, 1576, 719, 187, 733, 1389, 10... #&gt; $ hour &lt;dbl&gt; 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,... #&gt; $ minute &lt;dbl&gt; 15, 29, 40, 45, 58, 59, 0, 0, 0, 0, 0, 0, 0, 0,... #&gt; $ time_hour &lt;dttm&gt; 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013... #&gt; $ flight_id &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, ... Identify the keys in the following datasets Lahman::Batting babynames::babynames nasaweather::atmos fueleconomy::vehicles ggplot2::diamonds (You might need to install some packages and read some documentation.) The primary key for Lahman::Batting is playerID, yearID, stint. It is not simply playerID, yearID because players can have different stints in different leagues within the same year. Lahman::Batting %&gt;% group_by(playerID, yearID, stint) %&gt;% filter(n() &gt; 1) %&gt;% nrow() #&gt; [1] 0 The primary key for babynames::babynames is year, sex, name. It is no simply year, name since names can appear for both sexes with different counts. babynames::babynames %&gt;% group_by(year, sex, name) %&gt;% filter(n() &gt; 1) %&gt;% nrow() #&gt; [1] 0 The primary key for nasaweather::atmos is the location and time of the measurement: lat, long, year, month. nasaweather::atmos %&gt;% group_by(lat, long, year, month) %&gt;% filter(n() &gt; 1) %&gt;% nrow() #&gt; [1] 0 The column id (unique EPA identifier) is the primary key for fueleconomy::vehicles: fueleconomy::vehicles %&gt;% group_by(id) %&gt;% filter(n() &gt; 1) %&gt;% nrow() #&gt; [1] 0 There is no primary key for ggplot2::diamonds. Using all variables in the data frame, the number of distinct rows is less than the total number of rows, meaning no combination of variables uniquely identifies the observations. ggplot2::diamonds %&gt;% distinct() %&gt;% nrow() #&gt; [1] 53794 nrow(ggplot2::diamonds) #&gt; [1] 53940 Draw a diagram illustrating the connections between the Batting, Master, and Salaries tables in the Lahman package. Draw another diagram that shows the relationship between Master, Managers, AwardsManagers. Batting primary key: playerID, yearID, stint foreign keys: playerID -&gt; Master.playerID Master primary key: playerID Salaries primary key: yearID, teamID, playerID foreign keys: playerID -&gt; Master.playerID Managers: primary key: yearID, playerID, teamID, inseason foreign keys: playerID -&gt; Master.teamID Managers: primary key: awardID, yearID AwardsManagers: primary key: playerID, awardID, yearID (since there are ties and while tie distinguishes those awards it has NA values) foreign keys: playerID -&gt; Master.playerID playerID, yearID, lgID -&gt; Managers.playerID, yearID, lgID lgID and teamID appear in multiple tables, but should be primary keys for league and team tables. How would you characterise the relationship between the Batting, Pitching, and Fielding tables? 9.4 Mutating Joins flights2 &lt;- flights %&gt;% select(year:day, hour, origin, dest, tailnum, carrier) flights2 %&gt;% select(-origin, -dest) %&gt;% left_join(airlines, by = &quot;carrier&quot;) #&gt; # A tibble: 336,776 × 7 #&gt; year month day hour tailnum carrier name #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 2013 1 1 5 N14228 UA United Air Lines Inc. #&gt; 2 2013 1 1 5 N24211 UA United Air Lines Inc. #&gt; 3 2013 1 1 5 N619AA AA American Airlines Inc. #&gt; 4 2013 1 1 5 N804JB B6 JetBlue Airways #&gt; 5 2013 1 1 6 N668DN DL Delta Air Lines Inc. #&gt; 6 2013 1 1 5 N39463 UA United Air Lines Inc. #&gt; # ... with 3.368e+05 more rows 9.4.1 Exercises Compute the average delay by destination, then join on the airports data frame so you can show the spatial distribution of delays. Here’s an easy way to draw a map of the United States: airports %&gt;% semi_join(flights, c(&quot;faa&quot; = &quot;dest&quot;)) %&gt;% ggplot(aes(lon, lat)) + borders(&quot;state&quot;) + geom_point() + coord_quickmap() #&gt; #&gt; Attaching package: &#39;maps&#39; #&gt; The following object is masked from &#39;package:purrr&#39;: #&gt; #&gt; map (Don’t worry if you don’t understand what semi_join() does — you’ll learn about it next.) avg_dest_delays &lt;- flights %&gt;% group_by(dest) %&gt;% # arrival delay NA&#39;s are cancelled flights summarise(delay = mean(arr_delay, na.rm = TRUE)) %&gt;% inner_join(airports, by = c(dest = &quot;faa&quot;)) avg_dest_delays %&gt;% ggplot(aes(lon, lat, colour = delay)) + borders(&quot;state&quot;) + geom_point() + coord_quickmap() You might want to use the size or colour of the points to display the average delay for each airport. Add the location of the origin and destination (i.e. the lat and lon) to flights. flights %&gt;% left_join(airports, by = c(dest = &quot;faa&quot;)) %&gt;% left_join(airports, by = c(origin = &quot;faa&quot;)) %&gt;% head() #&gt; # A tibble: 6 × 33 #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 #&gt; 2 2013 1 1 533 529 4 850 #&gt; 3 2013 1 1 542 540 2 923 #&gt; 4 2013 1 1 544 545 -1 1004 #&gt; 5 2013 1 1 554 600 -6 812 #&gt; 6 2013 1 1 554 558 -4 740 #&gt; # ... with 26 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, #&gt; # time_hour &lt;dttm&gt;, name.x &lt;chr&gt;, lat.x &lt;dbl&gt;, lon.x &lt;dbl&gt;, alt.x &lt;int&gt;, #&gt; # tz.x &lt;dbl&gt;, dst.x &lt;chr&gt;, tzone.x &lt;chr&gt;, name.y &lt;chr&gt;, lat.y &lt;dbl&gt;, #&gt; # lon.y &lt;dbl&gt;, alt.y &lt;int&gt;, tz.y &lt;dbl&gt;, dst.y &lt;chr&gt;, tzone.y &lt;chr&gt; Is there a relationship between the age of a plane and its delays? Suprisingly not. If anything (departure) delay seems to decrease slightly with age (perhaps because of selection): plane_ages &lt;- planes %&gt;% mutate(age = 2013 - year) %&gt;% select(tailnum, age) flights %&gt;% inner_join(plane_ages, by = &quot;tailnum&quot;) %&gt;% group_by(age) %&gt;% filter(!is.na(dep_delay)) %&gt;% summarise(delay = mean(dep_delay)) %&gt;% ggplot(aes(x = age, y = delay)) + geom_point() + geom_line() #&gt; Warning: Removed 1 rows containing missing values (geom_point). #&gt; Warning: Removed 1 rows containing missing values (geom_path). What weather conditions make it more likely to see a delay? Almost any amount or precipitation is associated with a delay, though not as strong a trend after 0.02 in as one would expect flight_weather &lt;- flights %&gt;% inner_join(weather, by = c(&quot;origin&quot; = &quot;origin&quot;, &quot;year&quot; = &quot;year&quot;, &quot;month&quot; = &quot;month&quot;, &quot;day&quot; = &quot;day&quot;, &quot;hour&quot; = &quot;hour&quot;)) flight_weather %&gt;% group_by(precip) %&gt;% summarise(delay = mean(dep_delay, na.rm = TRUE)) %&gt;% ggplot(aes(x = precip, y = delay)) + geom_line() + geom_point() What happened on June 13 2013? Display the spatial pattern of delays, and then use Google to cross-reference with the weather. There was a large series of storms (derechos) in the southeastern US (see June 12-13, 2013 derecho series) The largest delays are in Tennessee (Nashville) and the Southeaste and Midwest (the location of the derechos). library(viridis) flights %&gt;% filter(year == 2013, month == 6, day == 13) %&gt;% group_by(dest) %&gt;% summarise(delay = mean(arr_delay, na.rm = TRUE)) %&gt;% inner_join(airports, by = c(&quot;dest&quot; = &quot;faa&quot;)) %&gt;% ggplot(aes(y = lat, x = lon, size = delay, colour = delay)) + borders(&quot;state&quot;) + geom_point() + coord_quickmap() + scale_color_viridis() #&gt; Warning: Removed 3 rows containing missing values (geom_point). 9.5 Filtering Joins semi_join: keep all obs in x with match in y anti_join: drop all obs in x with a match in y 9.5.1 Exercises What does it mean for a flight to have a missing tailnum? What do the tail numbers that don’t have a matching record in planes have in common? (Hint: one variable explains ~90% of the problems.) American Airlines (AA) and Envoy Airlines (MQ) don’t report tail numbers. flights %&gt;% anti_join(planes, by = &quot;tailnum&quot;) %&gt;% count(carrier, sort = TRUE) #&gt; # A tibble: 10 × 2 #&gt; carrier n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 MQ 25397 #&gt; 2 AA 22558 #&gt; 3 UA 1693 #&gt; 4 9E 1044 #&gt; 5 B6 830 #&gt; 6 US 699 #&gt; # ... with 4 more rows Filter flights to only show flights with planes that have flown at least 100 flights. planes_gt100 &lt;- filter(flights) %&gt;% group_by(tailnum) %&gt;% count() %&gt;% filter(n &gt; 100) flights %&gt;% semi_join(planes_gt100, by = &quot;tailnum&quot;) #&gt; # A tibble: 229,202 × 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 1 1 1604 1510 54 1817 #&gt; 2 2013 1 1 2100 2100 0 2307 #&gt; 3 2013 1 2 827 835 -8 1059 #&gt; 4 2013 1 2 2014 2020 -6 2256 #&gt; 5 2013 1 4 1621 1625 -4 1853 #&gt; 6 2013 1 5 834 835 -1 1050 #&gt; # ... with 2.292e+05 more rows, and 12 more variables: #&gt; # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, #&gt; # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, #&gt; # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Combine fueleconomy::vehicles and fueleconomy::common to find only the records for the most common models. The table fueleconomy::common identifies vehicles by make and model: glimpse(fueleconomy::vehicles) #&gt; Observations: 33,442 #&gt; Variables: 12 #&gt; $ id &lt;int&gt; 27550, 28426, 27549, 28425, 1032, 1033, 3347, 13309, 133... #&gt; $ make &lt;chr&gt; &quot;AM General&quot;, &quot;AM General&quot;, &quot;AM General&quot;, &quot;AM General&quot;, ... #&gt; $ model &lt;chr&gt; &quot;DJ Po Vehicle 2WD&quot;, &quot;DJ Po Vehicle 2WD&quot;, &quot;FJ8c Post Off... #&gt; $ year &lt;int&gt; 1984, 1984, 1984, 1984, 1985, 1985, 1987, 1997, 1997, 19... #&gt; $ class &lt;chr&gt; &quot;Special Purpose Vehicle 2WD&quot;, &quot;Special Purpose Vehicle ... #&gt; $ trans &lt;chr&gt; &quot;Automatic 3-spd&quot;, &quot;Automatic 3-spd&quot;, &quot;Automatic 3-spd&quot;,... #&gt; $ drive &lt;chr&gt; &quot;2-Wheel Drive&quot;, &quot;2-Wheel Drive&quot;, &quot;2-Wheel Drive&quot;, &quot;2-Wh... #&gt; $ cyl &lt;int&gt; 4, 4, 6, 6, 4, 6, 6, 4, 4, 6, 4, 4, 6, 4, 4, 6, 5, 5, 6,... #&gt; $ displ &lt;dbl&gt; 2.5, 2.5, 4.2, 4.2, 2.5, 4.2, 3.8, 2.2, 2.2, 3.0, 2.3, 2... #&gt; $ fuel &lt;chr&gt; &quot;Regular&quot;, &quot;Regular&quot;, &quot;Regular&quot;, &quot;Regular&quot;, &quot;Regular&quot;, &quot;... #&gt; $ hwy &lt;int&gt; 17, 17, 13, 13, 17, 13, 21, 26, 28, 26, 27, 29, 26, 27, ... #&gt; $ cty &lt;int&gt; 18, 18, 13, 13, 16, 13, 14, 20, 22, 18, 19, 21, 17, 20, ... glimpse(fueleconomy::common) #&gt; Observations: 347 #&gt; Variables: 4 #&gt; $ make &lt;chr&gt; &quot;Acura&quot;, &quot;Acura&quot;, &quot;Acura&quot;, &quot;Acura&quot;, &quot;Acura&quot;, &quot;Audi&quot;, &quot;Au... #&gt; $ model &lt;chr&gt; &quot;Integra&quot;, &quot;Legend&quot;, &quot;MDX 4WD&quot;, &quot;NSX&quot;, &quot;TSX&quot;, &quot;A4&quot;, &quot;A4 ... #&gt; $ n &lt;int&gt; 42, 28, 12, 28, 27, 49, 49, 66, 20, 12, 46, 20, 30, 29, ... #&gt; $ years &lt;int&gt; 16, 10, 12, 14, 11, 19, 15, 19, 19, 12, 20, 15, 16, 16, ... fueleconomy::vehicles %&gt;% semi_join(fueleconomy::common, by = c(&quot;make&quot;, &quot;model&quot;)) #&gt; # A tibble: 14,531 × 12 #&gt; id make model year class trans #&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1833 Acura Integra 1986 Subcompact Cars Automatic 4-spd #&gt; 2 1834 Acura Integra 1986 Subcompact Cars Manual 5-spd #&gt; 3 3037 Acura Integra 1987 Subcompact Cars Automatic 4-spd #&gt; 4 3038 Acura Integra 1987 Subcompact Cars Manual 5-spd #&gt; 5 4183 Acura Integra 1988 Subcompact Cars Automatic 4-spd #&gt; 6 4184 Acura Integra 1988 Subcompact Cars Manual 5-spd #&gt; # ... with 1.452e+04 more rows, and 6 more variables: drive &lt;chr&gt;, #&gt; # cyl &lt;int&gt;, displ &lt;dbl&gt;, fuel &lt;chr&gt;, hwy &lt;int&gt;, cty &lt;int&gt; Find the 48 hours (over the course of the whole year) that have the worst delays. Cross-reference it with the weather data. Can you see any patterns? What does anti_join(flights, airports, by = c(&quot;dest&quot; = &quot;faa&quot;)) tell you? What does anti_join(airports, flights, by = c(&quot;faa&quot; = &quot;dest&quot;)) tell you? anti_join(flights, airports, by = c(&quot;dest&quot; = &quot;faa&quot;)) are flights that go to an airport that is not in FAA list of destinations, likely foreign airports. anti_join(airports, flights, by = c(&quot;faa&quot; = &quot;dest&quot;)) are US airports that don’t have a flight in the data, meaning that there were no flights to that aiport from New York in 2013. You might expect that there’s an implicit relationship between plane and airline, because each plane is flown by a single airline. Confirm or reject this hypothesis using the tools you’ve learned above. There isn’t such a relationship, since planes can be sold or airlines can merge. However, that doesn’t necessarily mean that such a plane will appear in this data. There are eight planes which flights %&gt;% group_by(tailnum, carrier) %&gt;% count() %&gt;% filter(n() &gt; 1) %&gt;% select(tailnum) %&gt;% distinct() #&gt; Source: local data frame [18 x 1] #&gt; Groups: tailnum [18] #&gt; #&gt; tailnum #&gt; &lt;chr&gt; #&gt; 1 N146PQ #&gt; 2 N153PQ #&gt; 3 N176PQ #&gt; 4 N181PQ #&gt; 5 N197PQ #&gt; 6 N200PQ #&gt; # ... with 12 more rows 9.6 Set operations No exercises "],
["strings.html", "10 Strings 10.1 Introduction 10.2 String Basics 10.3 Matching Patterns and Regular Expressions 10.4 Tools 10.5 Other types of patterns 10.6 stringi", " 10 Strings 10.1 Introduction Functions and packages coverered stringr package str_length str_c str_replace_na str_sub str_to_uppser, str_sort, str_to_lower, str_order str_length, str_pad, str_trim, str_sub For regex = str_view, str_view_all regex syntax str_detect str_subset str_count str_extract str_match tidyr::extract str_split str_locate str_sub the stringi package Ideas mention rex. A package with friendly regular expressions. Use it to match country names? Extract numbers from text? Discuss fuzzy joining and string distance, approximate matching. Also see Character encoding Stat 545. Jenny Bryan. Character data. Stat 545. Jenny Bryan. Regular expression in R. Stat 545. Jenny Bryan. library(tidyverse) library(stringr) 10.2 String Basics 10.2.1 Exercises In code that doesn’t use stringr, you’ll often see paste() and paste0(). What’s the difference between the two functions? What stringr function are they equivalent to? How do the functions differ in their handling of NA? The function paste seperates strings by spaces by default, while paste0 does not seperate strings with spaces by default. paste(&quot;foo&quot;, &quot;bar&quot;) #&gt; [1] &quot;foo bar&quot; paste0(&quot;foo&quot;, &quot;bar&quot;) #&gt; [1] &quot;foobar&quot; Since str_c does not seperate strings with spaces by default it is closer in behabior to paste0. str_c(&quot;foo&quot;, &quot;bar&quot;) #&gt; [1] &quot;foobar&quot; However, str_c and the paste ufnction handle NA differently. The function str_c propogates NA, if any argument is a missing value, it returns a missing value. This is in line with how the numeric R functions, e.g. sum, mean, handle missing values. However, the paste functions, convert NA to the string &quot;NA&quot; and then treat it as any other character vector. str_c(&quot;foo&quot;, NA) #&gt; [1] NA paste(&quot;foo&quot;, NA) #&gt; [1] &quot;foo NA&quot; paste0(&quot;foo&quot;, NA) #&gt; [1] &quot;fooNA&quot; In your own words, describe the difference between the sep and collapse arguments to str_c(). The sep argument is the string inserted between argugments to str_c, while collapse is the string used to separate any elements of the character vector into a character vector of length one. Use str_length() and str_sub() to extract the middle character from a string. What will you do if the string has an even number of characters? The following function extracts the middle character. If the string has an even number of characters the choice is arbitrary. We choose to select \\(\\lceil n / 2 \\rceil\\), because that case works even if the string is only of length one. A more general method would allow the user to select either the floor or ceiling for the middle character of an even string. x &lt;- c(&quot;a&quot;, &quot;abc&quot;, &quot;abcd&quot;, &quot;abcde&quot;, &quot;abcdef&quot;) L &lt;- str_length(x) m &lt;- ceiling(L / 2) str_sub(x, m, m) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;c&quot; &quot;c&quot; What does str_wrap() do? When might you want to use it? The function str_wrap wraps text so that it fits within a certain width. This is useful for wrapping long strings of text to be typeset. What does str_trim() do? What’s the opposite of str_trim()? The function str_trim trims the whitespace from a string. str_trim(&quot; abc &quot;) #&gt; [1] &quot;abc&quot; str_trim(&quot; abc &quot;, side = &quot;left&quot;) #&gt; [1] &quot;abc &quot; str_trim(&quot; abc &quot;, side = &quot;right&quot;) #&gt; [1] &quot; abc&quot; The opposite of str_trim is str_pad which adds characters to each side. str_pad(&quot;abc&quot;, 5, side = &quot;both&quot;) #&gt; [1] &quot; abc &quot; str_pad(&quot;abc&quot;, 4, side = &quot;right&quot;) #&gt; [1] &quot;abc &quot; str_pad(&quot;abc&quot;, 4, side = &quot;left&quot;) #&gt; [1] &quot; abc&quot; Write a function that turns (e.g.) a vector c(“a”, “b”, “c”) into the string a, b, and c. Think carefully about what it should do if given a vector of length 0, 1, or 2. Note: See Ch 19 for writing functions. str_commasep &lt;- function(x, sep = &quot;, &quot;, last = &quot;, and &quot;) { if (length(x) &gt; 1) { str_c(str_c(x[-length(x)], collapse = sep), x[length(x)], sep = last) } else { x } } str_commasep(&quot;&quot;) #&gt; [1] &quot;&quot; str_commasep(&quot;a&quot;) #&gt; [1] &quot;a&quot; str_commasep(c(&quot;a&quot;, &quot;b&quot;)) #&gt; [1] &quot;a, and b&quot; str_commasep(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) #&gt; [1] &quot;a, b, and c&quot; 10.3 Matching Patterns and Regular Expressions 10.3.1 Exercises Explain why each of these strings don’t match a \\: &quot;\\&quot;, &quot;\\\\&quot;, &quot;\\\\\\&quot;. &quot;\\&quot;: This will escape the next character in the R string. &quot;\\\\&quot;: This will resolve to \\ in the regular expression, which will escape the next character in the regular expression. &quot;\\\\\\&quot;: The first two backslashes will resolve to a literal backslash in the regular expression, the third will escape the next character. So in the regular expresion, this will escape some escaped character. How would you match the sequence &quot;'\\ ? What patterns will the regular expression \\..\\..\\.. match? How would you represent it as a string? It will match any patterns that are a dot followed by any character, repeated three times. 10.3.1.1 Exercises How would you match the literal string “\\(^\\)”? str_view(c(&quot;$^$&quot;, &quot;ab$^$sfas&quot;), &quot;^\\\\$\\\\^\\\\$$&quot;) Given the corpus of common words in stringr::words, create regular expressions that find all words that: Start with “y”. End with “x” Are exactly three letters long. (Don’t cheat by using str_length()!) Have seven letters or more. Since this list is long, you might want to use the match argument to str_view() to show only the matching or non-matching words. head(stringr::words) #&gt; [1] &quot;a&quot; &quot;able&quot; &quot;about&quot; &quot;absolute&quot; &quot;accept&quot; &quot;account&quot; A simpler way, shown later is 10.3.1.2 Character classes and alternatives 10.3.1.2.1 Exercises Create regular expressions to find all words that: Start with a vowel. That only contain consonants. (Hint: thinking about matching “not”-vowels.) End with ed, but not with eed. End with ing or ise. Words starting with vowels str_view(stringr::words, &quot;^[aeiou]&quot;) Words that contain only consonants str_view(stringr::words, &quot;^[^aeiou]+$&quot;, match=TRUE) This seems to require using the + pattern introduced later, unless one wants to be very verbose and specify words of certain lengths. Words that end with ed but not with eed. This handles the special case of “ed”, as well as words with length &gt; 2. str_view(stringr::words, &quot;^ed$|[^e]ed$&quot;, match = TRUE) Words ending in ing or ise: str_view(stringr::words, &quot;i(ng|se)$&quot;, match = TRUE) Empirically verify the rule “i before e except after c”. Using only what has been introduced thus far: str_view(stringr::words, &quot;(cei|[^c]ie)&quot;, match = TRUE) str_view(stringr::words, &quot;(cie|[^c]ei)&quot;, match = TRUE) Using str_detect: sum(str_detect(stringr::words, &quot;(cei|[^c]ie)&quot;)) #&gt; [1] 14 sum(str_detect(stringr::words, &quot;(cie|[^c]ei)&quot;)) #&gt; [1] 3 Is “q” always followed by a “u”? In the stringr::words dataset, yes. In the full English language, no. str_view(stringr::words, &quot;q[^u]&quot;, match = TRUE) Write a regular expression that matches a word if it’s probably written in British English, not American English. Ummm. In the general case, this is hard. But, there are a few heuristics to consider that can get part of the way there: British English uses “ou” instead of “o” use of “ae” and “oe” instead of “a” and “o” ends in ise instead of ize ending yse ou|ise^|ae|oe|yse^ There are others, but https://en.wikipedia.org/wiki/American_and_British_English_spelling_differences but this is not handled best by a regular expression. It would require a dictionary with differences in spellings for different words. And even then, a good algorithm would be statistical, inferring the probability that a text or word is using the British spelling rather than some deterministic algorithm. Create a regular expression that will match telephone numbers as commonly written in your country. Using what has been covered in R4DS thus far, x &lt;- c(&quot;123-456-7890&quot;, &quot;1235-2351&quot;) str_view(x, &quot;\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d\\\\d&quot;) Using stuff covered in the next section, str_view(x, &quot;\\\\d{3}-\\\\d{3}-\\\\d{4}&quot;) Note that this pattern doesn’t account for phone numbers that are invalid because of unassigned area code, or special numbers like 911, or for extensions. See https://en.wikipedia.org/wiki/North_American_Numbering_Plan for the complexities of US phone numbers, and http://stackoverflow.com/questions/123559/a-comprehensive-regex-for-phone-number-validation for one discussion of using a regex for phone number validation. 10.3.2 Repitition 10.3.2.1 Exercises Describe the equivalents of ?, +, * in {m,n} form. The equivalent of ? is {,1}, matching at most 1. The equivalent of + is {1,}, matching 1 or more. There is no direct equivalent of * in {m,n} form since there are no bounds on the matches: it can be 0 up to infinity matches. Describe in words what these regular expressions match: (read carefully to see if I’m using a regular expression or a string that defines a regular expression.) ^.*$: Any string &quot;\\\\{.+\\\\}&quot;: Any string with curly braces surrounding at least one character. \\d{4}-\\d{2}-\\d{2}: A date in “%Y-%m-%d” format: four digits followed by a dash, followed by two digits followed by a dash, followed by another two digits followed by a dash. &quot;\\\\\\\\{4}&quot;: This resolves to the regex \\\\{4}, which is four backslashes. Create regular expressions to find all words that: Start with three consonants. Have three or more vowels in a row. Have two or more vowel-consonant pairs in a row. A regex to find all words starting with three consonants str_view(words, &quot;^[^aeiou]{3}&quot;, match = TRUE) A regex to find three or more vowels in a row: str_view(words, &quot;[aeiou]{3,}&quot;, match = TRUE) Two or more vowel-consonant pairs in a row. str_view(words, &quot;([aeiou][^aeiou]){2,}&quot;, match = TRUE) Solve the beginner regexp crosswords at https://regexcrossword.com/challenges/beginner Nope 10.3.3 Grouping and backreferences str_view(fruit, &quot;(..)\\\\1&quot;, match = TRUE) 10.3.3.1 Exercises Describe, in words, what these expressions will match: (.)\\1\\1 : The same character apearing three times in a row. E.g. “aaa” &quot;(.)(.)\\\\2\\\\1&quot;: A pair of characters followed by the same pair of characters in reversed order. E.g. “abba”. (..)\\1: Any two characters repeated. E.g. “a1a1”. &quot;(.).\\\\1.\\\\1&quot;: A character followed by any character, the original character, any other character, the original character again. E.g. “abaca”, “b8b.b”. &quot;(.)(.)(.).*\\\\3\\\\2\\\\1&quot; Three characters followed by zero or more characters of any kind followed by the same three characters but in reverse order. E.g. “abcsgasgddsadgsdgcba” or “abccba” or “abc1cba”. Construct regular expressions to match words that: Start and end with the same character. Assuming the word is more than one character and all strings are considered words, ^(.).*\\1$ str_view(words, &quot;^(.).*\\\\1$&quot;, match = TRUE) 2 Contain a repeated pair of letters (e.g. “church” contains “ch” repeated twice.). # any two characters repeated str_view(words, &quot;(..).*\\\\1&quot;, match = TRUE) # more stringent, letters only, but also allowing for differences in capitalization str_view(str_to_lower(words), &quot;([a-z][a-z]).*\\\\1&quot;, match = TRUE) Contain one letter repeated in at least three places (e.g. “eleven” contains three “e”s.) str_view(words, &quot;(.).*\\\\1.*\\\\1&quot;, match = TRUE) 10.4 Tools 10.4.1 Detect matches x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_detect(x, &quot;e&quot;) #&gt; [1] TRUE FALSE TRUE Number of words starting with t? sum(str_detect(words, &quot;^t&quot;)) #&gt; [1] 65 Proportion of words ending with a vowel? mean(str_detect(words, &quot;[aeiou]$&quot;)) #&gt; [1] 0.277 To find all words with no vowels no_vowels_1 &lt;- !str_detect(words, &quot;[aeiou]&quot;) no_vowels_2 &lt;- str_detect(words, &quot;^[^aeiou]+$&quot;) identical(no_vowels_1, no_vowels_2) #&gt; [1] TRUE words[str_detect(words, &quot;x$&quot;)] #&gt; [1] &quot;box&quot; &quot;sex&quot; &quot;six&quot; &quot;tax&quot; str_subset(words, &quot;x$&quot;) #&gt; [1] &quot;box&quot; &quot;sex&quot; &quot;six&quot; &quot;tax&quot; df &lt;- tibble( word = words, i = seq_along(word) ) df %&gt;% filter(str_detect(words, &quot;x$&quot;)) #&gt; # A tibble: 4 × 2 #&gt; word i #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 box 108 #&gt; 2 sex 747 #&gt; 3 six 772 #&gt; 4 tax 841 Number of matches in each string x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_count(x, &quot;a&quot;) #&gt; [1] 1 3 1 Average vowels per word mean(str_count(words, &quot;[aeiou]&quot;)) #&gt; [1] 1.99 df %&gt;% mutate( vowels = str_count(word, &quot;[aeiou]&quot;), consonants = str_count(word, &quot;[^aeiou]&quot;) ) #&gt; # A tibble: 980 × 4 #&gt; word i vowels consonants #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 a 1 1 0 #&gt; 2 able 2 2 2 #&gt; 3 about 3 3 2 #&gt; 4 absolute 4 4 4 #&gt; 5 accept 5 2 4 #&gt; 6 account 6 3 4 #&gt; # ... with 974 more rows matches do not overlap - they are usually greedy, except when otherwise noted. matches only match the first one. _all() functions will get all matches. 10.4.2 Exercises For each of the following challenges, try solving it by using both a single regular expression, and a combination of multiple str_detect() calls. Find all words that start or end with x. Find all words that start with a vowel and end with a consonant. Are there any words that contain at least one of each different vowel? Words that start or end with x? # one regex words[str_detect(words, &quot;^x|x$&quot;)] #&gt; [1] &quot;box&quot; &quot;sex&quot; &quot;six&quot; &quot;tax&quot; # split regex into parts start_with_x &lt;- str_detect(words, &quot;^x&quot;) end_with_x &lt;- str_detect(words, &quot;x$&quot;) words[start_with_x | end_with_x] #&gt; [1] &quot;box&quot; &quot;sex&quot; &quot;six&quot; &quot;tax&quot; Find all words starting with vowel and ending with consonant. str_subset(words, &quot;^[aeiou].*[^aeiou]$&quot;) %&gt;% head() #&gt; [1] &quot;about&quot; &quot;accept&quot; &quot;account&quot; &quot;across&quot; &quot;act&quot; &quot;actual&quot; start_with_vowel &lt;- str_detect(words, &quot;^[aeiou]&quot;) end_with_consonant &lt;- str_detect(words, &quot;[^aeiou]$&quot;) words[start_with_vowel &amp; end_with_consonant] %&gt;% head() #&gt; [1] &quot;about&quot; &quot;accept&quot; &quot;account&quot; &quot;across&quot; &quot;act&quot; &quot;actual&quot; Words that contain at least one of each vowel. I can’t think of a good way of doing this without doing a regex of the permutations: pattern &lt;- cross_n(rerun(5, c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;)), .filter = function(...) { x &lt;- as.character(unlist(list(...))) length(x) != length(unique(x)) }) %&gt;% map_chr(~ str_c(unlist(.x), collapse = &quot;.*&quot;)) %&gt;% str_c(collapse = &quot;|&quot;) str_subset(words, pattern) #&gt; character(0) words[str_detect(words, &quot;a&quot;) &amp; str_detect(words, &quot;e&quot;) &amp; str_detect(words, &quot;i&quot;) &amp; str_detect(words, &quot;o&quot;) &amp; str_detect(words, &quot;u&quot;)] #&gt; character(0) There appear to be none. To check that it works, str_subset(&quot;aseiouds&quot;, pattern) #&gt; [1] &quot;aseiouds&quot; What word has the highest number of vowels? What word has the highest proportion of vowels? (Hint: what is the denominator?) prop_vowels &lt;- str_count(words, &quot;[aeiou]&quot;) / str_length(words) words[which(prop_vowels == max(prop_vowels))] #&gt; [1] &quot;a&quot; 10.4.3 Extract Matches The Harvard sentences: length(sentences) #&gt; [1] 720 head(sentences) #&gt; [1] &quot;The birch canoe slid on the smooth planks.&quot; #&gt; [2] &quot;Glue the sheet to the dark blue background.&quot; #&gt; [3] &quot;It&#39;s easy to tell the depth of a well.&quot; #&gt; [4] &quot;These days a chicken leg is a rare dish.&quot; #&gt; [5] &quot;Rice is often served in round bowls.&quot; #&gt; [6] &quot;The juice of lemons makes fine punch.&quot; colours &lt;- c(&quot;red&quot;, &quot;orange&quot;, &quot;yellow&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;purple&quot;) colour_match &lt;- str_c(colours, collapse = &quot;|&quot;) colour_match #&gt; [1] &quot;red|orange|yellow|green|blue|purple&quot; has_colour &lt;- str_subset(sentences, colour_match) matches &lt;- str_extract(has_colour, colour_match) head(matches) #&gt; [1] &quot;blue&quot; &quot;blue&quot; &quot;red&quot; &quot;red&quot; &quot;red&quot; &quot;blue&quot; more &lt;- sentences[str_count(sentences, colour_match) &gt; 1] str_view_all(more, colour_match) str_extract(more, colour_match) #&gt; [1] &quot;blue&quot; &quot;green&quot; &quot;orange&quot; The _all versions of functions return lists. str_extract_all(more, colour_match) #&gt; [[1]] #&gt; [1] &quot;blue&quot; &quot;red&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;green&quot; &quot;red&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;orange&quot; &quot;red&quot; str_extract_all(more, colour_match, simplify = TRUE) #&gt; [,1] [,2] #&gt; [1,] &quot;blue&quot; &quot;red&quot; #&gt; [2,] &quot;green&quot; &quot;red&quot; #&gt; [3,] &quot;orange&quot; &quot;red&quot; x &lt;- c(&quot;a&quot;, &quot;a b&quot;, &quot;a b c&quot;) str_extract_all(x, &quot;[a-z]&quot;, simplify = TRUE) #&gt; [,1] [,2] [,3] #&gt; [1,] &quot;a&quot; &quot;&quot; &quot;&quot; #&gt; [2,] &quot;a&quot; &quot;b&quot; &quot;&quot; #&gt; [3,] &quot;a&quot; &quot;b&quot; &quot;c&quot; 10.4.3.1 Exercises In the previous example, you might have noticed that the regular expression matched “flickered”, which is not a colour. Modify the regex to fix the problem. Add the \\b before and after the pattern colour_match2 &lt;- str_c(&quot;\\\\b(&quot;, str_c(colours, collapse = &quot;|&quot;), &quot;)\\\\b&quot;) colour_match2 #&gt; [1] &quot;\\\\b(red|orange|yellow|green|blue|purple)\\\\b&quot; more2 &lt;- sentences[str_count(sentences, colour_match) &gt; 1] str_view_all(more2, colour_match2, match = TRUE) From the Harvard sentences data, extract: The first word from each sentence. All words ending in ing. All plurals. The first word in each sentence requires defining what a word is. I’ll consider a word any contiguous str_extract(sentences, &quot;[a-zA-X]+&quot;) %&gt;% head() #&gt; [1] &quot;The&quot; &quot;Glue&quot; &quot;It&quot; &quot;These&quot; &quot;Rice&quot; &quot;The&quot; All words ending in ing: pattern &lt;- &quot;\\\\b[A-Za-z]+ing\\\\b&quot; sentences_with_ing &lt;- str_detect(sentences, pattern) unique(unlist(str_extract_all(sentences[sentences_with_ing], pattern))) %&gt;% head() #&gt; [1] &quot;spring&quot; &quot;evening&quot; &quot;morning&quot; &quot;winding&quot; &quot;living&quot; &quot;king&quot; All plurals. To do this correct requires linguistic information. But if we just want to say any word ending in an “s” is plural (and with more than 3 characters to remove as, is, gas, etc.) unique(unlist(str_extract_all(sentences, &quot;\\\\b[A-Za-z]{3,}s\\\\b&quot;))) %&gt;% head() #&gt; [1] &quot;planks&quot; &quot;days&quot; &quot;bowls&quot; &quot;lemons&quot; &quot;makes&quot; &quot;hogs&quot; 10.4.4 Grouped Matches noun &lt;- &quot;(a|the) ([^ ]+)&quot; has_noun &lt;- sentences %&gt;% str_subset(noun) %&gt;% head(10) has_noun %&gt;% str_extract(noun) #&gt; [1] &quot;the smooth&quot; &quot;the sheet&quot; &quot;the depth&quot; &quot;a chicken&quot; &quot;the parked&quot; #&gt; [6] &quot;the sun&quot; &quot;the huge&quot; &quot;the ball&quot; &quot;the woman&quot; &quot;a helps&quot; has_noun %&gt;% str_match(noun) #&gt; [,1] [,2] [,3] #&gt; [1,] &quot;the smooth&quot; &quot;the&quot; &quot;smooth&quot; #&gt; [2,] &quot;the sheet&quot; &quot;the&quot; &quot;sheet&quot; #&gt; [3,] &quot;the depth&quot; &quot;the&quot; &quot;depth&quot; #&gt; [4,] &quot;a chicken&quot; &quot;a&quot; &quot;chicken&quot; #&gt; [5,] &quot;the parked&quot; &quot;the&quot; &quot;parked&quot; #&gt; [6,] &quot;the sun&quot; &quot;the&quot; &quot;sun&quot; #&gt; [7,] &quot;the huge&quot; &quot;the&quot; &quot;huge&quot; #&gt; [8,] &quot;the ball&quot; &quot;the&quot; &quot;ball&quot; #&gt; [9,] &quot;the woman&quot; &quot;the&quot; &quot;woman&quot; #&gt; [10,] &quot;a helps&quot; &quot;a&quot; &quot;helps&quot; tibble(sentence = sentences) %&gt;% tidyr::extract( sentence, c(&quot;article&quot;, &quot;noun&quot;), &quot;(a|the) ([^ ]+)&quot;, remove = FALSE ) #&gt; # A tibble: 720 × 3 #&gt; sentence article noun #&gt; * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 The birch canoe slid on the smooth planks. the smooth #&gt; 2 Glue the sheet to the dark blue background. the sheet #&gt; 3 It&#39;s easy to tell the depth of a well. the depth #&gt; 4 These days a chicken leg is a rare dish. a chicken #&gt; 5 Rice is often served in round bowls. &lt;NA&gt; &lt;NA&gt; #&gt; 6 The juice of lemons makes fine punch. &lt;NA&gt; &lt;NA&gt; #&gt; # ... with 714 more rows 10.4.4.1 Exercises Find all words that come after a “number” like “one”, “two”, “three” etc. Pull out both the number and the word. I’ll use the same following “word” pattern as used above numword &lt;- &quot;(one|two|three|four|five|six|seven|eight|nine|ten) +(\\\\S+)&quot; sentences[str_detect(sentences, numword)] %&gt;% str_extract(numword) #&gt; [1] &quot;ten served&quot; &quot;one over&quot; &quot;seven books&quot; &quot;two met&quot; #&gt; [5] &quot;two factors&quot; &quot;one and&quot; &quot;three lists&quot; &quot;seven is&quot; #&gt; [9] &quot;two when&quot; &quot;one floor.&quot; &quot;ten inches.&quot; &quot;one with&quot; #&gt; [13] &quot;one war&quot; &quot;one button&quot; &quot;six minutes.&quot; &quot;ten years&quot; #&gt; [17] &quot;one in&quot; &quot;ten chased&quot; &quot;one like&quot; &quot;two shares&quot; #&gt; [21] &quot;two distinct&quot; &quot;one costs&quot; &quot;ten two&quot; &quot;five robins.&quot; #&gt; [25] &quot;four kinds&quot; &quot;one rang&quot; &quot;ten him.&quot; &quot;three story&quot; #&gt; [29] &quot;ten by&quot; &quot;one wall.&quot; &quot;three inches&quot; &quot;ten your&quot; #&gt; [33] &quot;six comes&quot; &quot;one before&quot; &quot;three batches&quot; &quot;two leaves.&quot; Find all contractions. Separate out the pieces before and after the apostrophe. contraction &lt;- &quot;([A-Za-z]+)&#39;([A-Za-z]+)&quot; sentences %&gt;% `[`(str_detect(sentences, contraction)) %&gt;% str_extract(contraction) #&gt; [1] &quot;It&#39;s&quot; &quot;man&#39;s&quot; &quot;don&#39;t&quot; &quot;store&#39;s&quot; &quot;workmen&#39;s&quot; #&gt; [6] &quot;Let&#39;s&quot; &quot;sun&#39;s&quot; &quot;child&#39;s&quot; &quot;king&#39;s&quot; &quot;It&#39;s&quot; #&gt; [11] &quot;don&#39;t&quot; &quot;queen&#39;s&quot; &quot;don&#39;t&quot; &quot;pirate&#39;s&quot; &quot;neighbor&#39;s&quot; 10.4.5 Splitting 10.4.5.1 Exercises Split up a string like &quot;apples, pears, and bananas&quot; into individual components. x &lt;- c(&quot;apples, pears, and bananas&quot;) str_split(x, &quot;, +(and +)?&quot;)[[1]] #&gt; [1] &quot;apples&quot; &quot;pears&quot; &quot;bananas&quot; Why is it better to split up by boundary(&quot;word&quot;) than &quot; &quot;? Splitting by boundary(&quot;word&quot;) splits on punctuation and not just whitespace. What does splitting with an empty string (&quot;&quot;) do? Experiment, and then read the documentation. str_split(&quot;ab. cd|agt&quot;, &quot;&quot;)[[1]] #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;.&quot; &quot; &quot; &quot;c&quot; &quot;d&quot; &quot;|&quot; &quot;a&quot; &quot;g&quot; &quot;t&quot; It splits the string into individual characters. 10.5 Other types of patterns 10.5.1 Exercises How would you find all strings containing \\ with regex() vs. with fixed()? str_subset(c(&quot;a\\\\b&quot;, &quot;ab&quot;), &quot;\\\\\\\\&quot;) #&gt; [1] &quot;a\\\\b&quot; str_subset(c(&quot;a\\\\b&quot;, &quot;ab&quot;), fixed(&quot;\\\\&quot;)) #&gt; [1] &quot;a\\\\b&quot; What are the five most common words in sentences? str_extract_all(sentences, boundary(&quot;word&quot;)) %&gt;% unlist() %&gt;% str_to_lower() %&gt;% tibble() %&gt;% set_names(&quot;word&quot;) %&gt;% group_by(word) %&gt;% count(sort = TRUE) %&gt;% head(5) #&gt; # A tibble: 5 × 2 #&gt; word n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 the 751 #&gt; 2 a 202 #&gt; 3 of 132 #&gt; 4 to 123 #&gt; 5 and 118 10.6 stringi 10.6.1 Exercises Find the stringi functions that: Count the number of words. stri_count_words Find duplicated strings. stri_duplicated Generate random text. There are several functions beginning with stri_rand_. stri_rand_lipsum generates lorem ipsum text, stri_rand_strings generates random strings, stri_rand_shuffle randomly shuffles the code points in the text. How do you control the language that stri_sort() uses for sorting? Use the locale argument to the opts_collator argument. "],
["factors.html", "11 Factors 11.1 Introduction 11.2 Creating Factors 11.3 General Social Survey 11.4 Modifying factor order 11.5 Modifying factor levels", " 11 Factors 11.1 Introduction Functions and packages: forcats factor fct_inorder levels readr::parse_factor fct_reorder fct_relevel fct_reorder2 fct_infreq fct_rev fct_recode fct_lump fct_collapse Also see the Be the boss of your factors Stat 545. Jenny Bryan. library(&quot;tidyverse&quot;) library(&quot;forcats&quot;) 11.2 Creating Factors No exercises 11.3 General Social Survey 11.3.1 Exercises Explore the distribution of rincome (reported income). What makes the default bar chart hard to understand? How could you improve the plot? rincome_plot &lt;- gss_cat %&gt;% ggplot(aes(rincome)) + geom_bar() rincome_plot The default bar chart labels are too squished to read. One solution is to change the angle of the labels, rincome_plot + theme(axis.text.x = element_text(angle = 90)) But that’s not natural either, because text is vertical, and we read horizontally. So with long labels, it is better to flip it. rincome_plot + coord_flip() This is better, but it unituively goes from low to high. It would help if the scale is reversed. Also, if all the missing factors were differentiated. What is the most common relig in this survey? What’s the most common partyid? The most common relig is “Protestant” gss_cat %&gt;% count(relig) %&gt;% arrange(-n) %&gt;% head(1) #&gt; # A tibble: 1 × 2 #&gt; relig n #&gt; &lt;fctr&gt; &lt;int&gt; #&gt; 1 Protestant 10846 The most common partyid is “Independent” gss_cat %&gt;% count(partyid) %&gt;% arrange(-n) %&gt;% head(1) #&gt; # A tibble: 1 × 2 #&gt; partyid n #&gt; &lt;fctr&gt; &lt;int&gt; #&gt; 1 Independent 4119 Which relig does denom (denomination) apply to? How can you find out with a table? How can you find out with a visualisation? levels(gss_cat$denom) #&gt; [1] &quot;No answer&quot; &quot;Don&#39;t know&quot; &quot;No denomination&quot; #&gt; [4] &quot;Other&quot; &quot;Episcopal&quot; &quot;Presbyterian-dk wh&quot; #&gt; [7] &quot;Presbyterian, merged&quot; &quot;Other presbyterian&quot; &quot;United pres ch in us&quot; #&gt; [10] &quot;Presbyterian c in us&quot; &quot;Lutheran-dk which&quot; &quot;Evangelical luth&quot; #&gt; [13] &quot;Other lutheran&quot; &quot;Wi evan luth synod&quot; &quot;Lutheran-mo synod&quot; #&gt; [16] &quot;Luth ch in america&quot; &quot;Am lutheran&quot; &quot;Methodist-dk which&quot; #&gt; [19] &quot;Other methodist&quot; &quot;United methodist&quot; &quot;Afr meth ep zion&quot; #&gt; [22] &quot;Afr meth episcopal&quot; &quot;Baptist-dk which&quot; &quot;Other baptists&quot; #&gt; [25] &quot;Southern baptist&quot; &quot;Nat bapt conv usa&quot; &quot;Nat bapt conv of am&quot; #&gt; [28] &quot;Am bapt ch in usa&quot; &quot;Am baptist asso&quot; &quot;Not applicable&quot; From the context it is clear that denom refers to “Protestant” (and unsurprising given that it is the largest category in freq). Let’s filter out the non-responses, no answers, others, not-applicable, or no denomination, to leave only answers to denominations. After doing that, the only remaining responses are “Protestant”. gss_cat %&gt;% filter(!denom %in% c(&quot;No answer&quot;, &quot;Other&quot;, &quot;Don&#39;t know&quot;, &quot;Not applicable&quot;, &quot;No denomination&quot;)) %&gt;% count(relig) #&gt; # A tibble: 1 × 2 #&gt; relig n #&gt; &lt;fctr&gt; &lt;int&gt; #&gt; 1 Protestant 7025 This is also clear in a scatter plot of relig vs. denom where the points are proportional to the size of the number of answers (since otherwise there would be overplotting). gss_cat %&gt;% count(relig, denom) %&gt;% ggplot(aes(x = relig, y = denom, size = n)) + geom_point() + theme(axis.text.x = element_text(angle = 90)) 11.4 Modifying factor order 11.4.1 Exercises There are some suspiciously high numbers in tvhours. Is the mean a good summary? summary(gss_cat[[&quot;tvhours&quot;]]) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s #&gt; 0 1 2 3 4 24 10146 gss_cat %&gt;% filter(!is.na(tvhours)) %&gt;% ggplot(aes(x = tvhours)) + geom_histogram(binwidth = 1) Whether the mean is the best summary epends on what you are using it for :-), i.e. your objective. But probably the median would be what most people prefer. And the hours of tv doesn’t look that surprising to me. For each factor in gss_cat identify whether the order of the levels is arbitrary or principled. The following piece of code uses functions covered in Ch 21, to print out the names of only the factors. keep(gss_cat, is.factor) %&gt;% names() #&gt; [1] &quot;marital&quot; &quot;race&quot; &quot;rincome&quot; &quot;partyid&quot; &quot;relig&quot; &quot;denom&quot; There are five six categorical variables: marital, race, rincome, partyid, relig, denom. The ordering of marital is “somewhat principled”. There is some sort of logic in that the levels are grouped “never married”, married at some point (separated, divorced, widowed), and “married”; though it would seem that “Never Married”, “Divorced”, “Widowed”, “Separated”, “Married” might be more natural. I find that the question of ordering can be determined by the level of aggregation in a categorical variable, and there can be more “partially ordered” factors than one would expect. levels(gss_cat[[&quot;marital&quot;]]) #&gt; [1] &quot;No answer&quot; &quot;Never married&quot; &quot;Separated&quot; &quot;Divorced&quot; #&gt; [5] &quot;Widowed&quot; &quot;Married&quot; gss_cat %&gt;% ggplot(aes(x = marital)) + geom_bar() The ordering of race is principled in that the categories are ordered by count of observations in the data. levels(gss_cat$race) #&gt; [1] &quot;Other&quot; &quot;Black&quot; &quot;White&quot; &quot;Not applicable&quot; gss_cat %&gt;% ggplot(aes(race)) + geom_bar(drop = FALSE) #&gt; Warning: Ignoring unknown parameters: drop The levels of rincome are ordered in decreasing order of the income; however the placement of “No answer”, “Don’t know”, and “Refused” before, and “Not applicable” after the income levels is arbitrary. It would be better to place all the missing income level categories either before or after all the known values. levels(gss_cat$rincome) #&gt; [1] &quot;No answer&quot; &quot;Don&#39;t know&quot; &quot;Refused&quot; &quot;$25000 or more&quot; #&gt; [5] &quot;$20000 - 24999&quot; &quot;$15000 - 19999&quot; &quot;$10000 - 14999&quot; &quot;$8000 to 9999&quot; #&gt; [9] &quot;$7000 to 7999&quot; &quot;$6000 to 6999&quot; &quot;$5000 to 5999&quot; &quot;$4000 to 4999&quot; #&gt; [13] &quot;$3000 to 3999&quot; &quot;$1000 to 2999&quot; &quot;Lt $1000&quot; &quot;Not applicable&quot; The levels of relig is arbitrary: there is no natural ordering, and they don’t appear to be ordered by stats within the dataset. levels(gss_cat$relig) #&gt; [1] &quot;No answer&quot; &quot;Don&#39;t know&quot; #&gt; [3] &quot;Inter-nondenominational&quot; &quot;Native american&quot; #&gt; [5] &quot;Christian&quot; &quot;Orthodox-christian&quot; #&gt; [7] &quot;Moslem/islam&quot; &quot;Other eastern&quot; #&gt; [9] &quot;Hinduism&quot; &quot;Buddhism&quot; #&gt; [11] &quot;Other&quot; &quot;None&quot; #&gt; [13] &quot;Jewish&quot; &quot;Catholic&quot; #&gt; [15] &quot;Protestant&quot; &quot;Not applicable&quot; gss_cat %&gt;% ggplot(aes(relig)) + geom_bar() + coord_flip() The same goes for denom. levels(gss_cat$denom) #&gt; [1] &quot;No answer&quot; &quot;Don&#39;t know&quot; &quot;No denomination&quot; #&gt; [4] &quot;Other&quot; &quot;Episcopal&quot; &quot;Presbyterian-dk wh&quot; #&gt; [7] &quot;Presbyterian, merged&quot; &quot;Other presbyterian&quot; &quot;United pres ch in us&quot; #&gt; [10] &quot;Presbyterian c in us&quot; &quot;Lutheran-dk which&quot; &quot;Evangelical luth&quot; #&gt; [13] &quot;Other lutheran&quot; &quot;Wi evan luth synod&quot; &quot;Lutheran-mo synod&quot; #&gt; [16] &quot;Luth ch in america&quot; &quot;Am lutheran&quot; &quot;Methodist-dk which&quot; #&gt; [19] &quot;Other methodist&quot; &quot;United methodist&quot; &quot;Afr meth ep zion&quot; #&gt; [22] &quot;Afr meth episcopal&quot; &quot;Baptist-dk which&quot; &quot;Other baptists&quot; #&gt; [25] &quot;Southern baptist&quot; &quot;Nat bapt conv usa&quot; &quot;Nat bapt conv of am&quot; #&gt; [28] &quot;Am bapt ch in usa&quot; &quot;Am baptist asso&quot; &quot;Not applicable&quot; Ignoring “No answer”, “Don’t know”, and “Other party”, the levels of partyid are ordered from “Strong Republican”&quot; to “Strong Democrat”. levels(gss_cat$partyid) #&gt; [1] &quot;No answer&quot; &quot;Don&#39;t know&quot; &quot;Other party&quot; #&gt; [4] &quot;Strong republican&quot; &quot;Not str republican&quot; &quot;Ind,near rep&quot; #&gt; [7] &quot;Independent&quot; &quot;Ind,near dem&quot; &quot;Not str democrat&quot; #&gt; [10] &quot;Strong democrat&quot; Why did moving “Not applicable” to the front of the levels move it to the bottom of the plot? Because that gives the level “Not applicable” an integer value of 1. 11.5 Modifying factor levels 11.5.1 Exercises How have the proportions of people identifying as Democrat, Republican, and Independent changed over time? To answer that, we need to combine the multiple levels into Democrat, Republican, and Independent levels(gss_cat$partyid) #&gt; [1] &quot;No answer&quot; &quot;Don&#39;t know&quot; &quot;Other party&quot; #&gt; [4] &quot;Strong republican&quot; &quot;Not str republican&quot; &quot;Ind,near rep&quot; #&gt; [7] &quot;Independent&quot; &quot;Ind,near dem&quot; &quot;Not str democrat&quot; #&gt; [10] &quot;Strong democrat&quot; gss_cat %&gt;% mutate(partyid = fct_collapse(partyid, other = c(&quot;No answer&quot;, &quot;Don&#39;t know&quot;, &quot;Other party&quot;), rep = c(&quot;Strong republican&quot;, &quot;Not str republican&quot;), ind = c(&quot;Ind,near rep&quot;, &quot;Independent&quot;, &quot;Ind,near dem&quot;), dem = c(&quot;Not str democrat&quot;, &quot;Strong democrat&quot;))) %&gt;% count(year, partyid) %&gt;% group_by(year) %&gt;% mutate(p = n / sum(n)) %&gt;% ggplot(aes(x = year, y = p, colour = fct_reorder2(partyid, year, p))) + geom_point() + geom_line() + labs(colour = &quot;Party ID.&quot;) How could you collapse rincome into a small set of categories? Group all the non-responses into one category, and then group other categories into a smaller number. Since there is a clear ordering, we wouldn’t want to use something like fct_lump. levels(gss_cat$rincome) #&gt; [1] &quot;No answer&quot; &quot;Don&#39;t know&quot; &quot;Refused&quot; &quot;$25000 or more&quot; #&gt; [5] &quot;$20000 - 24999&quot; &quot;$15000 - 19999&quot; &quot;$10000 - 14999&quot; &quot;$8000 to 9999&quot; #&gt; [9] &quot;$7000 to 7999&quot; &quot;$6000 to 6999&quot; &quot;$5000 to 5999&quot; &quot;$4000 to 4999&quot; #&gt; [13] &quot;$3000 to 3999&quot; &quot;$1000 to 2999&quot; &quot;Lt $1000&quot; &quot;Not applicable&quot; library(&quot;stringr&quot;) gss_cat %&gt;% mutate(rincome = fct_collapse( rincome, `Unknown` = c(&quot;No answer&quot;, &quot;Don&#39;t know&quot;, &quot;Refused&quot;, &quot;Not applicable&quot;), `Lt $5000` = c(&quot;Lt $1000&quot;, str_c(&quot;$&quot;, c(&quot;1000&quot;, &quot;3000&quot;, &quot;4000&quot;), &quot; to &quot;, c(&quot;2999&quot;, &quot;3999&quot;, &quot;4999&quot;))), `$5000 to 10000` = str_c(&quot;$&quot;, c(&quot;5000&quot;, &quot;6000&quot;, &quot;7000&quot;, &quot;8000&quot;), &quot; to &quot;, c(&quot;5999&quot;, &quot;6999&quot;, &quot;7999&quot;, &quot;9999&quot;)) )) %&gt;% ggplot(aes(x = rincome)) + geom_bar() + coord_flip() "],
["dates-and-times.html", "12 Dates and Times 12.1 Prerequisite 12.2 Creating date/times 12.3 Date-Time Components 12.4 Time Spans", " 12 Dates and Times lubridate today, now ymd etc., ymd_hms etc. make_datetime, make_date as_datetime, as_date year, month, mday, yday, wday and year&lt;- floor_date, round_date, ceiling_date update as.duration, duration functions (ddays, etc) period functions (days, months, etc) interval creation with %--% with_tz, force_tz hms package has times Ideas for applications: CDB90 data, COW war start end and duration Read more on time-zones: https://en.wikipedia.org/wiki/Time_zone Computerphile The Problem with Time &amp; Timezones - Computerphile The history of the tz database are themselves interesting: https://en.wikipedia.org/wiki/Tz_database A literary appreciation of the Olson/Zoneinfo/tz database I think time-zones are likely a point for social science research in and of themselves. Policy choices. Coordination. Regression discontinuity designs. Just sayin… 12.1 Prerequisite library(tidyverse) library(lubridate) library(nycflights13) 12.2 Creating date/times NOTE %/% is integer division, divide and throw away the remainder. %% calculates the modulus (remainder of division). For example to test for an even number: x %% 2 == 0, or odd x %% 2 == 1. To get the thousands value of a number x %/% 1000. make_datetime_100 &lt;- function(year, month, day, time) { make_datetime(year, month, day, time %/% 100, time %% 100) } flights_dt &lt;- flights %&gt;% filter(!is.na(dep_time), !is.na(arr_time)) %&gt;% mutate( dep_time = make_datetime_100(year, month, day, dep_time), arr_time = make_datetime_100(year, month, day, arr_time), sched_dep_time = make_datetime_100(year, month, day, sched_dep_time), sched_arr_time = make_datetime_100(year, month, day, sched_arr_time) ) %&gt;% select(origin, dest, ends_with(&quot;delay&quot;), ends_with(&quot;time&quot;)) flights_dt %&gt;% head #&gt; # A tibble: 6 × 9 #&gt; origin dest dep_delay arr_delay dep_time sched_dep_time #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;dttm&gt; #&gt; 1 EWR IAH 2 11 2013-01-01 05:17:00 2013-01-01 05:15:00 #&gt; 2 LGA IAH 4 20 2013-01-01 05:33:00 2013-01-01 05:29:00 #&gt; 3 JFK MIA 2 33 2013-01-01 05:42:00 2013-01-01 05:40:00 #&gt; 4 JFK BQN -1 -18 2013-01-01 05:44:00 2013-01-01 05:45:00 #&gt; 5 LGA ATL -6 -25 2013-01-01 05:54:00 2013-01-01 06:00:00 #&gt; 6 EWR ORD -4 12 2013-01-01 05:54:00 2013-01-01 05:58:00 #&gt; # ... with 3 more variables: arr_time &lt;dttm&gt;, sched_arr_time &lt;dttm&gt;, #&gt; # air_time &lt;dbl&gt; Times are often stored as integers since a reference time, called an epoch. The most epoch is the UNIX (or POSIX) Epoch of January 1st, 1970 00:00:00. So, interally, times are stored as the number of days, seconds, or milliseconds, etc. since the 1970-01-01 00:00:00.000. Calculate dates and datetimes from number of seconds (as_datetime) or days (as_date) from Unix epoch. as_datetime(60 * 60 * 10) #&gt; [1] &quot;1970-01-01 10:00:00 UTC&quot; as_date(365 * 10 + 2) #&gt; [1] &quot;1980-01-01&quot; 12.2.1 Exercises What happens if you parse a string that contains invalid dates? ret &lt;- ymd(c(&quot;2010-10-10&quot;, &quot;bananas&quot;)) #&gt; Warning: 1 failed to parse. print(class(ret)) #&gt; [1] &quot;Date&quot; ret #&gt; [1] &quot;2010-10-10&quot; NA It produces an NA and an warning message. What does the tzone argument to today() do? Why is it important? It determines the time-zone of the date. Since different time-zones can have different dates, the value of today() can vary depending on the time-zone specified. Use the appropriate lubridate function to parse each of the following dates: d1 &lt;- &quot;January 1, 2010&quot; mdy(d1) #&gt; [1] &quot;2010-01-01&quot; d2 &lt;- &quot;2015-Mar-07&quot; ymd(d2) #&gt; [1] &quot;2015-03-07&quot; d3 &lt;- &quot;06-Jun-2017&quot; dmy(d3) #&gt; [1] &quot;2017-06-06&quot; d4 &lt;- c(&quot;August 19 (2015)&quot;, &quot;July 1 (2015)&quot;) mdy(d4) #&gt; [1] &quot;2015-08-19&quot; &quot;2015-07-01&quot; d5 &lt;- &quot;12/30/14&quot; # Dec 30, 2014 mdy(d5) #&gt; [1] &quot;2014-12-30&quot; 12.3 Date-Time Components sched_dep &lt;- flights_dt %&gt;% mutate(minute = minute(sched_dep_time)) %&gt;% group_by(minute) %&gt;% summarise( avg_delay = mean(arr_delay, na.rm = TRUE), n = n()) Note The difference between rounded and unrounded dates provides the within period time. (datetime &lt;- ymd_hms(&quot;2016-07-08 12:34:56&quot;)) #&gt; [1] &quot;2016-07-08 12:34:56 UTC&quot; year(datetime) &lt;- 2020 datetime #&gt; [1] &quot;2020-07-08 12:34:56 UTC&quot; month(datetime) &lt;- 01 datetime #&gt; [1] &quot;2020-01-08 12:34:56 UTC&quot; hour(datetime) &lt;- hour(datetime) + 1 datetime #&gt; [1] &quot;2020-01-08 13:34:56 UTC&quot; 12.3.1 Exercises How does the distribution of flight times within a day change over the course of the year? Let’s try plotting this by month: flights_dt %&gt;% mutate(time = hour(dep_time) * 100 + minute(dep_time), mon = as.factor(month (dep_time))) %&gt;% ggplot(aes(x = time, group = mon, color = mon)) + geom_freqpoly(binwidth = 100) This will look better if everything is normalized within groups. The reason that February is lower is that there are fewer days and thus fewer flights. flights_dt %&gt;% mutate(time = hour(dep_time) * 100 + minute(dep_time), mon = as.factor(month (dep_time))) %&gt;% ggplot(aes(x = time, y = ..density.., group = mon, color = mon)) + geom_freqpoly(binwidth = 100) At least to me there doesn’t appear to much difference in within-day distribution over the year, but I maybe thinking about it incorrectly. Compare dep_time, sched_dep_time and dep_delay. Are they consistent? Explain your findings. If they are consistent, then dep_time = sched_dep_time + dep_delay. flights_dt %&gt;% mutate(dep_time_ = sched_dep_time + dep_delay * 60) %&gt;% filter(dep_time_ != dep_time) %&gt;% select(dep_time_, dep_time, sched_dep_time, dep_delay) #&gt; # A tibble: 1,205 × 4 #&gt; dep_time_ dep_time sched_dep_time dep_delay #&gt; &lt;dttm&gt; &lt;dttm&gt; &lt;dttm&gt; &lt;dbl&gt; #&gt; 1 2013-01-02 08:48:00 2013-01-01 08:48:00 2013-01-01 18:35:00 853 #&gt; 2 2013-01-03 00:42:00 2013-01-02 00:42:00 2013-01-02 23:59:00 43 #&gt; 3 2013-01-03 01:26:00 2013-01-02 01:26:00 2013-01-02 22:50:00 156 #&gt; 4 2013-01-04 00:32:00 2013-01-03 00:32:00 2013-01-03 23:59:00 33 #&gt; 5 2013-01-04 00:50:00 2013-01-03 00:50:00 2013-01-03 21:45:00 185 #&gt; 6 2013-01-04 02:35:00 2013-01-03 02:35:00 2013-01-03 23:59:00 156 #&gt; # ... with 1,199 more rows There exist discrepencies. It looks like there are mistakes in the dates. These are flights in which the actual departure time is on the next day relative to the scheduled departure time. We forgot to account for this when creating the date-times. The code would have had to check if the departure time is less than the scheduled departure time. Alternatively, simply adding the delay time is more robust because it will automatically account for crossing into the next day. Compare air_time with the duration between the departure and arrival. Explain your findings. flights_dt %&gt;% mutate(flight_duration = as.numeric(arr_time - dep_time), air_time_mins = air_time, diff = flight_duration - air_time_mins) %&gt;% select(origin, dest, flight_duration, air_time_mins, diff) #&gt; # A tibble: 328,063 × 5 #&gt; origin dest flight_duration air_time_mins diff #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 EWR IAH 193 227 -34 #&gt; 2 LGA IAH 197 227 -30 #&gt; 3 JFK MIA 221 160 61 #&gt; 4 JFK BQN 260 183 77 #&gt; 5 LGA ATL 138 116 22 #&gt; 6 EWR ORD 106 150 -44 #&gt; # ... with 3.281e+05 more rows How does the average delay time change over the course of a day? Should you use dep_time or sched_dep_time? Why? Use sched_dep_time because that is the relevant metric for someone scheduling a flight. Also, using dep_time will always bias delays to later in the day since delays will push flights later. flights_dt %&gt;% mutate(sched_dep_hour = hour(sched_dep_time)) %&gt;% group_by(sched_dep_hour) %&gt;% summarise(dep_delay = mean(dep_delay)) %&gt;% ggplot(aes(y = dep_delay, x = sched_dep_hour)) + geom_point() + geom_smooth() #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; On what day of the week should you leave if you want to minimise the chance of a delay? Sunday has the lowest average departure delay time and the lowest average arrival delay time. flights_dt %&gt;% mutate(dow = wday(sched_dep_time)) %&gt;% group_by(dow) %&gt;% summarise(dep_delay = mean(dep_delay), arr_delay = mean(arr_delay, na.rm = TRUE)) #&gt; # A tibble: 7 × 3 #&gt; dow dep_delay arr_delay #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 11.5 4.82 #&gt; 2 2 14.7 9.65 #&gt; 3 3 10.6 5.39 #&gt; 4 4 11.7 7.05 #&gt; 5 5 16.1 11.74 #&gt; 6 6 14.7 9.07 #&gt; # ... with 1 more rows What makes the distribution of diamonds$carat and flights$sched_dep_time similar? ggplot(diamonds, aes(x = carat)) + geom_density() In both carat and sched_dep_time there are abnormally large numbers of values are at nice “human” numbers. In sched_dep_time it is at 00 and 30 minutes. In carats, it is at 0, 1/3, 1/2, 2/3, ggplot(diamonds, aes(x = carat %% 1 * 100)) + geom_histogram(binwidth = 1) In scheduled departure times it is 00 and 30 minutes, and minutes ending in 0 and 5. ggplot(flights_dt, aes(x = minute(sched_dep_time))) + geom_histogram(binwidth = 1) Confirm my hypothesis that the early departures of flights in minutes 20-30 and 50-60 are caused by scheduled flights that leave early. Hint: create a binary variable that tells you whether or not a flight was delayed. At the minute level, there doesn’t appear to be anything: flights_dt %&gt;% mutate(early = dep_delay &lt; 0, minute = minute(sched_dep_time)) %&gt;% group_by(minute) %&gt;% summarise(early = mean(early)) %&gt;% ggplot(aes(x = minute, y = early)) + geom_point() But if grouped in 10 minute intervals, there is a higher proportion of early flights during those minutes. flights_dt %&gt;% mutate(early = dep_delay &lt; 0, minute = minute(sched_dep_time) %% 10) %&gt;% group_by(minute) %&gt;% summarise(early = mean(early)) %&gt;% ggplot(aes(x = minute, y = early)) + geom_point() 12.4 Time Spans duration: exact number of seconds period: human time periods - e.g. weeks, months interval: start and end points 12.4.1 Durations No exercises 12.4.2 Periods Define overnight when arr_time &lt; dep_time (no flights &gt; 24 hours): flights_dt &lt;- flights_dt %&gt;% mutate( overnight = arr_time &lt; dep_time, arr_time = arr_time + days(overnight * 1), sched_arr_time = sched_arr_time + days(overnight * 1) ) 12.4.3 Intervals NOTE This section seems less complete than the others. Refer to the lubridate vignette for more information. 12.4.4 Exercises Why is there months() but no dmonths()? There is no direct unambigous value of months in seconds: 31 days: Jan, Mar, May, Jul, Aug, Oct, 30 days: Apr, Jun, Sep, Nov, Dec 28 or 29 days: Feb Though in the past, in the pre-computer era, for arithmetic convenience, bankers adopoted a 360 day year with 30 day months. Explain days(overnight * 1) to someone who has just started learning R. How does it work? overnight is equal to TRUE (1) or FALSE (0). So if it is an overnight flight, this becomes 1 day, and if not, then overnight = 0, and no days are added to the date. Create a vector of dates giving the first day of every month in 2015. Create a vector of dates giving the first day of every month in the current year. A vector of the first day of the month for every month in 2015: ymd(&quot;2015-01-01&quot;) + months(0:11) #&gt; [1] &quot;2015-01-01&quot; &quot;2015-02-01&quot; &quot;2015-03-01&quot; &quot;2015-04-01&quot; &quot;2015-05-01&quot; #&gt; [6] &quot;2015-06-01&quot; &quot;2015-07-01&quot; &quot;2015-08-01&quot; &quot;2015-09-01&quot; &quot;2015-10-01&quot; #&gt; [11] &quot;2015-11-01&quot; &quot;2015-12-01&quot; To get the vector of the first day of the month for this year, we first need to figure out what this year is, and get January 1st of it. I can do that by taking today() and truncating it to the year using floor_date: floor_date(today(), unit = &quot;year&quot;) + months(0:11) #&gt; [1] &quot;2017-01-01&quot; &quot;2017-02-01&quot; &quot;2017-03-01&quot; &quot;2017-04-01&quot; &quot;2017-05-01&quot; #&gt; [6] &quot;2017-06-01&quot; &quot;2017-07-01&quot; &quot;2017-08-01&quot; &quot;2017-09-01&quot; &quot;2017-10-01&quot; #&gt; [11] &quot;2017-11-01&quot; &quot;2017-12-01&quot; Write a function that given your birthday (as a date), returns how old you are in years. age &lt;- function(bday) { (bday %--% today()) %/% years(1) } age(ymd(&quot;1990-10-12&quot;)) #&gt; Note: method with signature &#39;Timespan#Timespan&#39; chosen for function &#39;%/%&#39;, #&gt; target signature &#39;Interval#Period&#39;. #&gt; &quot;Interval#ANY&quot;, &quot;ANY#Period&quot; would also be valid #&gt; [1] 26 Why can’t (today() %--% (today() + years(1)) / months(1) work? It appears to work. Today is a date. Today + 1 year is a valid endpoint for an interval. And months is period that is defined in this period. (today() %--% (today() + years(1))) %/% months(1) #&gt; [1] 12 (today() %--% (today() + years(1))) / months(1) #&gt; [1] 12 12.4.5 Time Zones No exercises. But time-zones are hell. Be happy you aren’t dealing with financial data. "],
["program-intro.html", "13 Introduction", " 13 Introduction "],
["pipes.html", "14 Pipes", " 14 Pipes No exercises in this chapter. "],
["functions.html", "15 Functions 15.1 Introduction 15.2 When should you write a function? 15.3 Functions are for humans and computers 15.4 Conditional execution 15.5 Function arguments", " 15 Functions 15.1 Introduction &amp;&amp;, ||, any, all, identical, dplyr::near switch, cut stop, stopifnot ... 15.2 When should you write a function? library(&quot;lubridate&quot;) #&gt; Loading required package: methods #&gt; #&gt; Attaching package: &#39;lubridate&#39; #&gt; The following object is masked from &#39;package:base&#39;: #&gt; #&gt; date 15.2.1 Practice Ex 1. Why is TRUE not a parameter to rescale01()? What would happen if x contained a single missing value, and na.rm was FALSE? Note By a single missing value, this means that x has at least one NA value. If there were any NA values, and na.rm = FALSE, then the function would return NA. I can confirm this by testing a function that allows for na.rm as an argument: rescale01_alt &lt;- function(x, finite = TRUE) { rng &lt;- range(x, na.rm = finite, finite = finite) (x - rng[1]) / (rng[2] - rng[1]) } rescale01_alt(c(NA, 1:5), finite = FALSE) #&gt; [1] NA NA NA NA NA NA rescale01_alt(c(NA, 1:5), finite = TRUE) #&gt; [1] NA 0.00 0.25 0.50 0.75 1.00 Ex 2. In the second variant of rescale01(), infinite values are left unchanged. Rewrite rescale01() so that -Inf is mapped to 0, and Inf is mapped to 1. rescale01 &lt;- function(x) { rng &lt;- range(x, na.rm = TRUE, finite = TRUE) y &lt;- (x - rng[1]) / (rng[2] - rng[1]) y[y == -Inf] &lt;- 0 y[y == Inf] &lt;- 1 y } rescale01(c(Inf, -Inf, 0:5, NA)) #&gt; [1] 1.0 0.0 0.0 0.2 0.4 0.6 0.8 1.0 NA Ex 3. Practice turning the following code snippets into functions. Think about what each function does. What would you call it? How many arguments does it need? Can you rewrite it to be more expressive or less duplicative? mean(is.na(x)) x / sum(x, na.rm = TRUE) sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE) This function calculates the proportion of NA values in a vector: prop_na &lt;- function(x) { mean(is.na(x)) } prop_na(c(NA, 0, NA, 0, NA)) #&gt; [1] 0.6 This function standardizes a function to its weight. If all elements of x are non-negative, this will ensure the vector sums to 1. weights &lt;- function(x) { x / sum(x, na.rm = TRUE) } y &lt;- weights(0:5) y #&gt; [1] 0.0000 0.0667 0.1333 0.2000 0.2667 0.3333 sum(y) #&gt; [1] 1 This function calculates the coefficient of variation (assuming that x can only take non-negative values). The coefficient of variation is the standard deviation devided by the mean: coef_variation &lt;- function(x) { sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE) } coef_variation(runif(10)) #&gt; [1] 0.672 Ex 4. Follow http://nicercode.github.io/intro/writing-functions.html to write your own functions to compute the variance and skew of a numeric vecto Note The math in https://nicercode.github.io/intro/writing-functions.html seems not to be rendering, but I’ll write functions for the variance and skewness. The sample variance is defined as \\[ Var(x) = \\frac{1}{n - 1} \\sum_{i=1}^n (x_i - \\bar{x}) ^2 \\] where the sample mean is \\(\\bar{x} = (\\sum x_i) / n\\). variance &lt;- function(x) { # remove missing values x &lt;- x[!is.na(x)] n &lt;- length(x) m &lt;- mean(x) sq_err &lt;- (x - m) ^ 2 sum(sq_err) / (n - 1) } var(1:10) #&gt; [1] 9.17 variance(1:10) #&gt; [1] 9.17 There are multiple definitions of skewness, but I’ll use the method of moments estimator of the population skewness, \\[ b_1 = \\frac{m_3}{s^3} = \\frac{\\frac{1}{n} \\sum (x_i - \\bar{x}) ^ 3}{{\\left(\\frac{1}{n - 1} \\sum (x_i - \\bar{x}) ^ 2\\right)} ^ \\frac{3}{2}} \\] skewness &lt;- function(x) { x &lt;- x[!is.na(x)] n &lt;- length(x) m &lt;- mean(x) m3 &lt;- sum((x - m) ^ 3) / n s3 &lt;- sqrt(sum((x - m) ^ 2) / (n - 1)) m3 / s3 } skewness(rgamma(10, 1, 1)) #&gt; [1] 1.56 Write both_na(), a function that takes two vectors of the same length and returns the number of positions that have an NA in both vectors. both_na &lt;- function(x, y) { sum(is.na(x) &amp; is.na(y)) } both_na(c(NA, NA, 1, 2), c(NA, 1, NA, 2)) #&gt; [1] 1 both_na(c(NA, NA, 1, 2, NA, NA, 1), c(NA, 1, NA, 2, NA, NA, 1)) #&gt; [1] 3 Ex. 6 What do the following functions do? Why are they useful even though they are so short? is_directory &lt;- function(x) file.info(x)$isdir is_readable &lt;- function(x) file.access(x, 4) == 0 The function is_directory checks whether the path in x is a directory. The function is_readable checks whether the path in x is readable, meaning that the file exists and the user has permission to open it. These functions are useful even though they are short because their names make it much clearer what the code is doing. Ex 7. Read the complete lyrics to “Little Bunny Foo Foo”. There’s a lot of duplication in this song. Extend the initial piping example to recreate the complete song, and use functions to reduce the duplication. This could probably be done cleaner, but here’s one version. threat &lt;- function(chances) { give_chances(from = Good_Fairy, to = foo_foo, number = chances, condition = &quot;Don&#39;t behave&quot;, consequence = turn_into_goon) } lyric &lt;- function() { foo_foo %&gt;% hop(through = forest) %&gt;% scoop(up = field_mouse) %&gt;% bop(on = head) down_came(Good_Fairy) said(Good_Fairy, c(&quot;Little bunny Foo Foo&quot;, &quot;I don&#39;t want to see you&quot;, &quot;Scooping up the field mice&quot; &quot;And bopping them on the head.&quot;) } lyric() threat(3) lyric() threat(2) lyric() threat(1) lyric() turn_into_goon(Good_Fairy, foo_foo) 15.3 Functions are for humans and computers There are only two hard problems in Computer Science: cache invalidation and naming things. - Phil Karlton (as quoted by many places online but no original source.) See this Quora discussion: Why is naming things hard in computer science, and how can it can be made easier?. 15.3.1 Exercises Ex 1. Read the source code for each of the following three functions, puzzle out what they do, and then brainstorm better names. f1 &lt;- function(string, prefix) { substr(string, 1, nchar(prefix)) == prefix } f2 &lt;- function(x) { if (length(x) &lt;= 1) return(NULL) x[-length(x)] } f3 &lt;- function(x, y) { rep(y, length.out = length(x)) } The function f1 returns whether a function has a common prefix. f1(c(&quot;str_c&quot;, &quot;str_foo&quot;, &quot;abc&quot;), &quot;str_&quot;) #&gt; [1] TRUE TRUE FALSE A better name for f1 is has_prefix() The function f2 drops the last element: f2(1:3) #&gt; [1] 1 2 f2(1:2) #&gt; [1] 1 f2(1) #&gt; NULL A better name for f2 is drop_last(). The function f3 repeats y once for each element of x. f3(1:3, 4) #&gt; [1] 4 4 4 This is a harder one to name. I would say something like recycle (R’s name for this behavior), or epxand. Ex. 2 Take a function that you’ve written recently and spend 5 minutes brainstorming a better name for it and its arguments. Don’t worry about it Ex. 3 Compare and contrast rnorm() and MASS::mvrnorm(). How could you make them more consistent? You can ignore rnorm samples from the univariate normal distribution, while MASS::mvrnorm samples from the multivariate normal distribution. The main arguments in rnorm are n, mean, sd. The main arguments is MASS::mvrnorm are n, mu, Sigma. To be consistent they should have the same names. However, this is difficult. In general, it is better to be consistent with more widely used functions, e.g. rmvnorm should follow the conventions of rnorm. However, while mean is correct in the multivariate case, sd does not make sense in the multivariate case. Both functions an internally consistent though; it would be bad to have mu and sd or mean and Sigma. Ex. 4 Make a case for why norm_r(), norm_d() etc would be better than rnorm(), dnorm(). Make a case for the opposite. If named norm_r and norm_d, it groups the family of functions related to the normal distribution. If named rnorm, and dnorm, functions related to are grouped into families by the action they perform. r* functions always sample from distributions: rnorm, rbinom, runif, rexp. d* functions calculate the probability density or mass of a distribution: dnorm, dbinom, dunif, dexp. 15.4 Conditional execution 15.4.1 Exercises Ex. 1 What’s the difference between if and ifelse()? Carefully read the help and construct three examples that illustrate the key differences. The keyword if tests a single condition, while ifelse tests each element. Ex. 2 Write a greeting function that says “good morning”, “good afternoon”, or “good evening”, depending on the time of day. (Hint: use a time argument that defaults to lubridate::now(). That will make it easier to test your function.) greet &lt;- function(time = lubridate::now()) { hr &lt;- hour(time) # I don&#39;t know what to do about times after midnight, # are they evening or morning? if (hr &lt; 12) { print(&quot;good morning&quot;) } else if (hr &lt; 17) { print(&quot;good afternoon&quot;) } else { print(&quot;good evening&quot;) } } greet() #&gt; [1] &quot;good morning&quot; greet(ymd_h(&quot;2017-01-08:05&quot;)) #&gt; [1] &quot;good morning&quot; greet(ymd_h(&quot;2017-01-08:13&quot;)) #&gt; [1] &quot;good afternoon&quot; greet(ymd_h(&quot;2017-01-08:20&quot;)) #&gt; [1] &quot;good evening&quot; Ex. 3 Implement a fizzbuzz function. It takes a single number as input. If the number is divisible by three, it returns “fizz”. If it’s divisible by five it returns “buzz”. If it’s divisible by three and five, it returns “fizzbuzz”. Otherwise, it returns the number. Make sure you first write working code before you create the function. fizzbuzz &lt;- function(x) { stopifnot(length(x) == 1) stopifnot(is.numeric(x)) # this could be made more efficient by minimizing the # number of tests if (!(x %% 3) &amp; !(x %% 5)) { print(&quot;fizzbuzz&quot;) } else if (!(x %% 3)) { print(&quot;fizz&quot;) } else if (!(x %% 5)) { print(&quot;buzz&quot;) } } fizzbuzz(6) #&gt; [1] &quot;fizz&quot; fizzbuzz(10) #&gt; [1] &quot;buzz&quot; fizzbuzz(15) #&gt; [1] &quot;fizzbuzz&quot; fizzbuzz(2) Ex. 4 How could you use cut() to simplify this set of nested if-else statements? if (temp &lt;= 0) { &quot;freezing&quot; } else if (temp &lt;= 10) { &quot;cold&quot; } else if (temp &lt;= 20) { &quot;cool&quot; } else if (temp &lt;= 30) { &quot;warm&quot; } else { &quot;hot&quot; } How would you change the call to cut() if I’d used &lt; instead of &lt;=? What is the other chief advantage of cut() for this problem? (Hint: what happens if you have many values in temp?) temp &lt;- seq(-10, 50, by = 5) cut(temp, c(-Inf, 0, 10, 20, 30, Inf), right = TRUE, labels = c(&quot;freezing&quot;, &quot;cold&quot;, &quot;cool&quot;, &quot;warm&quot;, &quot;hot&quot;)) #&gt; [1] freezing freezing freezing cold cold cool cool #&gt; [8] warm warm hot hot hot hot #&gt; Levels: freezing cold cool warm hot To have intervals open on the left (using &lt;), I change the argument to right = FALSE: temp &lt;- seq(-10, 50, by = 5) cut(temp, c(-Inf, 0, 10, 20, 30, Inf), right = FALSE, labels = c(&quot;freezing&quot;, &quot;cold&quot;, &quot;cool&quot;, &quot;warm&quot;, &quot;hot&quot;)) #&gt; [1] freezing freezing cold cold cool cool warm #&gt; [8] warm hot hot hot hot hot #&gt; Levels: freezing cold cool warm hot Two advantages of using cut is that it works on vectors, whereas if only works on a single value (I already demonstrated this above), and that to change comparisons I only needed to change the argument to right, but I would have had to change four operators in the if expression. Ex. 5 What happens if you use switch() with numeric values? It selects that number argument from .... switch(2, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;) #&gt; [1] &quot;two&quot; Ex 6. What does this switch() call do? What happens if x is “e”? It will return the &quot;ab&quot; for a or b, &quot;cd&quot; for c or d, an NULL for e. It returns the first non-missing value for the first name it matches. x &lt;- &quot;e&quot; switch(x, a = , b = &quot;ab&quot;, c = , d = &quot;cd&quot; ) Experiment, then carefully read the documentation. switcheroo &lt;- function(x) { switch(x, a = , b = &quot;ab&quot;, c = , d = &quot;cd&quot; ) } switcheroo(&quot;a&quot;) #&gt; [1] &quot;ab&quot; switcheroo(&quot;b&quot;) #&gt; [1] &quot;ab&quot; switcheroo(&quot;c&quot;) #&gt; [1] &quot;cd&quot; switcheroo(&quot;d&quot;) #&gt; [1] &quot;cd&quot; switcheroo(&quot;e&quot;) 15.5 Function arguments 15.5.1 Exercises Ex 1. What does commas(letters, collapse = &quot;-&quot;) do? Why? commas &lt;- function(...) stringr::str_c(..., collapse = &quot;, &quot;) It throws an error. commas(letters, collapse = &quot;-&quot;) #&gt; Error in stringr::str_c(..., collapse = &quot;, &quot;): formal argument &quot;collapse&quot; matched by multiple actual arguments The argument collapse is passed to str_c as part of ..., so it tries to run str_c(letters, collapse = &quot;-&quot;, collapse = &quot;, &quot;). Ex 2. It’d be nice if you could supply multiple characters to the pad argument, e.g. rule(&quot;Title&quot;, pad = &quot;-+&quot;). Why doesn’t this currently work? How could you fix it? rule &lt;- function(..., pad = &quot;-&quot;) { title &lt;- paste0(...) width &lt;- getOption(&quot;width&quot;) - nchar(title) - 5 cat(title, &quot; &quot;, stringr::str_dup(pad, width), &quot;\\n&quot;, sep = &quot;&quot;) } rule(&quot;Important output&quot;) #&gt; Important output ------------------------------------------------------ rule(&quot;Important output&quot;, pad = &quot;-+&quot;) #&gt; Important output -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ It does not work because it duplicates pad by the width minus the length of the string. This is implictly assuming that pad is only one character. I could adjust the code to calculate the length of pad. The trickiest part is handling what to do if width is not a multiple of the number of characters of pad. rule &lt;- function(..., pad = &quot;-&quot;) { title &lt;- paste0(...) width &lt;- getOption(&quot;width&quot;) - nchar(title) - 5 padchar &lt;- nchar(pad) cat(title, &quot; &quot;, stringr::str_dup(pad, width %/% padchar), # if not multiple, fill in the remaining characters stringr::str_sub(pad, 1, width %% padchar), &quot;\\n&quot;, sep = &quot;&quot;) } rule(&quot;Important output&quot;) #&gt; Important output ------------------------------------------------------ rule(&quot;Important output&quot;, pad = &quot;-+&quot;) #&gt; Important output -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ rule(&quot;Important output&quot;, pad = &quot;-+-&quot;) #&gt; Important output -+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+- Ex 3. What does the trim argument to mean() do? When might you use it? The trim arguments trims a fraction of observations from each end of the vector (meaning the range) before calculating the mean. This is useful for calculating a measure of central tendancy that is robust to outliers. Ex 4. The default value for the method argument to cor() is c(&quot;pearson&quot;, &quot;kendall&quot;, &quot;spearman&quot;). What does that mean? What value is used by default? It means that the method argument can take one of those three values. The first value, &quot;pearson&quot;, is used by default. "],
["vectors.html", "16 Vectors 16.1 Introduction 16.2 Important types of Atomic Vector 16.3 Using atomic vectors 16.4 Recursive Vectors (lists) 16.5 Augmented Vectors", " 16 Vectors 16.1 Introduction Functions mentioned typeof dplyr::near is.finite, is.nan, is.na attributes library(&quot;tidyverse&quot;) #&gt; Loading tidyverse: ggplot2 #&gt; Loading tidyverse: tibble #&gt; Loading tidyverse: tidyr #&gt; Loading tidyverse: readr #&gt; Loading tidyverse: purrr #&gt; Loading tidyverse: dplyr #&gt; Conflicts with tidy packages ---------------------------------------------- #&gt; filter(): dplyr, stats #&gt; lag(): dplyr, stats 16.2 Important types of Atomic Vector Why does this matter? 99% of the time in the work you do, it won’t. Someone else has written the numerical methods and (hopefully) accounted for these issues. And the types of problems you encounter in social science generally are not dealing with these issues. However, if you aren’t even aware that “floating point numbers” are a “thing”, if something goes wrong, it will seem like magic. Also, at least being aware of these problems will help you understand error messages from optimization routines that complaing of “numerical precision”. Computerphile has a good video on Floating Point Numbers. 16.2.1 Exercises Describe the difference between is.finite(x) and !is.infinite(x). To find out, try the functions on a numeric vector that includes a number and the five special values (NA, NaN, Inf, -Inf). x &lt;- c(0, NA, NaN, Inf, -Inf) is.finite(x) #&gt; [1] TRUE FALSE FALSE FALSE FALSE !is.infinite(x) #&gt; [1] TRUE TRUE TRUE FALSE FALSE is.finite considers only a number to be finite, and considers missing (NA), not a number (NaN), and positive and negative infinity to be not finite. However, since is.infinite only considers Inf and -Inf to be inifinite, !is.infinite considers 0 as well as missing and not-a-number to be not infinite. So NA and NaN are neither finite or infinite. Mind blown. Read the source code for dplyr::near() (Hint: to see the source code, drop the ()). How does it work? The source for dplyr::near is: dplyr::near #&gt; function (x, y, tol = .Machine$double.eps^0.5) #&gt; { #&gt; abs(x - y) &lt; tol #&gt; } #&gt; &lt;environment: namespace:dplyr&gt; Instead of checking for exact equality, it checks that two numbers are within a certain tolerance, tol. By default the tolerance is set to the square root of .Machine$double.eps, which is the smallest floating point number that the computer can represent. A logical vector can take 3 possible values. How many possible values can an integer vector take? How many possible values can a double take? Use google to do some research. The help for .Machine describes some of this: As all current implementations of R use 32-bit integers and usne IEC 60559 floating-point (double precision) arithmetic, The IEC 60559 or IEEE 754 format uses a 64 bit vector, but Brainstorm at least four functions that allow you to convert a double to an integer. How do they differ? Be precise. Broadly, could convert a double to an integer by truncating or rounding to the nearest integer. For truncating or for handling ties (doubles ending in 0.5), there are multiple methods for determing which integer value to go to. methods 0.5 -0.5 1.5 -1.5 ============================== ==== ===== ==== ==== towards zero: 0 0 1 1 away from zero 1 -1 2 -2 largest towards \\(+\\infty\\)) 1 0 2 -1 smallest (towards \\(-\\infty\\)) 0 -1 1 -2 even 0 0 2 -2 odd 1 -1 1 -1 ===================================================== See the Wikipedia article IEEE floating point for rounding rules. For rounding, R and many programming languages use the IEEE standard. This is “round to nearest, ties to even”. This is not the same as what you See the value of looking at the value of .Machine$double.rounding and its documentation. x &lt;- seq(-10, 10, by = 0.5) round2 &lt;- function(x, to_even = TRUE) { q &lt;- x %/% 1 r &lt;- x %% 1 q + (r &gt;= 0.5) } x &lt;- c(-12.5, -11.5, 11.5, 12.5) round(x) #&gt; [1] -12 -12 12 12 round2(x, to_even = FALSE) #&gt; [1] -12 -11 12 13 The problem with the always rounding 0.5 up rule is that it is biased upwards. Rounding to nearest with ties towards even is not. Consider the sequence \\(-100.5, -99.5, \\dots, 0, \\dots, 99.5, 100.5\\). Its sum is 0. It would be nice if rounding preserved that sum. Using the “ties towards even”, the sum is still zero. Hoever, the “ties towards \\(+\\infty\\)” produces a non-zero number. x &lt;- seq(-100.5, 100.5, by = 1) sum(x) #&gt; [1] 0 sum(round(x)) #&gt; [1] 0 sum(round2(x)) #&gt; [1] 101 Here’s a real-world non-engineering example of rounding going terribly wrong. In 1983, the Vancouver stock exchange adjusted its index from 524.811 to 1098.892 to correct for accumulated error due to rounding to three decimal points (see Vancouver Stock Exchange). Here’s a list of a few more. What functions from the readr package allow you to turn a string into logical, integer, and double vector? The functions parse_logical, parse_integer, and parse_number. parse_logical(c(&quot;TRUE&quot;, &quot;FALSE&quot;, &quot;1&quot;, &quot;0&quot;, &quot;true&quot;, &quot;t&quot;, &quot;NA&quot;)) #&gt; [1] TRUE FALSE TRUE FALSE TRUE TRUE NA parse_integer(c(&quot;1235&quot;, &quot;0134&quot;, &quot;NA&quot;)) #&gt; [1] 1235 134 NA parse_number(c(&quot;1.0&quot;, &quot;3.5&quot;, &quot;1,000&quot;, &quot;NA&quot;)) #&gt; [1] 1.0 3.5 1000.0 NA Read the documentation of read_number. In order to ignore things like currency symbols and comma seperators in number strings it ignores them using a heuristic. 16.3 Using atomic vectors What does mean(is.na(x)) tell you about a vector x? What about sum(!is.finite(x))? The expression mean(is.na(x)) calculates the proportion of missing values in a vector x &lt;- c(1:10, NA, NaN, Inf, -Inf) mean(is.na(x)) #&gt; [1] 0.143 The expression mean(!is.finite(x)) calcualtes the proportion of values that are NA, NaN, or infinite. mean(!is.finite(x)) #&gt; [1] 0.286 Carefully read the documentation of is.vector(). What does it actually test for? Why does is.atomic() not agree with the definition of atomic vectors above? The function is.vector only checks whether the object has no attributes other than names. Thus a list is a vector: is.vector(list(a = 1, b = 2)) #&gt; [1] TRUE But any object that has an attribute (other than names) is not: x &lt;- 1:10 attr(x, &quot;something&quot;) &lt;- TRUE is.vector(x) #&gt; [1] FALSE The idea behind this is that object oriented classes will include attributes, including, but not limited to &quot;class&quot;. The function is.atomic explicitly checks whether an object is one of the atomic types (“logical”, “integer”, “numeric”, “complex”, “character”, and “raw”) or NULL. is.atomic(1:10) #&gt; [1] TRUE is.atomic(list(a = 1)) #&gt; [1] FALSE The function is.atomic will consider objects to be atomic even if they have extra attributes. is.atomic(x) #&gt; [1] TRUE Compare and contrast setNames() with purrr::set_names(). These are simple functions, so we can simply print out their source code: setNames #&gt; function (object = nm, nm) #&gt; { #&gt; names(object) &lt;- nm #&gt; object #&gt; } #&gt; &lt;bytecode: 0x7fca28a92038&gt; #&gt; &lt;environment: namespace:stats&gt; purrr::set_names #&gt; function (x, nm = x) #&gt; { #&gt; if (!is_vector(x)) { #&gt; stop(&quot;`x` must be a vector&quot;, call. = FALSE) #&gt; } #&gt; if (length(x) != length(nm)) { #&gt; stop(&quot;`x` and `nm` must be the same length&quot;, call. = FALSE) #&gt; } #&gt; names(x) &lt;- nm #&gt; x #&gt; } #&gt; &lt;environment: namespace:purrr&gt; From the code we can see that set_names adds a few sanity checks: x has to be a vector, and the lengths of the object and the names have to be the same. Create functions that take a vector as input and returns: The last value. Should you use [ or [[? 2 The elements at even numbered positions. Every element except the last value. Only even numbers (and no missing values). last_value &lt;- function(x) { # check for case with no length if (length(x)) { # Use [[ as suggested because it returns one element x[[length(x)]] } else { x } } last_value(numeric()) #&gt; numeric(0) last_value(1) #&gt; [1] 1 last_value(1:10) #&gt; [1] 10 even_indices &lt;- function(x) { if (length(x)) { x[seq_along(x) %% 2 == 0] } else { x } } even_indices(numeric()) #&gt; numeric(0) even_indices(1) #&gt; numeric(0) even_indices(1:10) #&gt; [1] 2 4 6 8 10 # test using case to ensure that values not indices # are being returned even_indices(letters) #&gt; [1] &quot;b&quot; &quot;d&quot; &quot;f&quot; &quot;h&quot; &quot;j&quot; &quot;l&quot; &quot;n&quot; &quot;p&quot; &quot;r&quot; &quot;t&quot; &quot;v&quot; &quot;x&quot; &quot;z&quot; not_last &lt;- function(x) { if (length(x)) { x[-length(x)] } else { x } } not_last(1:5) #&gt; [1] 1 2 3 4 even_numbers &lt;- function(x) { x[!is.na(x) &amp; (x %% 2 == 0)] } even_numbers(-10:10) #&gt; [1] -10 -8 -6 -4 -2 0 2 4 6 8 10 Why is x[-which(x &gt; 0)] not the same as x[x &lt;= 0]? They will treat missing values differently. x &lt;- c(-5:5, Inf, -Inf, NaN, NA) x[-which(x &gt; 0)] #&gt; [1] -5 -4 -3 -2 -1 0 -Inf NaN NA -which(x &gt; 0) #&gt; [1] -7 -8 -9 -10 -11 -12 x[x &lt;= 0] #&gt; [1] -5 -4 -3 -2 -1 0 -Inf NA NA x &lt;= 0 #&gt; [1] TRUE TRUE TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE #&gt; [12] FALSE TRUE NA NA -which(x &gt; 0) which calculates the indexes for any value that is TRUE and ignores NA. Thus is keeps NA and NaN because the comparison is not TRUE. x &lt;= 0 works slightly differently. If x &lt;= 0 returns TRUE or FALSE it works the same way. Hoewver, if the comparison generates a NA, then it will always keep that entry, but set it to NA. This is why the last two values of x[x &lt;= 0] are NA rather than c(NaN, NA). What happens when you subset with a positive integer that’s bigger than the length of the vector? What happens when you subset with a name that doesn’t exist? When you subset with positive integers that are larger than the length of the vector, NA values are returned for those integers larger than the length of the vector. (1:10)[11:12] #&gt; [1] NA NA When a vector is subset with a name that doesn’t exist, an error is generated. c(a = 1, 2)[[&quot;b&quot;]] #&gt; Error in c(a = 1, 2)[[&quot;b&quot;]]: subscript out of bounds 16.4 Recursive Vectors (lists) 16.4.1 Exercises Draw the following lists as nested sets: list(a, b, list(c, d), list(e, f)) list(list(list(list(list(list(a)))))) What happens if you subset a tibble as if you’re subsetting a list? What are the key differences between a list and a tibble? Subsetting a tibble works the same way as a list; a data frame can be thought of as a list of columns. The key different between a list and a tibble is that a tibble (data frame) has the restriction that all its elements (columns) must have the same length. x &lt;- tibble(a = 1:2, b = 3:4) x[[&quot;a&quot;]] #&gt; [1] 1 2 x[&quot;a&quot;] #&gt; # A tibble: 2 × 1 #&gt; a #&gt; &lt;int&gt; #&gt; 1 1 #&gt; 2 2 x[1] #&gt; # A tibble: 2 × 1 #&gt; a #&gt; &lt;int&gt; #&gt; 1 1 #&gt; 2 2 x[1, ] #&gt; # A tibble: 1 × 2 #&gt; a b #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 3 16.5 Augmented Vectors 16.5.1 Exercises What does hms::hms(3600) return? How does it print? What primitive type is the augmented vector built on top of? What attributes does it use? x &lt;- hms::hms(3600) class(x) #&gt; [1] &quot;hms&quot; &quot;difftime&quot; x #&gt; 01:00:00 hms::hms returns an object of class, and prints the time in “%H:%M:%S” format. The primitive type is a double typeof(x) #&gt; [1] &quot;double&quot; The atttributes is uses are &quot;units&quot; and &quot;class&quot;. attributes(x) #&gt; $units #&gt; [1] &quot;secs&quot; #&gt; #&gt; $class #&gt; [1] &quot;hms&quot; &quot;difftime&quot; Try and make a tibble that has columns with different lengths. What happens? If I try to create at tibble with a scalar and column of a different length there are no issues, and the scalar is repeated to the length of the longer vector. tibble(x = 1, y = 1:5) #&gt; # A tibble: 5 × 2 #&gt; x y #&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 1 1 #&gt; 2 1 2 #&gt; 3 1 3 #&gt; 4 1 4 #&gt; 5 1 5 However, if I try to create a tibble with two vectors of different lengths (other than one), the tibble function throws an error. tibble(x = 1:3, y = 1:4) #&gt; Error: Variables must be length 1 or 4. #&gt; Problem variables: &#39;x&#39; Based on the definition above, is it ok to have a list as a column of a tibble? If I didn’t already know the answer, what I would do is try it out. From the above, the error message was about vectors having different lengths. But there is nothing that prevents a tibble from having vectors of different types: doubles, character, integers, logical, factor, date. The later are still atomic, but they have additional attributes. So, maybe there won’t be an issue with a list vector as long as it is the same length. tibble(x = 1:3, y = list(&quot;a&quot;, 1, list(1:3))) #&gt; # A tibble: 3 × 2 #&gt; x y #&gt; &lt;int&gt; &lt;list&gt; #&gt; 1 1 &lt;chr [1]&gt; #&gt; 2 2 &lt;dbl [1]&gt; #&gt; 3 3 &lt;list [1]&gt; It works! I even used a list with heterogenous types and there wasn’t an issue. In following chapters we’ll see that list vectors can be very useful: for example, when processing many different models. "],
["iteration.html", "17 Iteration 17.1 Introduction 17.2 For Loops 17.3 For loop variations 17.4 For loops vs. functionals 17.5 The map functions 17.6 Dealing with Failure 17.7 Mapping over multiple arguments 17.8 Walk 17.9 Other patterns of for loops", " 17 Iteration 17.1 Introduction purrr package for loop while seq_len, seq_along unlist bind_rows, bind_cols, purrr::flatten_dbl Map functions in purrr: map and type-specific variants map_lgl, map_chr, map_int, map_dbl. col_summary apply function in base R: lapply, sapply, vapply safely, quietly, possibly walk and variants keep, discard, some, every, head_while, tail_while, detect, detect_index reduce library(&quot;tidyverse&quot;) library(&quot;stringr&quot;) The package microbenchmark is used for timing code library(&quot;microbenchmark&quot;) 17.2 For Loops 17.2.1 Exercises Write for loops to: Compute the mean of every column in mtcars. Determine the type of each column in nycflights13::flights. Compute the number of unique values in each column of iris. Generate 10 random normals for each of \\(\\mu = -10\\), 0, 10, and 100. Think about the output, sequence, and body before you start writing the loop. To compute the mean of every column in mtcars. output &lt;- vector(&quot;double&quot;, ncol(mtcars)) names(output) &lt;- names(mtcars) for (i in names(mtcars)) { output[i] &lt;- mean(mtcars[[i]]) } output #&gt; mpg cyl disp hp drat wt qsec vs am #&gt; 20.091 6.188 230.722 146.688 3.597 3.217 17.849 0.438 0.406 #&gt; gear carb #&gt; 3.688 2.812 Determine the type of each column in nycflights13::flights. Note that we need to use a list, not a character vector, since the class can have multiple values. data(&quot;flights&quot;, package = &quot;nycflights13&quot;) output &lt;- vector(&quot;list&quot;, ncol(flights)) names(output) &lt;- names(flights) for (i in names(flights)) { output[[i]] &lt;- class(flights[[i]]) } output #&gt; $year #&gt; [1] &quot;integer&quot; #&gt; #&gt; $month #&gt; [1] &quot;integer&quot; #&gt; #&gt; $day #&gt; [1] &quot;integer&quot; #&gt; #&gt; $dep_time #&gt; [1] &quot;integer&quot; #&gt; #&gt; $sched_dep_time #&gt; [1] &quot;integer&quot; #&gt; #&gt; $dep_delay #&gt; [1] &quot;numeric&quot; #&gt; #&gt; $arr_time #&gt; [1] &quot;integer&quot; #&gt; #&gt; $sched_arr_time #&gt; [1] &quot;integer&quot; #&gt; #&gt; $arr_delay #&gt; [1] &quot;numeric&quot; #&gt; #&gt; $carrier #&gt; [1] &quot;character&quot; #&gt; #&gt; $flight #&gt; [1] &quot;integer&quot; #&gt; #&gt; $tailnum #&gt; [1] &quot;character&quot; #&gt; #&gt; $origin #&gt; [1] &quot;character&quot; #&gt; #&gt; $dest #&gt; [1] &quot;character&quot; #&gt; #&gt; $air_time #&gt; [1] &quot;numeric&quot; #&gt; #&gt; $distance #&gt; [1] &quot;numeric&quot; #&gt; #&gt; $hour #&gt; [1] &quot;numeric&quot; #&gt; #&gt; $minute #&gt; [1] &quot;numeric&quot; #&gt; #&gt; $time_hour #&gt; [1] &quot;POSIXct&quot; &quot;POSIXt&quot; data(iris) iris_uniq &lt;- vector(&quot;double&quot;, ncol(iris)) names(iris_uniq) &lt;- names(iris) for (i in names(iris)) { iris_uniq[i] &lt;- length(unique(iris[[i]])) } iris_uniq #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 35 23 43 22 3 # number to draw n &lt;- 10 # values of the mean mu &lt;- c(-10, 0, 10, 100) normals &lt;- vector(&quot;list&quot;, length(mu)) for (i in seq_along(normals)) { normals[[i]] &lt;- rnorm(n, mean = mu[i]) } normals #&gt; [[1]] #&gt; [1] -9.03 -11.01 -10.08 -10.55 -9.25 -10.93 -10.47 -10.86 -11.52 -8.03 #&gt; #&gt; [[2]] #&gt; [1] 0.4632 -0.8562 0.6480 0.0758 0.4918 -0.7535 0.3490 -0.1708 #&gt; [9] 1.6312 -0.7827 #&gt; #&gt; [[3]] #&gt; [1] 10.00 10.41 10.72 12.35 9.72 9.52 10.08 10.77 10.56 9.63 #&gt; #&gt; [[4]] #&gt; [1] 99.4 99.6 99.1 100.1 99.4 99.7 99.9 97.9 100.2 99.7 However, we don’t need a for loop for this since rnorm recycles means. matrix(rnorm(n * length(mu), mean = mu), ncol = n) #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] #&gt; [1,] -9.745 -11.57 -9.0267 -9.563 -8.78273 -9.83 -10.861 -10.69 -11.781 #&gt; [2,] -0.553 -1.04 -0.0768 0.413 0.00048 1.40 0.421 1.34 -0.716 #&gt; [3,] 11.405 11.02 10.8929 10.976 10.75513 9.32 11.451 12.74 10.911 #&gt; [4,] 99.205 99.30 99.2225 101.147 100.34240 100.74 100.194 99.06 99.228 #&gt; [,10] #&gt; [1,] -10.782 #&gt; [2,] -0.432 #&gt; [3,] 9.332 #&gt; [4,] 101.390 Eliminate the for loop in each of the following examples by taking advantage of an existing function that works with vectors: out &lt;- &quot;&quot; for (x in letters) { out &lt;- stringr::str_c(out, x) } out #&gt; [1] &quot;abcdefghijklmnopqrstuvwxyz&quot; str_c already works with vectors, so simply use str_c with the collapse argument to return a single string. stringr::str_c(letters, collapse = &quot;&quot;) #&gt; [1] &quot;abcdefghijklmnopqrstuvwxyz&quot; For this I’m going to rename the variable sd to something different because sd is the name of the function we want to use. x &lt;- sample(100) sd. &lt;- 0 for (i in seq_along(x)) { sd. &lt;- sd. + (x[i] - mean(x)) ^ 2 } sd. &lt;- sqrt(sd. / (length(x) - 1)) sd. #&gt; [1] 29 We could simply use the sd function. sd(x) #&gt; [1] 29 Or if there was a need to use the equation (e.g. for pedagogical reasons), then the functions mean and sum already work with vectors: sqrt(sum((x - mean(x)) ^ 2) / (length(x) - 1)) #&gt; [1] 29 x &lt;- runif(100) out &lt;- vector(&quot;numeric&quot;, length(x)) out[1] &lt;- x[1] for (i in 2:length(x)) { out[i] &lt;- out[i - 1] + x[i] } out #&gt; [1] 0.938 1.739 2.497 3.030 3.577 3.673 4.061 4.233 4.924 5.599 #&gt; [11] 6.546 6.742 7.711 8.098 8.748 9.563 9.634 10.160 10.924 11.359 #&gt; [21] 11.912 12.116 12.147 13.116 13.295 14.073 14.959 15.796 16.401 17.308 #&gt; [31] 17.344 17.475 17.569 18.266 18.671 18.737 18.864 19.801 20.017 20.683 #&gt; [41] 20.887 21.436 22.263 22.391 22.652 22.941 22.955 23.809 24.223 24.974 #&gt; [51] 25.693 26.208 27.183 27.544 27.714 28.498 28.529 29.318 29.485 29.513 #&gt; [61] 30.299 31.125 32.090 32.468 32.643 33.247 34.052 34.089 34.822 35.037 #&gt; [71] 35.053 35.182 35.868 36.510 36.837 37.224 37.932 38.629 39.555 40.014 #&gt; [81] 40.610 40.775 41.342 42.240 42.835 43.666 44.260 45.039 45.436 46.286 #&gt; [91] 47.028 47.346 47.458 47.559 48.359 48.739 48.791 49.778 50.382 50.531 The code above is calculating a cumulative sum. Use the function cumsum all.equal(cumsum(x),out) #&gt; [1] TRUE Ex. 21.2.1.3 Combine your function writing and for loop skills: 1. Write a for loop that `prints()` the lyrics to the children&#39;s song &quot;Alice the camel&quot;. 1. Convert the nursery rhyme &quot;ten in the bed&quot; to a function. Generalise it to any number of people in any sleeping structure. 1. Convert the song &quot;99 bottles of beer on the wall&quot; to a function. Generalise to any number of any vessel containing any liquid on any surface. I don’t know what the deal is with Hadley and nursery rhymes. Here’s the lyrics for Alice the Camel We’ll look from five to no humps, and print out a different last line if there are no humps. This uses cat instead of print, so it looks nicer. humps &lt;- c(&quot;five&quot;, &quot;four&quot;, &quot;three&quot;, &quot;two&quot;, &quot;one&quot;, &quot;no&quot;) for (i in humps) { cat(str_c(&quot;Alice the camel has &quot;, rep(i, 3), &quot; humps.&quot;, collapse = &quot;\\n&quot;), &quot;\\n&quot;) if (i == &quot;no&quot;) { cat(&quot;Now Alice is a horse.\\n&quot;) } else { cat(&quot;So go, Alice, go.\\n&quot;) } cat(&quot;\\n&quot;) } #&gt; Alice the camel has five humps. #&gt; Alice the camel has five humps. #&gt; Alice the camel has five humps. #&gt; So go, Alice, go. #&gt; #&gt; Alice the camel has four humps. #&gt; Alice the camel has four humps. #&gt; Alice the camel has four humps. #&gt; So go, Alice, go. #&gt; #&gt; Alice the camel has three humps. #&gt; Alice the camel has three humps. #&gt; Alice the camel has three humps. #&gt; So go, Alice, go. #&gt; #&gt; Alice the camel has two humps. #&gt; Alice the camel has two humps. #&gt; Alice the camel has two humps. #&gt; So go, Alice, go. #&gt; #&gt; Alice the camel has one humps. #&gt; Alice the camel has one humps. #&gt; Alice the camel has one humps. #&gt; So go, Alice, go. #&gt; #&gt; Alice the camel has no humps. #&gt; Alice the camel has no humps. #&gt; Alice the camel has no humps. #&gt; Now Alice is a horse. The lyrics for Ten in the Bed: numbers &lt;- c(&quot;ten&quot;, &quot;nine&quot;, &quot;eight&quot;, &quot;seven&quot;, &quot;six&quot;, &quot;five&quot;, &quot;four&quot;, &quot;three&quot;, &quot;two&quot;, &quot;one&quot;) for (i in numbers) { cat(str_c(&quot;There were &quot;, i, &quot; in the bed\\n&quot;)) cat(&quot;and the little one said\\n&quot;) if (i == &quot;one&quot;) { cat(&quot;I&#39;m lonely...&quot;) } else { cat(&quot;Roll over, roll over\\n&quot;) cat(&quot;So they all rolled over and one fell out.\\n&quot;) } cat(&quot;\\n&quot;) } #&gt; There were ten in the bed #&gt; and the little one said #&gt; Roll over, roll over #&gt; So they all rolled over and one fell out. #&gt; #&gt; There were nine in the bed #&gt; and the little one said #&gt; Roll over, roll over #&gt; So they all rolled over and one fell out. #&gt; #&gt; There were eight in the bed #&gt; and the little one said #&gt; Roll over, roll over #&gt; So they all rolled over and one fell out. #&gt; #&gt; There were seven in the bed #&gt; and the little one said #&gt; Roll over, roll over #&gt; So they all rolled over and one fell out. #&gt; #&gt; There were six in the bed #&gt; and the little one said #&gt; Roll over, roll over #&gt; So they all rolled over and one fell out. #&gt; #&gt; There were five in the bed #&gt; and the little one said #&gt; Roll over, roll over #&gt; So they all rolled over and one fell out. #&gt; #&gt; There were four in the bed #&gt; and the little one said #&gt; Roll over, roll over #&gt; So they all rolled over and one fell out. #&gt; #&gt; There were three in the bed #&gt; and the little one said #&gt; Roll over, roll over #&gt; So they all rolled over and one fell out. #&gt; #&gt; There were two in the bed #&gt; and the little one said #&gt; Roll over, roll over #&gt; So they all rolled over and one fell out. #&gt; #&gt; There were one in the bed #&gt; and the little one said #&gt; I&#39;m lonely... For the bottles of beer, I define a helper function to correctly print the number of bottles. bottles &lt;- function(i) { if (i &gt; 2) { bottles &lt;- str_c(i - 1, &quot; bottles&quot;) } else if (i == 2) { bottles &lt;- &quot;1 bottle&quot; } else { bottles &lt;- &quot;no more bottles&quot; } bottles } beer_bottles &lt;- function(n) { # should test whether n &gt;= 1. for (i in seq(n, 1)) { cat(str_c(bottles(i), &quot; of beer on the wall, &quot;, bottles(i), &quot; of beer.\\n&quot;)) cat(str_c(&quot;Take one down and pass it around, &quot;, bottles(i - 1), &quot; of beer on the wall.\\n\\n&quot;)) } cat(&quot;No more bottles of beer on the wall, no more bottles of beer.\\n&quot;) cat(str_c(&quot;Go to the store and buy some more, &quot;, bottles(n), &quot; of beer on the wall.\\n&quot;)) } beer_bottles(3) #&gt; 2 bottles of beer on the wall, 2 bottles of beer. #&gt; Take one down and pass it around, 1 bottle of beer on the wall. #&gt; #&gt; 1 bottle of beer on the wall, 1 bottle of beer. #&gt; Take one down and pass it around, no more bottles of beer on the wall. #&gt; #&gt; no more bottles of beer on the wall, no more bottles of beer. #&gt; Take one down and pass it around, no more bottles of beer on the wall. #&gt; #&gt; No more bottles of beer on the wall, no more bottles of beer. #&gt; Go to the store and buy some more, 2 bottles of beer on the wall. Ex 21.2.1.4 It’s common to see for loops that don’t preallocate the output and instead increase the length of a vector at each step: output &lt;- vector(&quot;integer&quot;, 0) for (i in seq_along(x)) { output &lt;- c(output, lengths(x[[i]])) } output I’ll use the package microbenchmark to time this. Microbenchmark will run an R expression a number of times and time it. Define a function that appends to an integer vector. add_to_vector &lt;- function(n) { output &lt;- vector(&quot;integer&quot;, 0) for (i in seq_len(n)) { output &lt;- c(output, i) } output } microbenchmark(add_to_vector(10000), times = 3) #&gt; Unit: milliseconds #&gt; expr min lq mean median uq max neval #&gt; add_to_vector(10000) 183 187 189 191 191 192 3 And one that pre-allocates it. add_to_vector_2 &lt;- function(n) { output &lt;- vector(&quot;integer&quot;, n) for (i in seq_len(n)) { output[[i]] &lt;- i } output } microbenchmark(add_to_vector_2(10000), times = 3) #&gt; Unit: milliseconds #&gt; expr min lq mean median uq max neval #&gt; add_to_vector_2(10000) 7.54 11 13.5 14.4 16.5 18.7 3 The pre-allocated vector is about 100 times faster! YMMV, but the longer the vector and the bigger the objects, the more that pre-allocation will outperform appending. 17.3 For loop variations 17.3.1 Ex Imagine you have a directory full of CSV files that you want to read in. You have their paths in a vector, files &lt;- dir(&quot;data/&quot;, pattern = &quot;\\\\.csv$&quot;, full.names = TRUE), and now want to read each one with read_csv(). Write the for loop that will load them into a single data frame. I pre-allocate a list, read each file as data frame into an element in that list. This creates a list of data frames. I then use bind_rows to create a single data frame from the list of data frames. df &lt;- vector(&quot;list&quot;, length(files)) for (fname in seq_along(files)) { df[[i]] &lt;- read_csv(files[[i]]) } df &lt;- bind_rows(df) Ex What happens if you use for (nm in names(x)) and x has no names? What if only some of the elements are named? What if the names are not unique? Let’s try it out and see what happens. When there are no names for the vector, it does not run the code in the loop (it runs zero iterations of the loop): x &lt;- 1:3 print(names(x)) #&gt; NULL for (nm in names(x)) { print(nm) print(x[[nm]]) } Note that the length of NULL is zero: length(NULL) #&gt; [1] 0 If there only some names, then we get an error if we try to access an element without a name. However, oddly, nm == &quot;&quot; when there is no name. x &lt;- c(a = 1, 2, c = 3) names(x) #&gt; [1] &quot;a&quot; &quot;&quot; &quot;c&quot; for (nm in names(x)) { print(nm) print(x[[nm]]) } #&gt; [1] &quot;a&quot; #&gt; [1] 1 #&gt; [1] &quot;&quot; #&gt; Error in x[[nm]]: subscript out of bounds Finally, if there are duplicate names, then x[[nm]] will give the first element with that name. There is no way to access duplicately named elements by name. x &lt;- c(a = 1, a = 2, c = 3) names(x) #&gt; [1] &quot;a&quot; &quot;a&quot; &quot;c&quot; for (nm in names(x)) { print(nm) print(x[[nm]]) } #&gt; [1] &quot;a&quot; #&gt; [1] 1 #&gt; [1] &quot;a&quot; #&gt; [1] 1 #&gt; [1] &quot;c&quot; #&gt; [1] 3 Ex Write a function that prints the mean of each numeric column in a data frame, along with its name. For example, show_mean(iris) would print: show_mean(iris) #&gt; Sepal.Length: 5.84 #&gt; Sepal.Width: 3.06 #&gt; Petal.Length: 3.76 #&gt; Petal.Width: 1.20 (Extra challenge: what function did I use to make sure that the numbers lined up nicely, even though the variable names had different lengths?) There may be other functions to do this, but I’ll use str_pad, and str_length to ensure that the space given to the variable names is the same. I messed around with the options to format until I got two digits . show_mean &lt;- function(df, digits = 2) { # Get max length of any variable in the dataset maxstr &lt;- max(str_length(names(df))) for (nm in names(df)) { if (is.numeric(df[[nm]])) { cat(str_c(str_pad(str_c(nm, &quot;:&quot;), maxstr + 1L, side = &quot;right&quot;), format(mean(df[[nm]]), digits = digits, nsmall = digits), sep = &quot; &quot;), &quot;\\n&quot;) } } } show_mean(iris) #&gt; Sepal.Length: 5.84 #&gt; Sepal.Width: 3.06 #&gt; Petal.Length: 3.76 #&gt; Petal.Width: 1.20 Ex What does this code do? How does it work? trans &lt;- list( disp = function(x) x * 0.0163871, am = function(x) { factor(x, labels = c(&quot;auto&quot;, &quot;manual&quot;)) } ) for (var in names(trans)) { mtcars[[var]] &lt;- trans[[var]](mtcars[[var]]) } This code mutates the disp and am columns: disp is multiplied by 0.0163871 am is replaced by a factor variable. The code works by looping over a named list of functions. It calls the named function in the list on the column of mtcars with the same name, and replaces the values of that column. E.g. this is a function: trans[[&quot;disp&quot;]] This applies the function to the column of mtcars with the same name trans[[&quot;disp&quot;]](mtcars[[&quot;disp&quot;]]) 17.4 For loops vs. functionals col_summary &lt;- function(df, fun) { out &lt;- vector(&quot;double&quot;, length(df)) for (i in seq_along(df)) { out[i] &lt;- fun(df[[i]]) } out } 17.4.1 Exercises Ex. 21.4.1.1 Read the documentation for apply(). In the 2d case, what two for loops does it generalise. It generalises looping over the rows or columns of a matrix or data-frame. Ex. 21.4.1.2 Adapt col_summary() so that it only applies to numeric columns You might want to start with an is_numeric() function that returns a logical vector that has a TRUE corresponding to each numeric column. col_summary2 &lt;- function(df, fun) { # test whether each colum is numeric numeric_cols &lt;- vector(&quot;logical&quot;, length(df)) for (i in seq_along(df)) { numeric_cols[[i]] &lt;- is.numeric(df[[i]]) } # indexes of numeric columns idxs &lt;- seq_along(df)[numeric_cols] # number of numeric columns n &lt;- sum(numeric_cols) out &lt;- vector(&quot;double&quot;, n) for (i in idxs) { out[i] &lt;- fun(df[[i]]) } out } Let’s test that it works, df &lt;- tibble( a = rnorm(10), b = rnorm(10), c = letters[1:10], d = rnorm(10) ) col_summary2(df, mean) #&gt; [1] 0.0262 -0.3145 0.0000 -0.1516 17.5 The map functions 17.5.1 Shortcuts Notes The lm() function runs a linear regression. It is covered in the Model Basics chapter. 17.5.2 Exercises Ex Write code that uses one of the map functions to: 1. Compute the mean of every column in `mtcars`. 1. Determine the type of each column in `nycflights13::flights`. 1. Compute the number of unique values in each column of `iris`. 1. Generate 10 random normals for each of $\\mu = -10$, $0$, $10$, and $100$. The mean of every column in mtcars: map_dbl(mtcars, mean) #&gt; mpg cyl disp hp drat wt qsec vs am #&gt; 20.091 6.188 230.722 146.688 3.597 3.217 17.849 0.438 0.406 #&gt; gear carb #&gt; 3.688 2.812 The type of every column in nycflights13::flights. map(nycflights13::flights, class) #&gt; $year #&gt; [1] &quot;integer&quot; #&gt; #&gt; $month #&gt; [1] &quot;integer&quot; #&gt; #&gt; $day #&gt; [1] &quot;integer&quot; #&gt; #&gt; $dep_time #&gt; [1] &quot;integer&quot; #&gt; #&gt; $sched_dep_time #&gt; [1] &quot;integer&quot; #&gt; #&gt; $dep_delay #&gt; [1] &quot;numeric&quot; #&gt; #&gt; $arr_time #&gt; [1] &quot;integer&quot; #&gt; #&gt; $sched_arr_time #&gt; [1] &quot;integer&quot; #&gt; #&gt; $arr_delay #&gt; [1] &quot;numeric&quot; #&gt; #&gt; $carrier #&gt; [1] &quot;character&quot; #&gt; #&gt; $flight #&gt; [1] &quot;integer&quot; #&gt; #&gt; $tailnum #&gt; [1] &quot;character&quot; #&gt; #&gt; $origin #&gt; [1] &quot;character&quot; #&gt; #&gt; $dest #&gt; [1] &quot;character&quot; #&gt; #&gt; $air_time #&gt; [1] &quot;numeric&quot; #&gt; #&gt; $distance #&gt; [1] &quot;numeric&quot; #&gt; #&gt; $hour #&gt; [1] &quot;numeric&quot; #&gt; #&gt; $minute #&gt; [1] &quot;numeric&quot; #&gt; #&gt; $time_hour #&gt; [1] &quot;POSIXct&quot; &quot;POSIXt&quot; I had to use map rather than map_chr since the class Though if by type, typeof is meant: map_chr(nycflights13::flights, typeof) #&gt; year month day dep_time sched_dep_time #&gt; &quot;integer&quot; &quot;integer&quot; &quot;integer&quot; &quot;integer&quot; &quot;integer&quot; #&gt; dep_delay arr_time sched_arr_time arr_delay carrier #&gt; &quot;double&quot; &quot;integer&quot; &quot;integer&quot; &quot;double&quot; &quot;character&quot; #&gt; flight tailnum origin dest air_time #&gt; &quot;integer&quot; &quot;character&quot; &quot;character&quot; &quot;character&quot; &quot;double&quot; #&gt; distance hour minute time_hour #&gt; &quot;double&quot; &quot;double&quot; &quot;double&quot; &quot;double&quot; The number of unique values in each column of iris: map_int(iris, ~ length(unique(.))) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 35 23 43 22 3 Generate 10 random normals for each of \\(\\mu = -10\\), \\(0\\), \\(10\\), and \\(100\\): map(c(-10, 0, 10, 100), rnorm, n = 10) #&gt; [[1]] #&gt; [1] -8.42 -9.99 -10.65 -8.14 -9.17 -8.80 -9.40 -9.94 -11.29 -10.13 #&gt; #&gt; [[2]] #&gt; [1] 0.384 -0.542 0.223 -0.645 -0.415 -2.295 -0.632 -0.531 0.710 -0.248 #&gt; #&gt; [[3]] #&gt; [1] 10.68 9.40 10.11 10.37 9.39 11.04 9.70 11.42 9.13 7.78 #&gt; #&gt; [[4]] #&gt; [1] 99.7 100.4 101.0 100.3 101.2 99.7 99.3 98.5 102.5 100.6 Ex How can you create a single vector that for each column in a data frame indicates whether or not it’s a factor? Use map_lgl with the function is.factor, map_lgl(mtcars, is.factor) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE Ex What happens when you use the map functions on vectors that aren’t lists? What does map(1:5, runif) do? Why? The function map applies the function to each element of the vector. map(1:5, runif) #&gt; [[1]] #&gt; [1] 0.133 #&gt; #&gt; [[2]] #&gt; [1] 0.927 0.894 #&gt; #&gt; [[3]] #&gt; [1] 0.204 0.257 0.614 #&gt; #&gt; [[4]] #&gt; [1] 0.441 0.316 0.101 0.273 #&gt; #&gt; [[5]] #&gt; [1] 0.6537 0.9279 0.0266 0.5595 0.8542 Ex What does map(-2:2, rnorm, n = 5) do? Why? What does map_dbl(-2:2, rnorm, n = 5) do? Why? This takes samples of n = 5 from normal distributions of means -2, -1, 0, 1, and 2, and returns a list with each element a numeric vectors of length 5. map(-2:2, rnorm, n = 5) #&gt; [[1]] #&gt; [1] -3.43 -2.01 -2.21 -2.91 -4.10 #&gt; #&gt; [[2]] #&gt; [1] 0.893 -1.968 -1.103 -0.760 -0.939 #&gt; #&gt; [[3]] #&gt; [1] -2.17758 -0.11786 0.11229 0.00789 1.87774 #&gt; #&gt; [[4]] #&gt; [1] 3.159 1.710 1.767 0.692 2.012 #&gt; #&gt; [[5]] #&gt; [1] 1.08 2.56 2.32 2.37 3.13 However, if we use map_dbl it throws an error. map_dbl expects the function to return a numeric vector of length one. map_dbl(-2:2, rnorm, n = 5) #&gt; Error: Result 1 is not a length 1 atomic vector If we wanted a numeric vector, we could use map followed by flatten_dbl, flatten_dbl(map(-2:2, rnorm, n = 5)) #&gt; [1] -2.222 -3.010 -1.519 -0.396 -3.515 -2.416 -0.123 -0.376 1.112 -1.356 #&gt; [11] -1.064 1.077 1.182 0.198 -0.400 1.616 2.974 2.885 -0.589 0.460 #&gt; [21] 0.831 2.559 0.181 2.393 2.042 Ex Rewrite map(x, function(df) lm(mpg ~ wt, data = df)) to eliminate the anonymous function. map(list(mtcars), ~ lm(mpg ~ wt, data = .)) #&gt; [[1]] #&gt; #&gt; Call: #&gt; lm(formula = mpg ~ wt, data = .) #&gt; #&gt; Coefficients: #&gt; (Intercept) wt #&gt; 37.29 -5.34 17.6 Dealing with Failure 17.7 Mapping over multiple arguments 17.8 Walk 17.9 Other patterns of for loops 17.9.1 Exercises Ex Implement your own version of every() using a for loop. Compare it with purrr::every(). What does purrr’s version do that your version doesn’t? # Use ... to pass arguments to the function every2 &lt;- function(.x, .p, ...) { for (i in .x) { if (!.p(i, ...)) { # If any is FALSE we know not all of then were TRUE return(FALSE) } } # if nothing was FALSE, then it is TRUE TRUE } every2(1:3, function(x) {x &gt; 1}) #&gt; [1] FALSE every2(1:3, function(x) {x &gt; 0}) #&gt; [1] TRUE The function purrr::every does fancy things with .p, like taking a logical vector instead of a function, or being able to test part of a string if the elements of .x are lists. Ex Create an enhanced col_sum() that applies a summary function to every numeric column in a data frame. Note this question has a typo. It is referring to col_summary. I will use map to apply the function to all the columns, and keep to only select numeric columns. col_sum2 &lt;- function(df, f, ...) { map(keep(df, is.numeric), f, ...) } col_sum2(iris, mean) #&gt; $Sepal.Length #&gt; [1] 5.84 #&gt; #&gt; $Sepal.Width #&gt; [1] 3.06 #&gt; #&gt; $Petal.Length #&gt; [1] 3.76 #&gt; #&gt; $Petal.Width #&gt; [1] 1.2 Ex A possible base R equivalent of col_sum() is: col_sum3 &lt;- function(df, f) { is_num &lt;- sapply(df, is.numeric) df_num &lt;- df[, is_num] sapply(df_num, f) } But it has a number of bugs as illustrated with the following inputs: df &lt;- tibble( x = 1:3, y = 3:1, z = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) ) # OK col_sum3(df, mean) # Has problems: don&#39;t always return numeric vector col_sum3(df[1:2], mean) col_sum3(df[1], mean) col_sum3(df[0], mean) What causes the bugs? The problem is that sapply doesn’t always return numeric vectors. If no columns are selected, instead of gracefully exiting, it returns an empty list. This causes an error since we can’t use a list with [. sapply(df[0], is.numeric) #&gt; named list() sapply(df[1], is.numeric) #&gt; a #&gt; TRUE sapply(df[1:2], is.numeric) #&gt; a b #&gt; TRUE TRUE "],
["model-intro.html", "18 Introduction", " 18 Introduction Some of the discussion of models is slightly different, and has a different emphasis than in most social science research. This is largely because this book is speaking to data scientists, where the primary goal is prediction rather than theory testing (that I don’t view these as too different is a different story). The discussion about hypothesis generation vs. confirmation is interesting. Too little emphasis is placed on hypothesis generation in social science. The importance of out of sample testing also receives too little emphasis in political science. And from this discussion it should be clear that many papers in social science are hypothesis generation masquerading as hypothesis confirmation. "],
["model-basics.html", "19 Model Basics 19.1 Prerequisites 19.2 A simple model 19.3 Visualizing Models 19.4 Formulas and Model Families 19.5 Missing values 19.6 Other model families", " 19 Model Basics Distinction between family of models and fitted model is a useful way to think about models. Especially as we can abstract some families of models to be themselves a fitted model of a more flexible family of models. For example, linear regression is a special case of GLM or Gaussian Processes etc. 19.1 Prerequisites library(tidyverse) library(modelr) options(na.action = na.warn) The option na.action determines how missing values are handled. It is a function. na.warn sets it so that there is a warning if there are any missing values (by default, R will just silently drop them). 19.2 A simple model ggplot(sim1, aes(x, y)) + geom_point() models &lt;- tibble( a1 = runif(250, -20, 40), a2 = runif(250, -5, 5) ) ggplot(sim1, aes(x, y)) + geom_abline(aes(intercept = a1, slope = a2), data = models, alpha = 1/4) + geom_point() model1 &lt;- function(a, data) { a[1] + data$x * a[2] } model1(c(7, 1.5), sim1) #&gt; [1] 8.5 8.5 8.5 10.0 10.0 10.0 11.5 11.5 11.5 13.0 13.0 13.0 14.5 14.5 #&gt; [15] 14.5 16.0 16.0 16.0 17.5 17.5 17.5 19.0 19.0 19.0 20.5 20.5 20.5 22.0 #&gt; [29] 22.0 22.0 measure_distance &lt;- function(mod, data) { diff &lt;- data$y - model1(mod, data) sqrt(mean(diff ^ 2)) } measure_distance(c(7, 1.5), sim1) #&gt; [1] 2.67 sim1_dist &lt;- function(a1, a2) { measure_distance(c(a1, a2), sim1) } models &lt;- models %&gt;% mutate(dist = purrr::map2_dbl(a1, a2, sim1_dist)) models #&gt; # A tibble: 250 × 3 #&gt; a1 a2 dist #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 30.06 -0.827 13.2 #&gt; 2 16.05 2.269 13.2 #&gt; 3 -10.57 1.377 18.7 #&gt; 4 -19.56 -1.036 41.8 #&gt; 5 7.98 4.595 19.3 #&gt; 6 9.87 -2.013 20.5 #&gt; # ... with 244 more rows ggplot(sim1, aes(x, y)) + geom_point(size = 2, colour = &quot;grey30&quot;) + geom_abline( aes(intercept = a1, slope = a2, colour = -dist), data = filter(models, rank(dist) &lt;= 10) ) grid &lt;- expand.grid( a1 = seq(-5, 20, length = 25), a2 = seq(1, 3, length = 25) ) %&gt;% mutate(dist = purrr::map2_dbl(a1, a2, sim1_dist)) grid %&gt;% ggplot(aes(a1, a2)) + geom_point(data = filter(grid, rank(dist) &lt;= 10), size = 4, colour = &quot;red&quot;) + geom_point(aes(colour = -dist)) ggplot(sim1, aes(x, y)) + geom_point(size = 2, colour = &quot;grey30&quot;) + geom_abline( aes(intercept = a1, slope = a2, colour = -dist), data = filter(grid, rank(dist) &lt;= 10) ) best &lt;- optim(c(0, 0), measure_distance, data = sim1) best$par #&gt; [1] 4.22 2.05 ggplot(sim1, aes(x, y)) + geom_point(size = 2, colour = &quot;grey30&quot;) + geom_abline(intercept = best$par[1], slope = best$par[2]) sim1_mod &lt;- lm(y ~ x, data = sim1) coef(sim1_mod) #&gt; (Intercept) x #&gt; 4.22 2.05 19.2.1 Exercises sim1a &lt;- tibble( x = rep(1:10, each = 3), y = x * 1.5 + 6 + rt(length(x), df = 2) ) lm(y ~ x, data = sim1a) #&gt; #&gt; Call: #&gt; lm(formula = y ~ x, data = sim1a) #&gt; #&gt; Coefficients: #&gt; (Intercept) x #&gt; 6.19 1.51 ggplot(sim1a, aes(x = x, y = y)) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) To re-run this a few times using purrr simt &lt;- function(i) { tibble( x = rep(1:10, each = 3), y = x * 1.5 + 6 + rt(length(x), df = 2), .id = i ) } lm_df &lt;- function(.data) { mod &lt;- lm(y ~ x, data = .data) beta &lt;- coef(mod) tibble(intercept = beta[1], slope = beta[2]) } sims &lt;- map(1:100, simt) %&gt;% map_df(lm_df) ggplot(sims, aes(x = intercept, y = slope)) + geom_point() NOTE It’s not entirely clear what is meant by “visualize the results”. The data are generated from a low-degrees of freedmo t-distribution, so there will be outliers.r4ds Linear regression is One way to make linear models more robust is to use a different distance measure. For example, instead of root-mean-squared distance, you could use mean-absolute distance: measure_distance &lt;- function(mod, data) { diff &lt;- data$y - make_prediction(mod, data) mean(abs(diff)) } To re-run this a few times use purrr simt &lt;- function(i) { tibble( x = rep(1:10, each = 3), y = x * 1.5 + 6 + rt(length(x), df = 2), .id = i ) } lm_df &lt;- function(.data) { mod &lt;- lm(y ~ x, data = .data) beta &lt;- coef(mod) tibble(intercept = beta[1], slope = beta[2]) } sims &lt;- map(1:100, simt) %&gt;% map_df(lm_df) ggplot(sims, aes(x = intercept, y = slope)) + geom_point() One challenge with performing numerical optimisation is that it’s only guaranteed to find one local optima. What’s the problem with optimising a three parameter model like this? model1 &lt;- function(a, data) { a[1] + data$x * a[2] + a[3] } The problem is that you for any values a[1] = a1 and a[3] = a3, any other values of a[1] and a[3] where a[1] + a[3] == (a1 + a3) will have the same fit. 19.3 Visualizing Models More complicated models can be visualized with predictions residuals Notes look at tidyr::complete, tidyr::expand, and modelr::data_grid functions modelr::add_residuals and modelr::add_predictions functions add residuals or predictions to the original data geom_ref_line grid &lt;- sim1 %&gt;% data_grid(x) grid #&gt; # A tibble: 10 × 1 #&gt; x #&gt; &lt;int&gt; #&gt; 1 1 #&gt; 2 2 #&gt; 3 3 #&gt; 4 4 #&gt; 5 5 #&gt; 6 6 #&gt; # ... with 4 more rows grid &lt;- grid %&gt;% add_predictions(sim1_mod) grid #&gt; # A tibble: 10 × 2 #&gt; x pred #&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1 6.27 #&gt; 2 2 8.32 #&gt; 3 3 10.38 #&gt; 4 4 12.43 #&gt; 5 5 14.48 #&gt; 6 6 16.53 #&gt; # ... with 4 more rows ggplot(sim1, aes(x)) + geom_point(aes(y = y)) + geom_line(aes(y = pred), data = grid, colour = &quot;red&quot;, size = 1) sim1 &lt;- sim1 %&gt;% add_residuals(sim1_mod) sim1 #&gt; # A tibble: 30 × 3 #&gt; x y resid #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 4.20 -2.072 #&gt; 2 1 7.51 1.238 #&gt; 3 1 2.13 -4.147 #&gt; 4 2 8.99 0.665 #&gt; 5 2 10.24 1.919 #&gt; 6 2 11.30 2.973 #&gt; # ... with 24 more rows ggplot(sim1, aes(resid)) + geom_freqpoly(binwidth = 0.5) ggplot(sim1, aes(x, resid)) + geom_ref_line(h = 0) + geom_point() 19.3.1 Exercises nstead of using lm() to fit a straight line, you can use loess() to fit a smooth curve. Repeat the process of model fitting, grid generation, predictions, and visualisation on sim1 using loess() instead of lm(). How does the result compare to geom_smooth()? I’ll use add_predictions and add_residuals to add the predictions and residuals from a loess regression to the sim1 data. sim1_loess &lt;- loess(y ~ x, data = sim1) grid_loess &lt;- sim1 %&gt;% add_predictions(sim1_loess) sim1 &lt;- sim1 %&gt;% add_residuals(sim1_loess, var = &quot;resid_loess&quot;) %&gt;% add_predictions(sim1_loess, var = &quot;pred_loess&quot;) This plots the loess predictions. The loess produces a nonlinear, but smooth line through the data. plot_sim1_loess &lt;- ggplot(sim1, aes(x = x, y = y)) + geom_point() + geom_line(aes(x = x, y = pred), data = grid_loess, colour = &quot;red&quot;) plot_sim1_loess The predictions of loess are the same as the default method for geom_smooth because geom_smooth() uses loess() by default; the message even tells us that. plot_sim1_loess + geom_smooth(colour = &quot;blue&quot;, se = FALSE, alpha = 0.20) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; We can plot the residuals (red), and compare them to the residuals from lm (black). In general, the loess model has smaller residuals within the sample (out of sample is a different issue, and we haven’t considered the uncertainty of these estimates). ggplot(sim1, aes(x = x)) + geom_ref_line(h = 0) + geom_point(aes(y = resid)) + geom_point(aes(y = resid_loess), colour = &quot;red&quot;) add_predictions() is paired with gather_predictions() and spread_predictions(). How do these three functions differ? The functions gather_predictions and spread_predictions allow for adding predictions from multiple models at once. What does geom_ref_line() do? What package does it come from? Why is displaying a reference line in plots showing residuals useful and important? The geom geom_ref_line() adds as reference line to a plot. Even though it alters a ggplot2 plot, it is in the modelr package. Putting a reference line at zero for residuals is important because good models (generally) should have residuals centered at zero, with approximately the same variance (or distribution) over the support of x, and no correlation. A zero reference line makes it easier to judge these characteristics visually. Why might you want to look at a frequency polygon of absolute residuals? What are the pros and cons compared to looking at the raw residuals? The frequency polygon makes it easier to judge whether the variance and/or absolute size of the residuals varies with respect to x. This is called heteroskedasticity, and results in incorrect standard errors in inference. In prediction, this provides insight into where the model is working well and where it is not. What is lost, is that since the absolute values are shown, whether the model is over-predicting or underpredicting, or on average correctly predicting in different regions of x cannot be determined. 19.4 Formulas and Model Families df &lt;- tribble( ~y, ~x1, ~x2, 4, 2, 5, 5, 1, 6 ) model_matrix(df, y ~ x1) #&gt; # A tibble: 2 × 2 #&gt; `(Intercept)` x1 #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 2 #&gt; 2 1 1 model_matrix(df, y ~ x1 - 1) #&gt; # A tibble: 2 × 1 #&gt; x1 #&gt; &lt;dbl&gt; #&gt; 1 2 #&gt; 2 1 19.4.1 Categorical Variables df &lt;- tribble( ~ sex, ~ response, &quot;male&quot;, 1, &quot;female&quot;, 2, &quot;male&quot;, 1 ) model_matrix(df, response ~ sex) #&gt; # A tibble: 3 × 2 #&gt; `(Intercept)` sexmale #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 #&gt; 2 1 0 #&gt; 3 1 1 ggplot(sim2) + geom_point(aes(x, y)) mod2 &lt;- lm(y ~ x, data = sim2) grid &lt;- sim2 %&gt;% data_grid(x) %&gt;% add_predictions(mod2) grid #&gt; # A tibble: 4 × 2 #&gt; x pred #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 a 1.15 #&gt; 2 b 8.12 #&gt; 3 c 6.13 #&gt; 4 d 1.91 ggplot(sim3, aes(x1, y)) + geom_point(aes(colour = x2)) mod1 &lt;- lm(y ~ x1 + x2, data = sim3) mod2 &lt;- lm(y ~ x1 * x2, data = sim3) grid &lt;- sim3 %&gt;% data_grid(x1, x2) %&gt;% gather_predictions(mod1, mod2) grid #&gt; # A tibble: 80 × 4 #&gt; model x1 x2 pred #&gt; &lt;chr&gt; &lt;int&gt; &lt;fctr&gt; &lt;dbl&gt; #&gt; 1 mod1 1 a 1.67 #&gt; 2 mod1 1 b 4.56 #&gt; 3 mod1 1 c 6.48 #&gt; 4 mod1 1 d 4.03 #&gt; 5 mod1 2 a 1.48 #&gt; 6 mod1 2 b 4.37 #&gt; # ... with 74 more rows ggplot(sim3, aes(x1, y, colour = x2)) + geom_point() + geom_line(data = grid, aes(y = pred)) + facet_wrap(~ model) sim3 &lt;- sim3 %&gt;% gather_residuals(mod1, mod2) ggplot(sim3, aes(x1, resid, colour = x2)) + geom_point() + facet_grid(model ~ x2) mod1 &lt;- lm(y ~ x1 + x2, data = sim4) mod2 &lt;- lm(y ~ x1 * x2, data = sim4) grid &lt;- sim4 %&gt;% data_grid( x1 = seq_range(x1, 5), x2 = seq_range(x2, 5) ) %&gt;% gather_predictions(mod1, mod2) grid #&gt; # A tibble: 50 × 4 #&gt; model x1 x2 pred #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 mod1 -1.0 -1.0 0.996 #&gt; 2 mod1 -1.0 -0.5 -0.395 #&gt; 3 mod1 -1.0 0.0 -1.786 #&gt; 4 mod1 -1.0 0.5 -3.177 #&gt; 5 mod1 -1.0 1.0 -4.569 #&gt; 6 mod1 -0.5 -1.0 1.907 #&gt; # ... with 44 more rows Function seq_range is useful. ggplot(grid, aes(x1, x2)) + geom_tile(aes(fill = pred)) + facet_wrap(~ model) ggplot(grid, aes(x1, pred, colour = x2, group = x2)) + geom_line() + facet_wrap(~ model) ggplot(grid, aes(x2, pred, colour = x1, group = x1)) + geom_line() + facet_wrap(~ model) TODO We should visualize interactions with plotly 19.4.2 Exercises 19.5 Missing values TODO Need to write a tidyverse compliant na.omit function. 19.6 Other model families NOTE It’s worth mentioning these as more general models. Though they don’t appear as much in social science work. I should try to explain that. I can think of several reasons preference for easy to explain models (though I think that’s wrong–most people can’t visualize high-dimensional space well, and interpret results marginally even though they are conditional) status-quo bias and path dependence combined with lack of knowledge of work outside the field and median lack of technical ability to understand or use these models. the most principled reason is that those modre complicated models really excel in prediction. If we take an agnostic approach to regression, as in the Angrist and Pischke books, then regression isn’t being used to fit \\(f(y | x)\\), its being used to fit \\(E(f(y | x))\\), and more specifically to get some sort of average effect for a change in a specific variable. "],
["model-building.html", "20 Model Building 20.1 Introduction 20.2 Why are low quality diamonds more expensive?", " 20 Model Building 20.1 Introduction library(tidyverse) library(modelr) options(na.action = na.warn) library(&quot;broom&quot;) library(nycflights13) library(lubridate) Notes talks about MASS::rlm() splines 20.2 Why are low quality diamonds more expensive? diamonds2 &lt;- diamonds %&gt;% filter(carat &lt;= 2.5) %&gt;% mutate(lprice = log2(price), lcarat = log2(carat)) mod_diamond2 &lt;- lm(lprice ~ lcarat + color + cut + clarity, data = diamonds2) 20.2.1 Exercises In the plot of lcarat vs. lprice, there are some bright vertical strips. What do they represent? The distribution of diamonds has more diamonds at round or otherwise human friendly numbers (fractions). If log(price) = a_0 + a_1 * log(carat), what does that say about the relationship between price and carat? An 1% increase in carat is associated with an \\(a_1\\)% increase in price. Extract the diamonds that have very high and very low residuals. Is there anything unusual about these diamonds? Are the particularly bad or good, or do you think these are pricing errors? This was already covered in the text. I don’t see anything either. Does the final model, mod_diamonds2, do a good job of predicting diamond prices? Would you trust it to tell you how much to spend if you were buying a diamond? diamonds2 %&gt;% add_predictions(mod_diamond2) %&gt;% add_residuals(mod_diamond2) %&gt;% summarise(sq_err = sqrt(mean(resid^2)), abs_err = mean(abs(resid)), p975_err = quantile(resid, 0.975), p025_err = quantile(resid, 0.025)) #&gt; # A tibble: 1 × 4 #&gt; sq_err abs_err p975_err p025_err #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.192 0.149 0.384 -0.369 The average squared and absolute erorrs are \\(2^0.19 = 1.14\\) and \\(2^0.10\\) so on average, the error is \\(\\pm 10--15\\)%. And the 95% range of residuals is about \\(2^0.37 = 1.3\\) so within \\(\\pm 30\\)%. This doesn’t seem terrible to me. 20.2.2 What affects the number of daily flights? Doesn’t discuss why and how chooses spline of 5 knots. Introduces natural splines library(&quot;nycflights13&quot;) daily &lt;- flights %&gt;% mutate(date = make_date(year, month, day)) %&gt;% group_by(date) %&gt;% summarise(n = n()) daily #&gt; # A tibble: 365 × 2 #&gt; date n #&gt; &lt;date&gt; &lt;int&gt; #&gt; 1 2013-01-01 842 #&gt; 2 2013-01-02 943 #&gt; 3 2013-01-03 914 #&gt; 4 2013-01-04 915 #&gt; 5 2013-01-05 720 #&gt; 6 2013-01-06 832 #&gt; # ... with 359 more rows daily &lt;- daily %&gt;% mutate(wday = wday(date, label = TRUE)) term &lt;- function(date) { cut(date, breaks = ymd(20130101, 20130605, 20130825, 20140101), labels = c(&quot;spring&quot;, &quot;summer&quot;, &quot;fall&quot;) ) } daily &lt;- daily %&gt;% mutate(term = term(date)) mod &lt;- lm(n ~ wday, data = daily) daily &lt;- daily %&gt;% add_residuals(mod) mod1 &lt;- lm(n ~ wday, data = daily) mod2 &lt;- lm(n ~ wday * term, data = daily) 20.2.3 Exercises Ex 1. Use your Google sleuthing skills to brainstorm why there were fewer than expected flights on Jan 20, May 26, and Sep 1. (Hint: they all have the same explanation.) How would these days generalise to another year? These are the Sundays before Monday holidays Martin Luther King Day, Memorial Day, and Labor Day. Ex 2. daily %&gt;% top_n(3, resid) #&gt; # A tibble: 3 × 5 #&gt; date n wday term resid #&gt; &lt;date&gt; &lt;int&gt; &lt;ord&gt; &lt;fctr&gt; &lt;dbl&gt; #&gt; 1 2013-11-30 857 Sat fall 112.4 #&gt; 2 2013-12-01 987 Sun fall 95.5 #&gt; 3 2013-12-28 814 Sat fall 69.4 Ex 3. Create a new variable that splits the wday variable into terms, but only for Saturdays, i.e. it should have Thurs, Fri, but Sat-summer, Sat-spring, Sat-fall How does this model compare with the model with every combination of wday and term? I’ll use the function case_when to do this, though there are other ways which it could be solved. daily &lt;- daily %&gt;% mutate(wday2 = case_when(.$wday == &quot;Sat&quot; &amp; .$term == &quot;summer&quot; ~ &quot;Sat-summer&quot;, .$wday == &quot;Sat&quot; &amp; .$ term == &quot;fall&quot; ~ &quot;Sat-fall&quot;, .$wday == &quot;Sat&quot; &amp; .$term == &quot;spring&quot; ~ &quot;Sat-spring&quot;, TRUE ~ as.character(.$wday))) mod4 &lt;- lm(n ~ wday2, data = daily) daily %&gt;% gather_residuals(sat_term = mod4, all_interact = mod2) %&gt;% ggplot(aes(date, resid, colour = model)) + geom_line(alpha = 0.75) I think the overlapping plot is hard to understand. If we are interested in the differences, it is better to plot the differences directly. In this code I use spread_residuals to add one column per model, rather than gather_residuals which creates a new row for each model. daily %&gt;% spread_residuals(sat_term = mod4, all_interact = mod2) %&gt;% mutate(resid_diff = sat_term - all_interact) %&gt;% ggplot(aes(date, resid_diff)) + geom_line(alpha = 0.75) The model with terms x Saturday has higher residuals in the fall, and lower residuals in the spring than the model with all interactions. Using overall model comparison terms, mod4 has a lower \\(R^2\\) and regression standard error, \\(\\hat\\sigma\\), despite using fewer variables. More importantly for prediction purposes, it has a higher AIC - which is an estimate of the out of sample error. glance(mod4) %&gt;% select(r.squared, sigma, AIC, df) #&gt; r.squared sigma AIC df #&gt; 1 0.736 47.4 3863 9 glance(mod2) %&gt;% select(r.squared, sigma, AIC, df) #&gt; r.squared sigma AIC df #&gt; 1 0.757 46.2 3856 21 Ex. 4 Create a new wday variable that combines the day of week, term (for Saturdays), and public holidays. What do the residuals of that model look like? The question is unclear how to handle the public holidays. We could include a dummy for all public holidays? or the Sunday before public holidays? Including a level for the public holidays themselves is insufficient because (1) public holiday’s effects on travel varies dramatically, (2) the effect can occur on the day itself or the day before and after, and (3) with Thanksgiving and Christmas there are increases in travel as well. daily &lt;- daily %&gt;% mutate(wday3 = case_when( .$date %in% lubridate::ymd(c(20130101, # new years 20130121, # mlk 20130218, # presidents 20130527, # memorial 20130704, # independence 20130902, # labor 20131028, # columbus 20131111, # veterans 20131128, # thanksgiving 20131225)) ~ &quot;holiday&quot;, .$wday == &quot;Sat&quot; &amp; .$term == &quot;summer&quot; ~ &quot;Sat-summer&quot;, .$wday == &quot;Sat&quot; &amp; .$ term == &quot;fall&quot; ~ &quot;Sat-fall&quot;, .$wday == &quot;Sat&quot; &amp; .$term == &quot;spring&quot; ~ &quot;Sat-spring&quot;, TRUE ~ as.character(.$wday))) mod5 &lt;- lm(n ~ wday3, data = daily) daily %&gt;% spread_residuals(mod5) %&gt;% arrange(desc(abs(resid))) %&gt;% slice(1:20) %&gt;% select(date, wday, resid) #&gt; # A tibble: 20 × 3 #&gt; date wday resid #&gt; &lt;date&gt; &lt;ord&gt; &lt;dbl&gt; #&gt; 1 2013-11-28 Thurs -332 #&gt; 2 2013-11-29 Fri -306 #&gt; 3 2013-12-25 Wed -244 #&gt; 4 2013-07-04 Thurs -229 #&gt; 5 2013-12-24 Tues -190 #&gt; 6 2013-12-31 Tues -175 #&gt; # ... with 14 more rows Ex 5. What happens if you fit a day of week effect that varies by month (i.e. n ~ wday * month)? Why is this not very helpful? There are only 4-5 observations per parameter since only there are only 4-5 weekdays in a given month. Ex 6. It will estimate a smooth seasonal trend (ns(date, 5)) with a day of the week cylicality, (wday). It probably will not be effective since Ex 7. We hypothesised that people leaving on Sundays are more likely to be business travellers who need to be somewhere on Monday. Explore that hypothesis by seeing how it breaks down based on distance and time: if it’s true, you’d expect to see more Sunday evening flights to places that are far away. Looking at only day of the week, we see that Sunday flights are on average longer than the rest of the day of the week flights, but not as long as Saturday flights (perhaps vacation flights?). flights %&gt;% mutate(date = make_date(year, month, day), wday = wday(date, label = TRUE)) %&gt;% group_by(wday) %&gt;% summarise(dist_mean = mean(distance), dist_median = median(distance)) %&gt;% ggplot(aes(y = dist_mean, x = wday)) + geom_point() However, breaking it down by hour, I don’t see much evidence at first. Conditional on hour, the distance of Sunday flights seems similar to that of other days (excluding Saturday): flights %&gt;% mutate(date = make_date(year, month, day), wday = wday(date, label = TRUE)) %&gt;% group_by(wday, hour) %&gt;% summarise(dist_mean = mean(distance), dist_median = median(distance)) %&gt;% ggplot(aes(y = dist_mean, x = hour, colour = wday)) + geom_point() + geom_line() Can someone think of a better way to check this? Ex 8. It’s a little frustrating that Sunday and Saturday are on separate ends of the plot. Write a small function to set the levels of the factor so that the week starts on Monday. See the chapter Factors for the function fct_relevel. I use fct_relevel to put all levels in-front of the first level (“Sunday”). monday_first &lt;- function(x) { forcats::fct_relevel(x, levels(x)[-1]) } Now Monday is the first day of the week, daily &lt;- daily %&gt;% mutate(wday = wday(date, label = TRUE)) ggplot(daily, aes(monday_first(wday), n)) + geom_boxplot() + labs(x = &quot;Day of Week&quot;, y = &quot;Number of flights&quot;) "],
["many-models.html", "21 Many Models 21.1 Introduction 21.2 Gapminder 21.3 Creating list-columns 21.4 Simplifying list-columns", " 21 Many Models 21.1 Introduction library(modelr) library(tidyverse) #&gt; Loading tidyverse: ggplot2 #&gt; Loading tidyverse: tibble #&gt; Loading tidyverse: tidyr #&gt; Loading tidyverse: readr #&gt; Loading tidyverse: purrr #&gt; Loading tidyverse: dplyr #&gt; Conflicts with tidy packages ---------------------------------------------- #&gt; filter(): dplyr, stats #&gt; lag(): dplyr, stats library(gapminder) Functions nest unnest glance 21.2 Gapminder 21.2.1 Exercises 25.2.5 A linear trend seems to be slightly too simple for the overall trend. Can you do better with a quadratic polynomial? How can you interpret the coefficients of the quadratic? (Hint you might want to transform year so that it has mean zero.) The following code replicates the analysis in the chapter but the function country_model is replaced with a regression that includes the year squared. lifeExp ~ poly(year, 2) country_model &lt;- function(df) { lm(lifeExp ~ poly(year - median(year), 2), data = df) } by_country &lt;- gapminder %&gt;% group_by(country, continent) %&gt;% nest() by_country &lt;- by_country %&gt;% mutate(model = map(data, country_model)) by_country &lt;- by_country %&gt;% mutate( resids = map2(data, model, add_residuals) ) by_country #&gt; # A tibble: 142 × 5 #&gt; country continent data model resids #&gt; &lt;fctr&gt; &lt;fctr&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 Afghanistan Asia &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt; &lt;tibble [12 × 5]&gt; #&gt; 2 Albania Europe &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt; &lt;tibble [12 × 5]&gt; #&gt; 3 Algeria Africa &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt; &lt;tibble [12 × 5]&gt; #&gt; 4 Angola Africa &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt; &lt;tibble [12 × 5]&gt; #&gt; 5 Argentina Americas &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt; &lt;tibble [12 × 5]&gt; #&gt; 6 Australia Oceania &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt; &lt;tibble [12 × 5]&gt; #&gt; # ... with 136 more rows unnest(by_country, resids) %&gt;% ggplot(aes(year, resid)) + geom_line(aes(group = country), alpha = 1 / 3) + geom_smooth(se = FALSE) #&gt; `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; by_country %&gt;% mutate(glance = map(model, broom::glance)) %&gt;% unnest(glance, .drop = TRUE) %&gt;% ggplot(aes(continent, r.squared)) + geom_jitter(width = 0.5) Ex 25.2.5 Explore other methods for visualising the distribution of \\(R^2\\) per continent. You might want to try the ggbeeswarm package, which provides similar methods for avoiding overlaps as jitter, but uses deterministic methods. See exercise 7.5.1.1.6 for more on ggbeeswarm library(&quot;ggbeeswarm&quot;) by_country %&gt;% mutate(glance = map(model, broom::glance)) %&gt;% unnest(glance, .drop = TRUE) %&gt;% ggplot(aes(continent, r.squared)) + geom_beeswarm() 21.3 Creating list-columns 21.3.1 Exercises Ex. 25.4.5.1 List all the functions that you can think of that take a atomic vector and return a list. E.g. Many of the stringr functions. Ex. 25.4.5.2 Brainstorm useful summary functions that, like quantile(), return multiple values. E.g. range, fivenum. Ex. 25.4.5.3 What’s missing in the following data frame? How does quantile() return that missing piece? Why isn’t that helpful here? mtcars %&gt;% group_by(cyl) %&gt;% summarise(q = list(quantile(mpg))) %&gt;% unnest() #&gt; # A tibble: 15 × 2 #&gt; cyl q #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 21.4 #&gt; 2 4 22.8 #&gt; 3 4 26.0 #&gt; 4 4 30.4 #&gt; 5 4 33.9 #&gt; 6 6 17.8 #&gt; # ... with 9 more rows The particular quantiles of the values are missing, e.g. 0%, 25%, 50%, 75%, 100%. quantile() returns these in the names of the vector. quantile(mtcars$mpg) #&gt; 0% 25% 50% 75% 100% #&gt; 10.4 15.4 19.2 22.8 33.9 Since the unnest function drops the names of the vector, they aren’t useful here. Ex 25.4.5.4 What does this code do? Why might might it be useful? mtcars %&gt;% group_by(cyl) %&gt;% summarise_each(funs(list)) #&gt; # A tibble: 3 × 11 #&gt; cyl mpg disp hp drat wt qsec #&gt; &lt;dbl&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 4 &lt;dbl [11]&gt; &lt;dbl [11]&gt; &lt;dbl [11]&gt; &lt;dbl [11]&gt; &lt;dbl [11]&gt; &lt;dbl [11]&gt; #&gt; 2 6 &lt;dbl [7]&gt; &lt;dbl [7]&gt; &lt;dbl [7]&gt; &lt;dbl [7]&gt; &lt;dbl [7]&gt; &lt;dbl [7]&gt; #&gt; 3 8 &lt;dbl [14]&gt; &lt;dbl [14]&gt; &lt;dbl [14]&gt; &lt;dbl [14]&gt; &lt;dbl [14]&gt; &lt;dbl [14]&gt; #&gt; # ... with 4 more variables: vs &lt;list&gt;, am &lt;list&gt;, gear &lt;list&gt;, #&gt; # carb &lt;list&gt; It creates a data frame in which each row corresponds to a value of cyl, and each observation for each column (other than cyl) is a vector of all the values of that column for that value of cyl. It seems like it should be useful to have all the observations of each variable for each group, but off the top of my head, I can’t think of a specific use for this. But, it seems that it may do many things that dplyr::do does. 21.4 Simplifying list-columns 21.4.1 Exercises Ex 25.5.3.1 Why might the lengths() function be useful for creating atomic vector columns from list-columns? The lengths() function gets the lengths of each element in a list. It could be useful for testing whether all elements in a list-column are the same length. You could get the maximum length to determine how many atomic vector columns to create. It is also a replacement for something like map_int(x, length) or sapply(x, length). Ex 25.5.3.2 List the most common types of vector found in a data frame. What makes lists different? The common types of vectors in data frames are: logical numeric integer character factor All of the common types of vectors in data frames are atomic. Lists are not atomic (they can contain other lists and other vectors). "],
["communicate-intro.html", "22 Introduction", " 22 Introduction "],
["r-markdown.html", "23 R Markdown 23.1 R Markdown Basics 23.2 Text formatting with R Markdown", " 23 R Markdown 23.1 R Markdown Basics Doesn’t describe what YAML is. https://en.wikipedia.org/wiki/YAML The Ansible Guide to YAML is pretty simple; you don’t need to know what Ansible is: http://docs.ansible.com/ansible/YAMLSyntax.html https://learnxinyminutes.com/docs/yaml/ http://codebeautify.org/yaml-validator https://docs.saltstack.com/en/latest/topics/yaml/ 23.1.1 Exercise Create a new notebook using File &gt; New File &gt; R Notebook. Read the instructions. Practice running the chunks. Verify that you can modify the code, re-run it, and see modified output. Nothing to show Create a new R Markdown document with File &gt; New File &gt; R Markdown… Knit it by clicking the appropriate button. Knit it by using the appropriate keyboard short cut. Verify that you can modify the input and see the output update. Compare and contrast the R notebook and R markdown files you created above. How are the outputs similar? How are they different? How are the inputs similar? How are they different? What happens if you copy the YAML header from one to the other? R notebook files show the output inside the editor, while hiding the console. R markdown files shows the output inside the console, and does not show output inside the editor. They differ in the value of output in their YAML headers. The YAML header for the R notebook is ouptut: html_notebook while the header for the R markdown file is ouptut: html_document Create one new R Markdown document for each of the three built-in formats: HTML, PDF and Word. Knit each of the three documents. How does the output differ? How does the input differ? (You may need to install LaTeX in order to build the PDF output — RStudio will prompt you if this is necessary.) They produce different outputs, both in the final documents and intermediate files (notably the type of plots produced). The only difference in the inputs is the value of output in the YAML header: word_document for Word documents, pdf_document for PDF documents, and html_document for HTML documents. 23.2 Text formatting with R Markdown Continue "],
["graphics-for-communication.html", "24 Graphics for communication 24.1 Introduction 24.2 Label 24.3 Annotations 24.4 Scales", " 24 Graphics for communication 24.1 Introduction library(&quot;tidyverse&quot;) #&gt; Loading tidyverse: ggplot2 #&gt; Loading tidyverse: tibble #&gt; Loading tidyverse: tidyr #&gt; Loading tidyverse: readr #&gt; Loading tidyverse: purrr #&gt; Loading tidyverse: dplyr #&gt; Conflicts with tidy packages ---------------------------------------------- #&gt; filter(): dplyr, stats #&gt; lag(): dplyr, stats library(&quot;modelr&quot;) library(&quot;lubridate&quot;) #&gt; Loading required package: methods #&gt; #&gt; Attaching package: &#39;lubridate&#39; #&gt; The following object is masked from &#39;package:base&#39;: #&gt; #&gt; date 24.2 Label ggplot(mpg, aes(displ, hwy)) + geom_point(aes(color = class)) + geom_smooth(se = FALSE) + labs(title = &quot;Fuel efficiency generally decreases with engine size&quot;) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ggplot(mpg, aes(displ, hwy)) + geom_point(aes(color = class)) + geom_smooth(se = FALSE) + labs( title = &quot;Fuel efficiency generally decreases with engine size&quot;, subtitle = &quot;Two seaters (sports cars) are an exception because of their light weight&quot;, caption = &quot;Data from fueleconomy.gov&quot; ) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 24.2.1 Exercises Ex 28.2.1 Create one plot on the fuel economy data with customised title, subtitle, caption, x, y, and colour labels. ggplot(data = mpg, mapping = aes(x = reorder(class, hwy, median), y = hwy)) + geom_boxplot() + coord_flip() + labs( title = &quot;Compact Cars have &gt; 10 Hwy MPG than Pickup Trucks&quot;, subtitle = &quot;Comparing the median highway mpg in each class&quot;, caption = &quot;Data from fueleconomy.gov&quot;, x = &quot;Car Class&quot;, y = &quot;Highway Miles per Gallon&quot; ) Ex 28.2.3 The geom_smooth() is somewhat misleading because the hwy for large engines is skewed upwards due to the inclusion of lightweight sports cars with big engines. Use your modelling tools to fit and display a better model. ggplot(mpg, aes(displ, hwy, colour = class)) + geom_point(aes(colour = class)) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + labs( title = &quot;Fuel efficiency generally decreases with engine size&quot;, subtitle = &quot;Subcompact cars show the greatest sensitivity to engine size&quot;, caption = &quot;Data from fueleconomy.gov&quot; ) mod &lt;- lm(hwy ~ class, data = mpg) mpg %&gt;% add_residuals(mod) %&gt;% ggplot(aes(displ, resid)) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) + labs( title = &quot;Fuel efficiency decreases with engine size&quot;, subtitle = &quot;Highway MPG for Cars After Subtracing Mean MPG of their Class&quot;, caption = &quot;Data from fueleconomy.gov&quot;, x = &quot;Highway MPG Relative to Class&quot;, y = &quot;Engine Displacement&quot; ) Ex 28.2.3. Take an exploratory graphic that you’ve created in the last month, and add informative titles to make it easier for others to understand. Ignoring 24.3 Annotations This section covers annotating (adding labels to data) in a plot. The primary problem that makes this non-trivial is ensuring that the labels do not overlap each other (or other data). When labeling points the package ggrepel dodges labels; but several other annotation methods are also discussed. 24.3.1 Exercise Ex 28.3.1 Use geom_text() with infinite positions to place text at the four corners of the plot. I can use similar code as the example in the text. However, I need to use vjust and hjust in order for the text to appear in the plot, and these need to be different for each corner. But, geom_text takes hjust and vjust as aesthetics, I can add them to the data and mappings, and use a single geom_text call instead of four different geom_text calls with four different data arguments, and four different values of hjust and vjust arguments. label &lt;- tribble( ~displ, ~hwy, ~label, ~vjust, ~hjust, Inf, Inf, &quot;Top right&quot;, &quot;top&quot;, &quot;right&quot;, Inf, -Inf, &quot;Bottom right&quot;, &quot;bottom&quot;, &quot;right&quot;, -Inf, Inf, &quot;Top left&quot;, &quot;top&quot;, &quot;left&quot;, -Inf, -Inf, &quot;Bottom left&quot;, &quot;bottom&quot;, &quot;left&quot; ) ggplot(mpg, aes(displ, hwy)) + geom_point() + geom_text(aes(label = label, vjust = vjust, hjust = hjust), data = label) Ex 28.3.1.2 Read the documentation for annotate(). How can you use it to add a text label to a plot without having to create a tibble? With annotate you use what would be aesthetic mappings directly as arguments: ggplot(mpg, aes(displ, hwy)) + geom_point() + annotate(&quot;text&quot;, x = Inf, y = Inf, label = &quot;Increasing engine size is \\nrelated to decreasing fuel economy.&quot;, vjust = &quot;top&quot;, hjust = &quot;right&quot;) Ex 28.3.1.3 How do labels with geom_text() interact with faceting? How can you add a label to a single facet? How can you put a different label in each facet? (Hint: think about the underlying data.) If the facet variable is not specified, the text is drawn in all facets. label &lt;- tibble( displ = Inf, hwy = Inf, label = &quot;Increasing engine size is \\nrelated to decreasing fuel economy.&quot; ) ggplot(mpg, aes(displ, hwy)) + geom_point() + geom_text(aes(label = label), data = label, vjust = &quot;top&quot;, hjust = &quot;right&quot;, size = 2) + facet_wrap(~ class) To draw the label in only one facet, add a column to the label data frame with the value of the faceting variable(s) in which to draw it. label &lt;- tibble( displ = Inf, hwy = Inf, class = &quot;2seater&quot;, label = &quot;Increasing engine size is \\nrelated to decreasing fuel economy.&quot; ) ggplot(mpg, aes(displ, hwy)) + geom_point() + geom_text(aes(label = label), data = label, vjust = &quot;top&quot;, hjust = &quot;right&quot;, size = 2) + facet_wrap(~ class) To draw labels in different plots, simply have the facetting variable(s): label &lt;- tibble( displ = Inf, hwy = Inf, class = unique(mpg$class), label = stringr::str_c(&quot;Label for &quot;, class) ) ggplot(mpg, aes(displ, hwy)) + geom_point() + geom_text(aes(label = label), data = label, vjust = &quot;top&quot;, hjust = &quot;right&quot;, size = 3) + facet_wrap(~ class) Ex 28.3.1.4 What arguments to geom_label() control the appearance of the background box? label.padding: padding around label label.r: amount of rounding in the corners label.size: size of label border Ex 28.3.1.5 What are the four arguments to arrow()? How do they work? Create a series of plots that demonstrate the most important options. The four arguments are: (from the help for arrow) - angle : angle of arrow head - length : length of the arrow head - ends: ends of the line to draw arrow head - type: &quot;open&quot; or &quot;close&quot;: whether the arrow head is a closed or open triangle TODO 24.4 Scales 24.4.1 Exercises Ex 28.4.4.1 Why doesn’t the following code override the default scale? df &lt;- tibble( x = rnorm(10000), y = rnorm(10000) ) ggplot(df, aes(x, y)) + geom_hex() + scale_colour_gradient(low = &quot;white&quot;, high = &quot;red&quot;) + coord_fixed() It does not override the default scale because the colors in geom_hex are set by the fill aesthetic, not the color aesthetic. ggplot(df, aes(x, y)) + geom_hex() + scale_fill_gradient(low = &quot;white&quot;, high = &quot;red&quot;) + coord_fixed() Ex 28.4.2.2 The first argument to every scale is the label for the scale. It is equivalent to using the labs function. ggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = class)) + geom_smooth(se = FALSE) + labs( x = &quot;Engine displacement (L)&quot;, y = &quot;Highway fuel economy (mpg)&quot;, colour = &quot;Car type&quot; ) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = class)) + geom_smooth(se = FALSE) + scale_x_continuous(&quot;Engine displacement (L)&quot;) + scale_y_continuous(&quot;Highway fuel economy (mpg)&quot;) + scale_colour_discrete(&quot;Car type&quot;) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Ex 28.4.4.3 Change the display of the presidential terms by: 1. Combining the two variants shown above. 2. Improving the display of the y axis. 3. Labelling each term with the name of the president. 4. Adding informative plot labels. 5. Placing breaks every 4 years (this is trickier than it seems!). years &lt;- lubridate::make_date(seq(year(min(presidential$start)), year(max(presidential$end)), by = 4), 1, 1) presidential %&gt;% mutate(id = 33 + row_number(), name_id = stringr::str_c(name, &quot; (&quot;, id, &quot;)&quot;), name_id = factor(name_id, levels = name_id)) %&gt;% ggplot(aes(start, name_id, colour = party)) + geom_point() + geom_segment(aes(xend = end, yend = name_id)) + scale_colour_manual(values = c(Republican = &quot;red&quot;, Democratic = &quot;blue&quot;)) + scale_y_discrete(NULL) + scale_x_date(NULL, breaks = years, date_labels = &quot;&#39;%y&quot;) + theme(panel.grid.minor = element_blank()) Ex 28.4.4.4 Use override.aes to make the legend on the following plot easier to see. ggplot(diamonds, aes(carat, price)) + geom_point(aes(colour = cut), alpha = 1/20) The problem with the legend is that the alpha value make the colors hard to see. So I’ll override the alpha value to make the points solid in the legend. ggplot(diamonds, aes(carat, price)) + geom_point(aes(colour = cut), alpha = 1/20) + theme(legend.position = &quot;bottom&quot;) + guides(colour = guide_legend(nrow = 1, override.aes = list(alpha = 1))) "],
["r-markdown-formats.html", "25 R Markdown Formats", " 25 R Markdown Formats No exercises. This document was built with bookdown. You can see the source at https://github.com/jrnold/e4qf. "],
["r-markdown-workflow.html", "26 R Markdown Workflow", " 26 R Markdown Workflow Notes Find reproducible research articles Need good documentation on YAML and what it is No exercises "]
]
