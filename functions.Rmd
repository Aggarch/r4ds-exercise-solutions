# Functions

## Introduction

- `&&`, `||`, `any`, `all`, `identical`, `dplyr::near`
- `switch`, `cut`
- `stop`, `stopifnot`
- `...`


## When should you write a function?


### Practice

**Ex 1.** Why is TRUE not a parameter to `rescale01()`? What would happen if `x` contained a single missing value, and `na.rm` was `FALSE`?

**Note** By a single missing value, this means that `x` has at least one `NA` value.

If there were any `NA` values, and `na.rm = FALSE`, then the function would 
return `NA`.

I can confirm this by testing a function that allows for `na.rm` as an argument:
```{r}
rescale01_alt <- function(x, finite = TRUE) {
  rng <- range(x, na.rm = finite, finite = finite)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01_alt(c(NA, 1:5), finite = FALSE)
rescale01_alt(c(NA, 1:5), finite = TRUE)
```

**Ex 2.** In the second variant of `rescale01()`, infinite values are left unchanged. Rewrite `rescale01()` so that `-Inf` is mapped to 0, and `Inf` is mapped to 1.

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE, finite = TRUE)
  y <- (x - rng[1]) / (rng[2] - rng[1])
  y[y == -Inf] <- 0
  y[y == Inf] <- 1
  y
}

rescale01(c(Inf, -Inf, 0:5, NA))
```

**Ex 3.** Practice turning the following code snippets into functions. Think about what each function does. What would you call it? How many arguments does it need? Can you rewrite it to be more expressive or less duplicative?

```{r}
mean(is.na(x))

x / sum(x, na.rm = TRUE)

sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE)
```


This function calculates the proportion of `NA` values in a vector:
```{r}
prop_na <- function(x) {
  mean(is.na(x))
}
prop_na(c(NA, 0, NA, 0, NA))
```

This function standardizes a function to its weight. If all elements of `x` are non-negative, this will ensure the vector sums to 1. 
```{r}
weights <- function(x) {
  x / sum(x, na.rm = TRUE)
}
y <- weights(0:5)
y
sum(y)
```

This function calculates the [coefficient of variation](https://en.wikipedia.org/wiki/Coefficient_of_variation) (assuming that `x` can only take non-negative values). 
The coefficient of variation is the standard deviation devided by the mean:
```{r}
coef_variation <- function(x) {
  sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE)
}
coef_variation(runif(10))
```

**Ex 4.** Follow http://nicercode.github.io/intro/writing-functions.html to write your own functions to compute the variance and skew of a numeric vecto

**Note** The math in https://nicercode.github.io/intro/writing-functions.html seems not to be rendering, but I'll write functions for the variance and skewness.

The sample variance is defined as 
$$
Var(x) = \frac{1}{n - 1} \sum_{i=1}^n (x_i - \bar{x}) ^2
$$
where the sample mean is $\bar{x} = (\sum x_i) / n$.
```{r}
variance <- function(x) {
  # remove missing values
  x <- x[!is.na(x)]
  n <- length(x)
  m <- mean(x)
  sq_err <- (x - m) ^ 2
  sum(sq_err) / (n - 1)
}
var(1:10)
variance(1:10)
```

There are multiple definitions of [skewness](https://en.wikipedia.org/wiki/Skewness), but I'll use the method of moments estimator of the population skewness,
$$
b_1 =  \frac{m_3}{s^3} = \frac{\frac{1}{n} \sum (x_i - \bar{x}) ^ 3}{{\left(\frac{1}{n - 1} \sum (x_i - \bar{x}) ^ 2\right)} ^ \frac{3}{2}}
$$
```{r}
skewness <- function(x) {
  x <- x[!is.na(x)] 
  n <- length(x)
  m <- mean(x)
  m3 <- sum((x - m) ^ 3) / n
  s3 <- sqrt(sum((x - m) ^ 2) / (n - 1))
  m3 / s3
}
skewness(rgamma(10, 1, 1))
```

5. Write `both_na()`, a function that takes two vectors of the same length and returns the number of positions that have an `NA` in both vectors.

```{r}
both_na <- function(x, y) {
  sum(is.na(x) & is.na(y))
}
both_na(c(NA, NA,  1, 2),
        c(NA,  1, NA, 2))
both_na(c(NA, NA,  1, 2, NA, NA, 1), 
        c(NA,  1, NA, 2, NA, NA, 1))
```

**Ex. 6** What do the following functions do? Why are they useful even though they are so short?

```{r}
is_directory <- function(x) file.info(x)$isdir
is_readable <- function(x) file.access(x, 4) == 0
```

The function `is_directory` checks whether the path in `x` is a directory.
The function `is_readable` checks whether the path in `x` is readable, meaning that the file exists and the user has permission to open it.
These functions are useful even though they are short because their names make it much clearer what the code is doing.

**Ex 7.** Read the complete lyrics to “Little Bunny Foo Foo”. There’s a lot of duplication in this song. Extend the initial piping example to recreate the complete song, and use functions to reduce the duplication.

This could probably be done cleaner, but here's one version.
```{r eval=FALSE}
threat <- function(chances) {
  give_chances(from = Good_Fairy,
               to = foo_foo,
               number = chances,
               condition = "Don't behave",
               consequence = turn_into_goon)  
}
  
lyric <- function() {
  foo_foo %>%
    hop(through = forest) %>%
    scoop(up = field_mouse) %>%
    bop(on = head)
  
  down_came(Good_Fairy)
  said(Good_Fairy, 
      c("Little bunny Foo Foo",
        "I don't want to see you",
        "Scooping up the field mice"
        "And bopping them on the head.")
}

lyric()
threat(3)
lyric()
threat(2)
lyric()
threat(1)
lyric()
turn_into_goon(Good_Fairy, foo_foo)
             
```


## Functions are for humans and computers

> There are only two hard problems in Computer Science: cache invalidation and naming things. - Phil Karlton (as quoted by many places online but no original source.)

See this Quora discussion: [Why is naming things hard in computer science, and how can it can be made easier?](https://www.quora.com/Why-is-naming-things-hard-in-computer-science-and-how-can-it-can-be-made-easier).

### Exercises

**Ex 1.** Read the source code for each of the following three functions, puzzle out what they do, and then brainstorm better names.

```{r}
f1 <- function(string, prefix) {
  substr(string, 1, nchar(prefix)) == prefix
}

f2 <- function(x) {
  if (length(x) <= 1) return(NULL)
  x[-length(x)]
}

f3 <- function(x, y) {
  rep(y, length.out = length(x))
}
```

The function `f1` returns whether a function has a common prefix.
```{r}
f1(c("str_c", "str_foo", "abc"), "str_")
```
A better name for `f1` is `has_prefix()`

The function `f2` drops the last element:
```{r}
f2(1:3)
f2(1:2)
f2(1)
```
A better name for `f2` is `drop_last()`.

The function `f3` repeats `y` once for each element of `x`.
```{r}
f3(1:3, 4)
```
This is a harder one to name. I would say something like `recycle` (R's name for this behavior), or `epxand`.

**Ex. 2** Take a function that you’ve written recently and spend 5 minutes brainstorming a better name for it and its arguments.

*Don't worry about it*

**Ex. 3** Compare and contrast `rnorm()` and `MASS::mvrnorm()`. How could you make them more consistent?

*You can ignore*

`rnorm` samples from the univariate normal distribution, while `MASS::mvrnorm` samples from the multivariate normal distribution.
The main arguments in `rnorm` are `n`, `mean`, `sd`.
The main arguments is `MASS::mvrnorm` are `n`, `mu`, `Sigma`. 
To be consistent they should have the same names.
However, this is difficult. 
In general, it is better to be consistent with more widely used functions, e.g. `rmvnorm` should follow the conventions of `rnorm`. 
However, while `mean` is correct in the multivariate case, `sd` does not make sense in the multivariate case. 
Both functions an internally consistent though; it would be bad to have `mu` and `sd` or `mean` and `Sigma`.

**Ex. 4**  Make a case for why `norm_r()`, `norm_d()` etc would be better than `rnorm()`, `dnorm()`. Make a case for the opposite.

If named `norm_r` and `norm_d`, it groups the family of functions related to the normal distribution.
If named `rnorm`, and `dnorm`, functions related to are grouped into families by the action they perform. `r*` functions always sample from distributions: `rnorm`, `rbinom`, `runif`, `rexp`. `d*` functions calculate the probability density or mass of a distribution: `dnorm`, `dbinom`, `dunif`, `dexp`.

