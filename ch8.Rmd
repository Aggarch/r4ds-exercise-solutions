---
title: "Ch 8: Strings"
output: html_notebook
---

## Notes

- `str_length`
- `str_c`
- `str_replace_na`
- `str_sub`
- `str_to_uppser`, `str_sort`, `str_to_lower`, `str_order`
- `str_length`, `str_pad`, `str_trim`, `str_sub`
- For regex = `str_view`, `str_view_all`



## Prerequisites

```{r message=FALSE}
library(tidyverse)
library(stringr)
```

## String Basics

### Exercises

1. In code that doesn’t use stringr, you’ll often see `paste()` and `paste0()`. What’s the difference between the two functions? What stringr function are they equivalent to? How do the functions differ in their handling of NA?

The function `paste` seperates strings by spaces by default, while `paste0` does not seperate strings with spaces by default.

```{r}
paste("foo", "bar")
paste0("foo", "bar")
```

Since `str_c` does not seperate strings with spaces by default it is closer in behabior to `paste0`.

```{r}
str_c("foo", "bar")
```

However, `str_c` and the paste ufnction handle NA differently.
The function `str_c` propogates `NA`, if any argument is a missing value, it returns a missing value.
This is in line with how the numeric R functions, e.g. `sum`, `mean`, handle missing values.
However, the paste functions, convert `NA` to the string `"NA"` and then treat it as any other character vector.
```{r}
str_c("foo", NA)
paste("foo", NA)
paste0("foo", NA)
```

2. In your own words, describe the difference between the `sep` and `collapse` arguments to `str_c()`.

The `sep` argument is the string inserted between argugments to `str_c`, while `collapse` is the string used to separate any elements of the character vector into a character vector of length one.

3. Use `str_length()` and `str_sub()` to extract the middle character from a string. What will you do if the string has an even number of characters?

The following function extracts the middle character. If the string has an even number of characters the choice is arbitrary.
We choose to select $\lceil n / 2 \rceil$, because that case works even if the string is only of length one.
A more general method would allow the user to select either the floor or ceiling for the middle character of an even string.
```{r}
x <- c("a", "abc", "abcd", "abcde", "abcdef")
L <- str_length(x)
m <- ceiling(L / 2)
str_sub(x, m, m)
```

4. What does `str_wrap()` do? When might you want to use it?

The function `str_wrap` wraps text so that it fits within a certain width.
This is useful for wrapping long strings of text to be typeset.

5. What does `str_trim()` do? What’s the opposite of `str_trim()`?

The function `str_trim` trims the whitespace from a string.
```{r}
str_trim(" abc ")
str_trim(" abc ", side = "left")
str_trim(" abc ", side = "right")
```

The opposite of `str_trim` is `str_pad` which adds characters to each side.

```{r}
str_pad("abc", 5, side = "both")
str_pad("abc", 4, side = "right")
str_pad("abc", 4, side = "left")
```

6. Write a function that turns (e.g.) a vector c("a", "b", "c") into the string a, b, and c. Think carefully about what it should do if given a vector of length 0, 1, or 2.

*Note:* See Ch 19 for writing functions.

```{r}
str_commasep <- function(x, sep = ", ", last = ", and ") {
  if (length(x) > 1) {
    str_c(str_c(x[-length(x)], collapse = sep),
                x[length(x)],
                sep = last)
  } else {
    x
  }
}
str_commasep("")
str_commasep("a")
str_commasep(c("a", "b"))
str_commasep(c("a", "b", "c"))
```

## Matching Patterns and Regular Expressions

```{r}
x <- c("apple", "banana", "pear")
str_view(x, "an")
str_view(x, ".a.")
```

```{r}
dot <- "\\."
writeLines(dot)
str_view(c("abc", "a.c", "bef"), "a\\.c")
```


### Exercises

1. Explain why each of these strings don’t match a `\`: `"\"`, `"\\"`, `"\\\"`.

- `"\"`: This will escape the next character in the R string.
- `"\\"`: This will resolve to `\` in the regular expression, which will escape the next character in the regular expression.
- `"\\\"`: The first two backslashes will resolve to a literal backslash in the regular expression, the third will escape the next character. So in the regular expresion, this will escape some escaped character.

2. How would you match the sequence `"'\` ?

```{r}
str_view("\"'\\", "\"'\\\\")
```

3. What patterns will the regular expression `\..\..\..` match? How would you represent it as a string?

It will match any patterns that are a dot followed by any character, repeated three times.

```{r}
str_view(c(".a.b.c", ".a.b", "....."), c("\\..\\..\\.."))
```

```{r}
x < c("apple", "banana", "pear")
str_view(x, "^a")
```

```{r}
str_view(x, "a$")
```

```{r}
x <- c("apple pie", "apple", "apple cake")
str_view(x, "apple")
```

```{r}
str_view(x, "^apple$")
```

#### Exercises

1. How would you match the literal string "$^$"?

```{r}
str_view(c("$^$", "ab$^$sfas"), "^\\$\\^\\$$")
```

2. Given the corpus of common words in `stringr::words`, create regular expressions that find all words that:

  1. Start with “y”.
  2. End with “x”
  3. Are exactly three letters long. (Don’t cheat by using `str_length()`!)
  4. Have seven letters or more.
  
Since this list is long, you might want to use the match argument to `str_view()` to show only the matching or non-matching words.

```{r}
head(stringr::words)
```

```{r}
str_view(stringr::words, "^y", match =TRUE)
```

```{r}
str_view(stringr::words, "x$", match = TRUE)
```

```{r}
str_view(stringr::words, "^...$", match = TRUE)
```

A simpler way, shown later is 
```{r, eval=FALSE}
str_view(stringr::words, "^.{3}$", match = TRUE)
```

```{r}
str_view(stringr::words, ".......", match = TRUE)
```

#### Character classes and alternatives

```{r}
str_view(c("grey", "gray"), "gr(e|a)y")
```

##### Exercises


1. Create regular expressions to find all words that:

   1. Start with a vowel.
   2. That only contain consonants. (Hint: thinking about matching “not”-vowels.)
   3. End with `ed`, but not with `eed`.
   4. End with `ing` or `ise`.

Words starting with vowels
```{r}
str_view(stringr::words, "^[aeiou]")
```

Words that contain only consonants
```{r}
str_view(stringr::words, "^[^aeiou]+$", match=TRUE)
```
This seems to require using the `+` pattern introduced later, unless one wants to be very verbose and specify words of certain lengths.

Words that end with `ed` but not with `eed`. This handles the special case of "ed", as well as words with length > 2.
```{r}
str_view(stringr::words, "^ed$|[^e]ed$", match = TRUE)
```

Words ending in ing or ise:
```{r}
str_view(stringr::words, "i(ng|se)$", match = TRUE)
```

2. Empirically verify the rule “i before e except after c”.

Using only what has been introduced thus far: 
```{r}
str_view(stringr::words, "(cei|[^c]ie)", match = TRUE)
```
```{r}
str_view(stringr::words, "(cie|[^c]ei)", match = TRUE)
```

Using `str_detect`:
```{r}
sum(str_detect(stringr::words, "(cei|[^c]ie)"))
sum(str_detect(stringr::words, "(cie|[^c]ei)"))
```

3. Is “q” always followed by a “u”?

In the `stringr::words` dataset, yes. In the full English language, no.
```{r}
str_view(stringr::words, "q[^u]", match = TRUE)
```

4. Write a regular expression that matches a word if it’s probably written in British English, not American English.

Ummm. In the general case, this is hard. But, there are a few heuristics to consider that can get part of the way there: British English uses 

- "ou" instead of "o"
- use of "ae" and "oe" instead of "a" and "o"
- ends in `ise` instead of `ize`
- ending `yse`

`ou|ise^|ae|oe|yse^`

There are others, but https://en.wikipedia.org/wiki/American_and_British_English_spelling_differences but this is not handled best by a regular expression.
It would require a dictionary with differences in spellings for different words.
And even then, a good algorithm would be statistical, inferring the probability that a text or word is using the British spelling rather than some deterministic algorithm.

5. Create a regular expression that will match telephone numbers as commonly written in your country.

Using what has been covered in R4ds thus far,
```{r}
x <- c("123-456-7890", "1235-2351")
str_view(x, "\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d")
```
Using stuff covered in the next section,
```{r}
str_view(x, "\\d{3}-\\d{3}-\\d{4}")
```
Note that this pattern doesn't account for phone numbers that are invalid because of unassigned area code, or special numbers like 911, or for extensions. See https://en.wikipedia.org/wiki/North_American_Numbering_Plan for the complexities of US phone numbers, and http://stackoverflow.com/questions/123559/a-comprehensive-regex-for-phone-number-validation for one discussion of using a regex for phone number validation.




